<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=utf8">
<title>Seed7 マニュアル</title>
<style type="text/css">
<!--
div.top_image {
  position:fixed;
  width:100%;
  height:68px;
  white-space:nowrap;
}

div.space_below_top_image {
  position: fixed;
  top: 68px;
  left: 0;
  width: 100%;
  height:15px;
}

div.menu {
  position:fixed;
  top:85px;
  left:10px;
  bottom:10px;
  width:145px;
  overflow-y:auto;
}

div.content {
  position:fixed;
  top:85px;
  left:165px;
  right:0;
  bottom:10px;
  overflow-y:scroll;
}

a.link:visited { color: mediumblue; text-decoration: none }
a.link:link    { color: blue; text-decoration: none }
a.link:hover   { color: blue; text-decoration: underline }
a.link:active  { color: orange; text-decoration: underline }

a.head:visited { color: cyan;  background-color: mediumblue }
a.head:link    { color: cyan;  background-color: mediumblue }
a.head:hover   { color: white; background-color: mediumblue }
a.head:active  { color: green; background-color: mediumblue }

a.menu:visited { color: indigo; background-color: gainsboro }
a.menu:link    { color: indigo; background-color: gainsboro }
a.menu:hover   { color: red;    background-color: white  }
a.menu:active  { color: green;  background-color: gainsboro }

a.navigation:visited { color: indigo; text-decoration: none; background-color: gainsboro }
a.navigation:link    { color: indigo; text-decoration: none; background-color: gainsboro }
a.navigation:hover   { color: red;    text-decoration: none; background-color: gainsboro }
a.navigation:active  { color: green;  text-decoration: none; background-color: gainsboro }

a.type:visited { color: red; text-decoration: underline }
a.type:link    { color: red; text-decoration: underline }
a.type:hover   { color: navy }
a.type:active  { color: gold }

a.type_no_ul:visited { color: red; text-decoration: none }
a.type_no_ul:link    { color: red; text-decoration: none }
a.type_no_ul:hover   { color: navy; text-decoration: underline }
a.type_no_ul:active  { color: gold; text-decoration: underline }

a.keywd:visited { color: blue; text-decoration: underline }
a.keywd:link    { color: blue; text-decoration: underline }
a.keywd:hover   { color: orange }
a.keywd:active  { color: green }

a.keywd_no_ul:visited { color: blue; text-decoration: none }
a.keywd_no_ul:link    { color: blue; text-decoration: none }
a.keywd_no_ul:hover   { color: orange; text-decoration: underline }
a.keywd_no_ul:active  { color: green; text-decoration: underline }

a.op:visited { color: blue; text-decoration: underline }
a.op:link    { color: blue; text-decoration: underline }
a.op:hover   { color: orange }
a.op:active  { color: green }

a.op_no_ul:visited { color: blue; text-decoration: none }
a.op_no_ul:link    { color: blue; text-decoration: none }
a.op_no_ul:hover   { color: orange; text-decoration: underline }
a.op_no_ul:active  { color: green; text-decoration: underline }

a.comment:visited { color: green; text-decoration: none }
a.comment:link    { color: green; text-decoration: none }
a.comment:hover   { color: darkgreen; text-decoration: underline }
a.comment:active  { color: blue; text-decoration: underline }

a.stri:visited { color: maroon; text-decoration: none }
a.stri:link    { color: maroon; text-decoration: none }
a.stri:hover   { color: brown; text-decoration: underline }
a.stri:active  { color: blue; text-decoration: underline }

a.lib:visited { color: maroon; text-decoration: underline }
a.lib:link    { color: maroon; text-decoration: underline }
a.lib:hover   { color: blue }
a.lib:active  { color: orange }

a.prog:visited { color: darkgreen; text-decoration: underline }
a.prog:link    { color: darkgreen; text-decoration: underline }
a.prog:hover   { color: darkorange }
a.prog:active  { color: orange }

a.func:visited { color: purple; text-decoration: underline }
a.func:link    { color: purple; text-decoration: underline }
a.func:hover   { color: magenta }
a.func:active  { color: olive }

a.func_no_ul:visited { color: black; text-decoration: none }
a.func_no_ul:link    { color: black; text-decoration: none }
a.func_no_ul:hover   { color: magenta; text-decoration: underline }
a.func_no_ul:active  { color: olive; text-decoration: underline }

a.var:visited { color: darkcyan; text-decoration: underline  }
a.var:link    { color: darkcyan; text-decoration: underline  }
a.var:hover   { color: darkred }
a.var:active  { color: gold }

a.var_no_ul:visited { color: darkcyan; text-decoration: none  }
a.var_no_ul:link    { color: darkcyan; text-decoration: none  }
a.var_no_ul:hover   { color: darkred; text-decoration: underline }
a.var_no_ul:active  { color: gold; text-decoration: underline }

a.exception:visited { color: black; text-decoration: none }
a.exception:link    { color: black; text-decoration: none }
a.exception:hover   { color: blue; text-decoration: underline }
a.exception:active  { color: orange; text-decoration: underline }

a.ebnf:visited { color: black; text-decoration: none }
a.ebnf:link    { color: black; text-decoration: none }
a.ebnf:hover   { color: blue; text-decoration: underline }
a.ebnf:active  { color: orange; text-decoration: underline }

span.type    { color: red }
span.keywd   { color: blue }
span.op      { color: blue }
span.comment { color: green }
span.stri    { color: maroon }
span.lib     { color: maroon }
span.prog    { color: darkgreen }
span.func    { color: purple }
span.var     { color: darkcyan }
span.input   { color: green }

span.type_no_ul  { color: red }
span.keywd_no_ul { color: blue }
span.op_no_ul    { color: blue }
span.func_no_ul  { color: purple }
span.var_no_ul   { color: darkcyan }

span.navigation { color: gainsboro; text-decoration: none; background-color: gainsboro }

span.box {
  border: solid 1px black;
  background-color: WhiteSmoke;
  padding: 0px 1px 0px 1px;
  margin: 4px 2px 6px 2px;
}

a.menu, a.head {
  text-decoration: none;
  margin: 0px;
  color: black;
  padding: 0px;
  padding-left: 5px;
  border: 1px solid blue;
  border-top: 0;
  display: block;
  width: 120px;
}

.tt { font-family: monospace; font-size: 10pt; }

body  { font-family: "Segoe UI","Noto Sans",Verdana,sans-serif; font-size: 12pt; }
table { font-size: 12pt; }
tt    { font-size: 10pt; }

pre.tt {
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    color: black;
    margin: 0;
    padding: 0;
}

pre.box {
    border: 1pt dashed black;
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    padding: 1em 0;
    background: #F8F8F8;
    color: black;
}

pre.indent {
    border: 1pt dashed black;
    white-space: pre;
    table-display: fixed;
    white-space: pre-wrap;
    font-size: 10pt;
    overflow: auto;
    padding: 1em 0;
    background: #F8F8F8;
    color: black;
    padding-left: 16px;
}
//-->
</style>
</head>
<body>

<!--[(********************************************************************)
(*                                                                  *)
(*  manual.txt                                                      *)
(*                                                                  *)
(*  Copyright (C) 1989 - 2022  Thomas Mertes                        *)
(*  All rights reserved.                                            *)
(*                                                                  *)
(*  Documentation: Manual for the Seed7 programming language        *)
(*                                                                  *)
(*  This file is distributed "AS IS" in the hope that it will be    *)
(*  useful, but WITHOUT ANY WARRANTY; without even the implied      *)
(*  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*)
(*                                                                  *)
(********************************************************************)]-->
<!--(*--><p></p><hr /><h1 align="center">Seed7プログラミング言語のマニュアル</h1><hr /><!--*)-->

<div>
<h2>目次</h2>

<ol>
<li>
          <a class="link" href="#intro_file_start">
            <big>緒言</big>
          </a>
        <ol>
<li>
          <a class="link" href="#intro_What_is_Seed7">
            <b>Seed7とは?</b>
          </a>
        </li>
<li>
          <a class="link" href="#intro_Why_a_new_programming_language">
            <b>なぜ新しいプログラミング言語なのか?</b>
          </a>
        </li>
<li>
          <a class="link" href="#intro_Features_of_Seed7">
            <b>Seed7の特徴</b>
          </a>
        </li>
<li>
          <a class="link" href="#intro_How_to_read_the_manual">
            <b>本書の読みかた</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#tutorial_file_start">
            <big>チュートリアル</big>
          </a>
        <ol>
<li>
          <a class="link" href="#tutorial_Hello_world">
            <b>Hello world</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Greeting">
            <b>挨拶</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Assignment">
            <b>譲渡</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Constants">
            <b>定数</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_For_loop_and_float_expressions">
            <b>ループ式およびfloat式の場合</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Arrays">
            <b>配列</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Hashes">
            <b>ハッシュ</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_For_loop_and_containers">
            <b>ループ・容器用</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Functions">
            <b>機能</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Parameters">
            <b>パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Overloading">
            <b>オーバーロード</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Templates">
            <b>テンプレート</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Declare_a_statement">
            <b>声明を発表する</b>
          </a>
        </li>
<li>
          <a class="link" href="#tutorial_Template_declaring_a_statement">
            <b>文を宣言するテンプレート</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#decls_file_start">
            <big>宣言</big>
          </a>
        <ol>
<li>
          <a class="link" href="#decls_Variable_declarations">
            <b>変数宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Constant_declarations">
            <b>定数の宣言</b>
          </a>
        <ol>
<li>
          <a class="link" href="#decls_Type_declarations">
            <b>型宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Procedure_declarations">
            <b>プロシージャの宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Function_declarations">
            <b>関数の宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Forward_declarations">
            <b>前方宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Interface_declarations">
            <b>インタフェース宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Abstract_data_types">
            <b>抽象データ型</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Templates">
            <b>テンプレート</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#decls_Initialization">
            <b>初期化</b>
          </a>
        <ol>
<li>
          <a class="link" href="#decls_How_the_initialization_works">
            <b>初期化の仕組み</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#decls_Syntax_declarations">
            <b>構文の宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_System_declarations">
            <b>システム宣言</b>
          </a>
        </li>
<li>
          <a class="link" href="#decls_Pragmas">
            <b>プラグマ</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#stats_file_start">
            <big>定義済みの文</big>
          </a>
        <ol>
<li>
          <a class="link" href="#stats_Assignment">
            <b>譲渡</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_Ignoring_values">
            <b>値を無視する</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_while-statement">
            <b>while文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_repeat-statement">
            <b>反復文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-statement">
            <b>for文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-until-statement">
            <b>for-until文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-step-statement">
            <b>ステップ用命令文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-each-statement">
            <b>for-each文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-each-key-statement">
            <b>for-each-key-statement</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_for-key-statement">
            <b>for-key-statement</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_if-statement">
            <b>if文</b>
          </a>
        </li>
<li>
          <a class="link" href="#stats_case-statement">
            <b>判決理由陳述書</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#types_file_start">
            <big>定義済みタイプ</big>
          </a>
        <ol>
<li>
          <a class="link" href="#types_boolean">
            <b>ブール</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_integer">
            <b>整数</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_bigInteger">
            <b>bigInteger</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_rational">
            <b>合理的な</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_bigRational">
            <b>bigRational</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_float">
            <b>浮かぶ</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_complex">
            <b>複雑なさま</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_char">
            <b>char</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_string">
            <b>文字列</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_array">
            <b>配列</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_hash">
            <b>ハッシュ</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_set">
            <b>設定する</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_struct">
            <b>構造体</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_enumeration">
            <b>列挙</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_bin64">
            <b>bin64</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_bin32">
            <b>ビン32</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_bstring">
            <b>bstring</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_color">
            <b>色</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_time">
            <b>時間</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_duration">
            <b>持続時間</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_file">
            <b>ファイルする</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_text">
            <b>テキスト</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_fileSys">
            <b>fileSys</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_pollData">
            <b>pollData</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_listener">
            <b>聞き手</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_database">
            <b>データベース</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_sqlStatement">
            <b>sqlStatement</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_process">
            <b>プロセス</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_category">
            <b>カテゴリ</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_reference">
            <b>参考</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_ref_list">
            <b>参照リスト</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_structElement">
            <b>structElement</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_program">
            <b>プログラム</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_parseError">
            <b>parseError</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_ptr">
            <b>ptr</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_func">
            <b>機能</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_varfunc">
            <b>varfunc</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_void">
            <b>無</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_proc">
            <b>proc</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_creator">
            <b>作成者</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_destroyer">
            <b>破壊者</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_type">
            <b>タイプ</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_object">
            <b>物</b>
          </a>
        </li>
<li>
          <a class="link" href="#types_expr">
            <b>expr</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#params_file_start">
            <big>パラメータ</big>
          </a>
        <ol>
<li>
          <a class="link" href="#params_val_parameter">
            <b>&#39;val&#39;パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_ref_parameter">
            <b>&#39;ref&#39;パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_in_parameter">
            <b>&#39;in&#39;パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_in_var_parameter">
            <b>&#39;in var&#39;パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_inout_parameter">
            <b>&#39;inout&#39;パラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_call_by_name_parameter">
            <b>Call-by-nameパラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_Symbol_parameter">
            <b>シンボルパラメータ</b>
          </a>
        </li>
<li>
          <a class="link" href="#params_attr_parameter">
            <b>&#39;attr&#39;パラメータ</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#objects_file_start">
            <big>物体の向き</big>
          </a>
        <ol>
<li>
          <a class="link" href="#objects_interface_and_implementation">
            <b>インターフェースおよび実装</b>
          </a>
        </li>
<li>
          <a class="link" href="#objects_dynamic_dispatch">
            <b>ダイナミックディスパッチ</b>
          </a>
        </li>
<li>
          <a class="link" href="#objects_inheritance">
            <b>継承</b>
          </a>
        </li>
<li>
          <a class="link" href="#objects_class_methods">
            <b>クラスメソッド</b>
          </a>
        </li>
<li>
          <a class="link" href="#objects_multiple_dispatch">
            <b>複数発報</b>
          </a>
        </li>
<li>
          <a class="link" href="#objects_replacing_pointers">
            <b>ポインタをインタフェース型に置き換える</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#file_file_start">
            <big>ファイル入出力</big>
          </a>
        <ol>
<li>
          <a class="link" href="#file_Conversion_to_strings_and_back">
            <b>文字列への変換とその逆の変換</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Basic_input_and_output_operations">
            <b>基本的な入出力操作</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Input_and_output_with_conversion">
            <b>換算入力・換算出力</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Simple_read_and_write_statements">
            <b>単純な読み書き文</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Standard_input_and_output_files">
            <b>標準入出力ファイル</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Access_to_operating_system_files">
            <b>オペレーティングシステムファイルにアクセスする</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Keyboard_file">
            <b>キーボードファイル</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Files_with_line_structure">
            <b>行構造のファイル</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Sockets">
            <b>ソケット</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Transport_layer_security">
            <b>Transport Layer Security</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_User_defined_file_types">
            <b>ユーザ定義のファイルタイプ</b>
          </a>
        </li>
<li>
          <a class="link" href="#file_Scanning_a_file">
            <b>ファイルを検索する</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#syntax_file_start">
            <big>構造化構文の定義</big>
          </a>
        <ol>
<li>
          <a class="link" href="#syntax_The_Extended_Backus-Naur_Form">
            <b>拡張バッカス-ナウア形式</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_The_Seed7_Structured_Syntax_Description">
            <b>Seed7構造化構文の説明</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_The_syntax_of_a_statement">
            <b>文の構文</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_Priority_and_associativity">
            <b>優先順位と結合性</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_The_syntax_of_operators">
            <b>演算子の構文</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_Syntax_of_predefined_statements">
            <b>定義済み文の構文</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_Advanced_syntax_definitions">
            <b>高度な構文定義</b>
          </a>
        </li>
<li>
          <a class="link" href="#syntax_Comparison_of_EBNF_and_S7SSD">
            <b>EBNFとS7SSDの比較</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#tokens_file_start">
            <big>トークン</big>
          </a>
        <ol>
<li>
          <a class="link" href="#tokens_White_space">
            <b>空白</b>
          </a>
        <ol>
<li>
          <a class="link" href="#tokens_Spaces">
            <b>スペース</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Comments">
            <b>コメント</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Line_comments">
            <b>行コメント</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#tokens_Identifiers">
            <b>識別子</b>
          </a>
        <ol>
<li>
          <a class="link" href="#tokens_Name_identifiers">
            <b>名前の識別子</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Special_identifiers">
            <b>特別な識別子</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Brackets">
            <b>大括弧</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#tokens_Literals">
            <b>リテラル</b>
          </a>
        <ol>
<li>
          <a class="link" href="#tokens_Integer_literals">
            <b>整数リテラル</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_BigInteger_literals">
            <b>BigIntegerリテラル{{BigInteger:りて</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Float_literals">
            <b>Floatリテラル</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_String_literals">
            <b>文字列リテラル</b>
          </a>
        </li>
<li>
          <a class="link" href="#tokens_Character_literals">
            <b>文字リテラル</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#tokens_Unicode_characters">
            <b>Unicode文字</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#expr_file_start">
            <big>式</big>
          </a>
        <ol>
<li>
          <a class="link" href="#expr_EXPRESSION_Parentheses">
            <b>括弧</b>
          </a>
        </li>
<li>
          <a class="link" href="#expr_Call_expressions">
            <b>式を呼び出す</b>
          </a>
        </li>
<li>
          <a class="link" href="#expr_Dot_expressions">
            <b>ドット表現</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#os_file_start">
            <big>オペレーティング・システムへのアクセス</big>
          </a>
        <ol>
<li>
          <a class="link" href="#os_Standard_path_representation">
            <b>標準パス表現</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_File_properties">
            <b>ファイルのプロパティ</b>
          </a>
        <ol>
<li>
          <a class="link" href="#os_fileType">
            <b>ファイルタイプ</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_fileSize">
            <b>ファイルサイズ</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getFileMode">
            <b>getFileMode</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setFileMode">
            <b>setFileMode</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getATime">
            <b>getATime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setATime">
            <b>setATime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getCTime">
            <b>getCTime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getMTime">
            <b>getMTime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setMTime">
            <b>setMTime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getOwner">
            <b>getOwner</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setOwner">
            <b>所有者を設定する</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getGroup">
            <b>getGroup</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setGroup">
            <b>setGroup</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#os_Symbolic_links">
            <b>シンボリック・リンク</b>
          </a>
        <ol>
<li>
          <a class="link" href="#os_readLink">
            <b>readLink</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_finalPath">
            <b>finalPath</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_makeLink">
            <b>makeLink</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getFileMode_SYMLINK">
            <b>シンボリックリンクgetFileMode</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getATime_SYMLINK">
            <b>シンボリックリンクgetATime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getMTime_SYMLINK">
            <b>シンボリックリンクgetMTime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setMTime_SYMLINK">
            <b>シンボリックリンクsetMTime</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getOwner_SYMLINK">
            <b>シンボリックリンクgetOwner</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setOwner_SYMLINK">
            <b>シンボリックリンクの所有者</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getGroup_SYMLINK">
            <b>シンボリックリンクgetGroup</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setGroup_SYMLINK">
            <b>シンボリックリンクsetGroup</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#os_Directory_functions">
            <b>ディレクトリ機能</b>
          </a>
        <ol>
<li>
          <a class="link" href="#os_readDir">
            <b>readDir</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_openDir">
            <b>openDir</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getcwd">
            <b>getcwd</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_chdir">
            <b>chdir</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_makeDir">
            <b>makeDir</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_homeDir">
            <b>ホームディレクトリ</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#os_Maintenance functions">
            <b>メンテナンス機能</b>
          </a>
        <ol>
<li>
          <a class="link" href="#os_removeFile">
            <b>removeFile</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_removeTree">
            <b>removeTree</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_copyFile">
            <b>copyFile</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_cloneFile">
            <b>cloneFile</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_moveFile">
            <b>moveFile</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#os_Environment">
            <b>環境</b>
          </a>
        <ol>
<li>
          <a class="link" href="#os_argv_PROGRAM">
            <b>argv(PROGRAM)</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_name_PROGRAM">
            <b>name(PROGRAM)</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_path_PROGRAM">
            <b>path(PROGRAM)</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_dir_PROGRAM">
            <b>dir(PROGRAM)</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_file_PROGRAM">
            <b>ファイル(PROGRAM)</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_getenv">
            <b>getenv</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_setenv">
            <b>setenv</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_unsetenv">
            <b>unsetenv</b>
          </a>
        </li>
<li>
          <a class="link" href="#os_environment">
            <b>環境</b>
          </a>
        </li></ol></li></ol></li>
<li>
          <a class="link" href="#database_file_start">
            <big>データベース抽象化API</big>
          </a>
        <ol>
<li>
          <a class="link" href="#database_Opening_a_database_connection">
            <b>データベース接続を開く</b>
          </a>
        <ol>
<li>
          <a class="link" href="#database_Opening_an_Oracle_database_connection">
            <b>Oracleデータベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Opening_a_Db2_database_connection">
            <b>Db2データベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Opening_a_SQL_Server_database_connection">
            <b>SQL Serverデータベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Opening_a_SQLite_database_connection">
            <b>SQLiteデータベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Opening_an_Informix_database_connection">
            <b>Informixデータベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Opening_an_ODBC_database_connection">
            <b>ODBCデータベース接続を開く</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#database_Other_ways_to_open_a_database_connection">
            <b>他の方法でデータベース接続を開く</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Prepared_statements">
            <b>準備文</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Bind_values_to_placeholders">
            <b>値をプレースホルダにバインドする</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Execute_a_prepared_statement">
            <b>プリペアードステートメントの実行</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Fetch_records_from_the_result_set">
            <b>結果セットからレコードを取得する</b>
          </a>
        </li>
<li>
          <a class="link" href="#database_Get_columns_from_fetched_records">
            <b>フェッチしたレコードから列を取得する</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#graphic_file_start">
            <big>グラフィックライブラリ</big>
          </a>
        <ol>
<li>
          <a class="link" href="#graphic_Basics">
            <b>基本</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#actions_file_start">
            <big>原始的な行動</big>
          </a>
        <ol>
<li>
          <a class="link" href="#actions_ACTION">
            <b>ACTIONタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_array">
            <b>配列型に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_bigInteger">
            <b>bigInteger型に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_binary">
            <b>タイプbin32およびbin64に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_boolean">
            <b>タイプブールのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_bstring">
            <b>文字列に対する操作</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_char">
            <b>char型に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_commands">
            <b>各種ディレクトリ、ファイル、およびその他のコマンドに対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_console_output">
            <b>テキスト(コンソール)画面出力に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_declarations">
            <b>宣言に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_graphic_output">
            <b>グラフィック出力を行うためのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_enumeration">
            <b>列挙型のアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_clib_file">
            <b>clib_fileタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_float">
            <b>float型のアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_graphic_keyboard">
            <b>グラフィックキーボードをサポートするためのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_hash">
            <b>ハッシュタイプに対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_integer">
            <b>integer型に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_interface">
            <b>インタフェースタイプに対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_console_keyboard">
            <b>テキスト(コンソール)画面のキーボードをサポートするアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_list">
            <b>リストタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_process">
            <b>タイププロセスのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_pointList">
            <b>pointListタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_pollData">
            <b>pollDataタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_proc">
            <b>proc操作およびステートメントに対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_program">
            <b>タイププログラムのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_reference">
            <b>型参照に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_ref_list">
            <b>ref_list型のアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_struct">
            <b>構造体型に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_structElement">
            <b>タイプstructElementのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_set">
            <b>セットタイプに対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_PRIMITIVE_SOCKET">
            <b>PR IMERIC_SOCKETタイプのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_database">
            <b>タイプのデータベースとsqlStatementのアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_string">
            <b>タイプ文字列に対するアクション</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_time">
            <b>型時間の動作</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_type">
            <b>タイプに対するアクションタイプ</b>
          </a>
        </li>
<li>
          <a class="link" href="#actions_utf8File">
            <b>「utf 8ファイル」タイプのアクション</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#ffi_file_start">
            <big>外部関数インターフェース</big>
          </a>
        <ol>
<li>
          <a class="link" href="#ffi_C_types_used_by_the_implementation">
            <b>実装で使われているC言語の型</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_System_variables">
            <b>システム変数</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_String_conversions">
            <b>文字列の変換</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Operating_system_string_and_path_conversions">
            <b>オペレーティング・システムの文字列とパスの変換</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Macros_to_access_the_action_parameters">
            <b>アクションパラメータにアクセスするためのマクロ</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Functions_to_create_action_results">
            <b>アクション結果を出す機能</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Memory_management_macros">
            <b>メモリ管理マクロ</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Basic_conversion_functions">
            <b>基本的な変換関数</b>
          </a>
        </li>
<li>
          <a class="link" href="#ffi_Error_handling">
            <b>エラー処理</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#errors_file_start">
            <big>エラー</big>
          </a>
        <ol>
<li>
          <a class="link" href="#errors_Parsing_errors">
            <b>解析エラー</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Compilation_errors">
            <b>コンパイルエラー</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Exceptions">
            <b>例外</b>
          </a>
        <ol>
<li>
          <a class="link" href="#errors_MEMORY_ERROR">
            <b>メモリエラー</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_NUMERIC_ERROR">
            <b>NUMERIC_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_OVERFLOW_ERROR">
            <b>OVERFLOW_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_INDEX_ERROR">
            <b>INDEX_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_RANGE_ERROR">
            <b>範囲エラー</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_FILE_ERROR">
            <b>FILE_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_DATABASE_ERROR">
            <b>DATABASE_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_GRAPHIC_ERROR">
            <b>GRAPHIC_ERROR</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_ILLEGAL_ACTION">
            <b>ILLEGAL_ACTION</b>
          </a>
        </li></ol></li>
<li>
          <a class="link" href="#errors_Handlers">
            <b>ハンドラ</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Trace_exceptions">
            <b>例外をトレースする</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Stack_trace">
            <b>スタック・トレース</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Suppressing_exception_checks">
            <b>例外チェックの抑止</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Signals">
            <b>シグナル</b>
          </a>
        </li>
<li>
          <a class="link" href="#errors_Other_errors_and_warnings">
            <b>その他のエラーと警告</b>
          </a>
        </li></ol></li>
</ol></div>
          <a name="intro_file_start"></a>
        <p></p>
          <a name="intro_INTRODUCTION">
        <h2>1緒言</h2>
          </a>
        <p></p>
          <a name="intro_What_is_Seed7">
        <h3>1.1Seed7とは</h3>
          </a>
        <p>Seed7は汎用プログラミング言語です。 Ada、C++、Javaと比較して高レベルの言語です。 Seed7では、新しい文と演算子を簡単に定義できます。 型の結果と型パラメータを持つ関数は、通常のテンプレートやジェネリックスの概念よりもエレガントです。 オブジェクト指向は、他のソリューションがより明白な場所ではなく、利点をもたらす場合に使用されます。 Seed7は他のプログラム言語のいくつかの概念を含んでいますが、一般に他のプログラム言語の直接の子孫とは見なされていません。</p><p>プログラマーは、管理や何らかのパラダイムの実現ではなく、問題解決に集中すべきです。 したがって、Seed7では、すべてを小さな構文的または意味的な概念に変換するのではなく、「問題空間」でプログラミングすることができます。 Seed7の定義済みコンストラクトは、読みやすく理解しやすいように定義されています。 この実践的なアプローチは、以下のように要約することができる。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5"><tr><td>
          <big>
            <b>プログラミングは楽しくなくてはいけない</b>
          </big>
        </td></tr></table></dd></dl><p>第7種プログラムはインタープリトまたはコンパイルが可能です。 したがって、Seed7はスクリプトや「実際の」プログラムに使用できます。</p>
          <a name="intro_Why_a_new_programming_language">
        <h3>1.2なぜ新しいプログラミング言語なのか?</h3>
          </a>
        <p>従来のプログラミング言語には、しっかりとした構文構造が与えられている。 文、演算子、宣言、手続き、および関数の形式は言語定義で固定されており、ユーザーが変更することはできません。 新しいプロシージャ、関数、および一部の言語では新しい演算子のみを宣言できます。 ただし、プロシージャ、関数、演算子の構文は変更できません。 この厳密なパターンはプログラムの移植性には好ましいが、プログラミング言語の改良はほとんど不可能である。 しかし、既存の弱点を修復し、新しいより明白な構成体を導入し、プログラミング言語を異なるアプリケーション領域に適応させるために、拡張が望ましい。 例:数学の分野では、行列演算子とベクトル演算子を導入することで、プログラムの読みやすさを大幅に向上させることができます。 ベクトルの内積と外積を宣言した後は、次のように記述できます。</p><pre class="indent">
v1:=v2
v3;write(v1*v2);
<span class="op">渡る</span></pre><p>データベース内のデータを検索するプログラムは、for文を使用してテーブルをループすることで、より理解しやすくなります。 このようなfor文の使用方法は次のとおりです。</p><pre class="indent">人物1、人物2


person1.mother=person2.mother

person1&lt;>person2

writeln(
&lt;&amp;person2.name);

;
<span class="keywd">の</span>ここで:<span class="keywd">person1.age=person2.age</span>および<span class="op">および</span>do<span class="op">「双子:」</span>&lt;&amp;person1.name&lt;&amp;<span class="keywd">&quot;と&quot;</span>終わる<span class="stri"></span><span class="stri"></span><span class="keywd"></span></pre><p>このような拡張機能により、プログラムの理解、変更、およびデバッグが容易になります。</p>
          <a name="intro_Features_of_Seed7">
        <h3>1.3Seed7の特徴</h3>
          </a>
        <p>Seed7には以下の特徴があります。</p><ul>
    <li>ユーザ定義の文と演算子。</li>

    <li>型はファーストクラス・オブジェクトであるため、テンプレートと総称は特別な構文がなくても簡単に定義できます。</li>

    <li>配列やforループのような定義済みの構造は、言語自体で定義されています。</li>

    <li><a class="link" href="#objects_file_start">オブジェクト指向</a>はインタフェースをベースにしており、複数のディスパッチをサポートし、メソッドをオブジェクトに接続できる。</li>

    <li><span class="link">静的型チェック</span>およびno<span class="link">自動鋳造</span></li>

    <li>あり<a class="link" href="#errors_Exceptions">例外処理</a></li>

    <li>のチェックがあります。<a class="link" href="#errors_INDEX_ERROR">配列の添字</a>および<span class="link">integer overflow</span></li>

    <li><a class="link" href="#tutorial_Overloading">オーバーロード</a>手順/関数/演算子/文の</li>

    <li>サイズ変更可能などのさまざまな定義済みタイプ<a class="type" href="#types_array">配列</a><a class="type" href="#types_hash">ハッシュ</a><a class="type" href="#types_set">ビットセット</a><a class="type" href="#types_struct">構造体</a>など</li>
</ul><p>しかし、新しいプログラミング言語は、新しい機能によって既存のプログラミング言語と異なるだけではありません。 本当の利点は、時代遅れの機能を省くことにあります。</p><p>他の言語で使用されているいくつかの概念が存在しない</p><ul>
    <li>ヌルはありません。</li>

    <li>goto文はありません。 隠されたgotoのような<span class="link">break-and continue-ステートメント</span>も省略されます。</li>

    <li>return文はありません。 その代わりに、関数の結果を割り当てることができる結果変数を定義することができます。</li>

    <li>存在しない<span class="link">自動型変換</span>サブプログラムを異なる型に使用する必要がある場合、それをオーバーロードする必要があります。</li>

    <li>C言語のswitch文のような、制御フローの暗黙的なfall-throughはありません。</li>

    <li>存在しない<span class="link">定義されていない振</span></li>

    <li>マニュアルはありません<span class="link">記憶域管理</span></li>

    <li>存在しない<span class="link">&quot;言ったことをやってください&quot;</span>ヒューリスティックでは、コンパイラがプログラマの心を読み取ろうとします。</li>

    <li>デフォルトで存在すべき言語機能に対応するプリプロセッサがありません。</li>

    <li>存在しない<span class="link">可変長パラメータリスト</span>代わりに、配列をパラメータとして使用することができます。</li>

    <li>省略時パラメーターはありません。 しかし、2つのサブプログラムを定義するのは簡単です。 追加パラメータを持つものと持たないものです。</li>

    <li>「self」や「this」という特別な「パラメータ」はありません。 プロシージャで、受信オブジェクトがユーザー定義名を持つ仮パラメータとして定義されます。</li>

    <li>この機能はサブプログラム機能と非常に似ているため、マクロ機能はありません。 かわりに、他の言語よりも柔軟な方法でサブプログラムを使用できます。</li>

    <li>存在しない<span class="link">予約語</span></li>

    <li>ファンクション、演算子、プロシージャおよび文に概念上の区別はありません。</li>

    <li>プロシージャ呼出しの仕組みは、オブジェクトとメッセージのペア(オブジェクトがメッセージを受信する)という概念に基づいていません。 その代わりに、オブジェクトのリストに対して照合が行われます。 このより一般的な(そして強力な)メカニズムは多重ディスパッチと呼ばれ、特殊なケースとして単純なオブジェクト・メッセージ・メカニズムが含まれています。</li>
</ul><p>他の言語でも使用されている概念がいくつかあります。</p><ul>
    <li><a class="link" href="#tokens_Comments">ブロックコメント</a>で始まる<a class="comment" href="#tokens_Comments">(*で終わり、*で終わる)</a>入れ子にすることもできます。</li>

    <li><a class="link" href="#tokens_Line_comments">行コメント</a>で始まる<a class="comment" href="#tokens_Line_comments">#そして行末で終了します。</a></li>
</ul><p>新しい概念がいくつかある。</p><ul>
    <li>変数および定数は、定義時に初期化する必要があります。</li>

    <li>すべての式は型を1つだけ持ちます。 つまり、オーバーロードされた関数は、呼び出しのコンテキストではなく、実際のパラメータで解決されます。 (これは、ADAで使用されるオーバーロードの仕組みとは異なります。</li>

    <li>構文の宣言により新しい演算子と文を定義することができます。</li>

    <li>定義済みの演算子記号だけでなく、他の演算子記号も多重定義することができます。 さらに、まったく新しい演算子記号を発明することが可能である。</li>
</ul><p>他の言語のいくつかの制限がリリースされる</p><ul>
    <li>識別子の長さに制限はなく、識別子のすべての文字が意味を持ちます。</li>

    <li>文や括弧の入れ子の深さに制限はありません。</li>

    <li>パラメータとローカル変数の数に制限はありません。</li>

    <li><a class="link" href="#types_string">文字列</a>任意の文字(NUL文字も含む)を使用できます。 これにより、文字列内にバイナリ情報を保持できます。</li>

    <li>文字列はNUL終端されていませんが、サイズ制限はありません。 (メモリがない場合を除く)</li>

    <li><a class="link" href="#tokens_String_literals">文字列リテラル</a>の長さは任意である。</li>

    <li>ソース線の長さには制限はない。</li>

    <li>ネストするincludeのレベル制限はありません。</li>
</ul>
          <a name="intro_How_to_read_the_manual">
        <h3>1.4取扱説明書の見方</h3>
          </a>
        <p>Seed7プログラミング言語には複数のビューを使用できます。 ビューに応じて、特定の章に集中できます。</p><p>例えば、Seed7は、従来のプログラミング言語として使用することができます。 この場合、ステートメントがどのように表示されるか、どのタイプが使用できるか、どの演算子が事前定義されているか、変数やプロシージャをどのように宣言するかなどに関心があります。 ステートメントおよび事前定義タイプの説明は<a class="link" href="#stats_file_start">第4章(定義済みステートメント)</a>および<a class="link" href="#types_file_start">第5章(事前定義型)</a>宣言メカニズムは<a class="link" href="#decls_file_start">第3章(宣言)</a></p><p>しかし、Seed7はオブジェクト指向プログラミング言語でもあります。 ここでは、新規クラスの定義方法、インスタンスの生成方法、メソッド呼び出しメカニズム、定義済みのクラス階層などについて説明します。 Seed7のオブジェクト指向は、で説明されています。<a class="link" href="#objects_file_start">第7章オブジェクトのオリエンテーション</a>クラスとインスタンスの良い例は、で説明されているファイルシステムです。<a class="link" href="#file_file_start">第8章(ファイルシステム)</a></p><p>また、Seed7は拡張可能なプログラミング言語でもあります。 この場合、新しい文の宣言方法、新しい演算子の定義方法、演算子への優先順位と結合性の割り当て、その他の事項に関心があります。 構文宣言の概要については、以下を参照してください。<a class="link" href="#decls_Syntax_declarations">3.2章(構文の宣言)</a>Seed7構文定義の詳細な説明は<a class="link" href="#syntax_file_start">第9章(構造化構文定義)</a><a class="link" href="#stats_file_start">第4章(定義済み文)</a>には、構文と意味宣言のさまざまな例が記載されています。 構文の基本的な部分の説明は<a class="link" href="#tokens_file_start">第10章(トークン)</a>および<a class="link" href="#expr_file_start">第11章(式)</a></p>
          <a name="tutorial_file_start"></a>
        <p></p>
          <a name="tutorial_TUTORIAL">
        <h2>2. チュートリアル</h2>
          </a>
          <a name="tutorial_Hello_world">
        <h3>2.1 Hello world</h3>
          </a>
        <p>以下は、Seed7のhello worldプログラムです。</p><pre class="indent">
$
;






);

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">begin</span>writeln<span class="keywd">(</span>&quot;hello world&quot;<span class="func_no_ul">関数終了</span><a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span></pre><p>このプログラムをhello.sd7ファイルに保存し、コンソールで次のように起動します。</p><pre class="indent">s7 hello
</pre><p>Seed7インタプリタは以下のように記述します。</p><pre class="indent">SEED7 INTERPRETER Version 5.1.790 Copyright(c)1990-2023 Thomas Mertes
hello world
</pre><p>Seed7インタプリタとhello.sd7プログラムの出力に関する情報が表示されます。</p><pre class="indent">hello world
</pre><p>オプション<span class="link"><tt>-q</tt></span>を使用すると、Seed7インタプリタの情報行を抑制できます。</p><pre class="indent">s7-q hello
</pre><p>プログラムの最初の行</p><pre class="indent">
$
;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span></pre><p>に、標準ライブラリの定義をすべて示します。 他のライブラリとは対照的に、seed7_05.s7iライブラリには関数宣言だけでなく、ステートメントと演算子の宣言も含まれています。 さらに、seed7_05.s7iライブラリは<tt><span class="func">主要な</span></tt>機能をSeed7プログラムのエントリーポイントとして使用します。</p><p>上の例では<tt><span class="func">主要な</span></tt>は定数として宣言され<tt><a class="type" href="#types_proc">proc</a></tt>は<tt><span class="func">主要な</span></tt>宣言<tt><span class="func">主要な</span></tt>そのタイプで<tt><a class="type" href="#types_proc">proc</a></tt>そこから手続きを作る。 オブジェクトは<tt><span class="func">主要な</span></tt>を取得します。</p><pre class="indent"><span class="keywd">機能</span><span class="keywd">関数終了</span></pre><p>値として構築します。 その<tt>&#39;<span class="keywd">機能</span>&#39;</tt>構成はに類似している<tt><span class="keywd">begin</span><span class="keywd">終わり</span></tt>PASCALと<tt>{.}</tt>in C. Inside the<tt>&#39;<span class="keywd">機能</span>&#39;</tt>は<tt><span class="func">writeln</span></tt>ステートメントを<tt><a class="stri" href="#tokens_String_literals">&quot;hello world&quot;</a></tt>文字列。 その<tt><span class="func">writeln</span></tt>ステートメントは<tt><a class="type" href="#types_string">文字列</a></tt>その後に改行文字が続きます。</p>
          <a name="tutorial_Greeting">
        <h3>2.2挨拶</h3>
          </a>
        <p>以下のプログラムは、小さなダイアログを起動します。</p><pre class="indent">
$
;






;



);

(名称)

);

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:name</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>書く<a class="stri" href="#tokens_String_literals">(</a>「あなたのお名前は?」<span class="keywd">readln</span>writeln<span class="func_no_ul">(</span>「ハイ」<a class="stri" href="#tokens_String_literals"></a>&lt;&amp;<span class="func_no_ul">名前</span>&lt;&amp;<span class="func_no_ul"></span>&quot;!&quot;<a class="stri" href="#tokens_String_literals">関数終了</a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span></pre><p>このプログラムを「greeting.sd7」ファイルに保存し、コンソールで次のように起動します。</p><pre class="indent">s7挨拶
</pre><p>次のようにお名前をお尋ねします。</p><pre class="indent">お名前は?
</pre><p>名前を入力してEnterを押すと、挨拶が表示されます。 このプログラムは、変数を使用する<tt>&#39;name&#39;</tt>入力した名前を保存します。 変数を定義する必要があります。 関数のすべての変数を定義および初期化する場所は、キーワードの後です。<span class="keywd">地域の</span></p><pre class="indent">;
<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type_no_ul" href="#types_string">文字列</a>:name<span class="keywd">は</span><a class="stri" href="#tokens_String_literals">&quot;&quot;</a></pre><p>これは<tt><a class="type" href="#types_string">文字列</a></tt>変わりやすい<tt>&#39;name&#39;</tt>この定義では、初期値も割り当てられます。<a class="stri" href="#tokens_String_literals">&quot;&quot;</a>へ<tt>&#39;name&#39;</tt>・値<a class="stri" href="#tokens_String_literals">&quot;&quot;</a>が空の文字列の場合(何も文字が含まれていない場合) Seed7では、変数を定義し、常に初期値を取得する必要があります。</p><p>その<tt><span class="func">書く</span></tt>ステートメントは次のようになります。<tt><span class="func">writeln</span></tt>と同じですが、改行文字を書き込みません。 その<tt><span class="func">readln</span></tt>文は、標準入力ファイルから行を読み込み、その行を指定された変数に代入します。 この機能では、バックスペースを使用して入力を訂正できます。 入力を押すと、行がプログラムに送信されます。 最後の<tt><span class="func">writeln</span></tt>文は演算子を含む<tt><span class="op">&lt;&amp;</span></tt>と入力します。 必要に応じて<tt><span class="op">&lt;&amp;</span></tt>演算子は値を<tt><a class="type" href="#types_string">文字列</a></tt></p><p>上記のグリーティング・プログラムには問題があります。 誰かが名前の入力を拒否して[Enter]だけを押した場合、プログラムは次のように書き込みます。</p><pre class="indent">こんにちは!
</pre><p>これを回避するために、特殊なケースをチェックするようにプログラムを改善します。</p><pre class="indent">
$
;






;



);

(名称)



);



);



);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:name</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>書く<a class="stri" href="#tokens_String_literals">(</a>「あなたのお名前は?」<span class="keywd">readln</span>if<span class="func_no_ul">名前</span>=<a class="stri" href="#tokens_String_literals"></a>&quot;&quot;<span class="func_no_ul"></span>その時<a class="keywd_no_ul" href="#stats_if-statement">writeln</a>(<span class="op_no_ul">「入館を押してくださった方にこんにちは!」</span>elsif<a class="stri" href="#tokens_String_literals">名前</a>=<a class="keywd_no_ul" href="#stats_if-statement"></a>&quot;name&quot;<span class="func_no_ul"></span>その時<a class="stri" href="#tokens_String_literals">writeln</a>(<a class="keywd_no_ul" href="#stats_if-statement">「おもしろいね、君の名前はなんというのか」</a>else<span class="op_no_ul">writeln</span>(<a class="stri" href="#tokens_String_literals">「ハイ」</a><a class="keywd_no_ul" href="#stats_if-statement">&lt;&amp;</a>名前<span class="func_no_ul">&lt;&amp;</span><a class="stri" href="#tokens_String_literals">&quot;!&quot;</a>if終了<a class="keywd_no_ul" href="#stats_if-statement">関数終了</a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre><p>ゼロまたはそれ以上になり得ます。<tt><span class="keywd">elsif</span></tt>部品、および<tt><span class="keywd">else</span></tt>パートはオプションです。 見ての通り、文字列が等しいかどうかは<tt><span class="op_no_ul">=</span></tt>の条件<a class="link" href="#stats_if-statement">if文</a>何をするか決めなければいけない 偶然にも上の例の両方の条件が変数を使用する<tt>名前</tt>この特別なケースは<a class="link" href="#stats_case-statement">判決理由陳述書</a>代わりに:</p><pre class="indent">
$
;






;



);

(名称)



}:

);

}:

);

}:

);

:

);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:name</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>書く<a class="stri" href="#tokens_String_literals">(</a>「あなたのお名前は?」<span class="keywd">readln</span>ケース<span class="func_no_ul">名前</span>の<a class="stri" href="#tokens_String_literals">いつ</a>{<span class="func_no_ul">&quot;&quot;</span>writeln<a class="keywd_no_ul" href="#stats_case-statement">(</a>「入館を押してくださった方にこんにちは!」<a class="keywd_no_ul" href="#stats_case-statement">いつ</a>{<a class="keywd_no_ul" href="#stats_case-statement">&quot;name&quot;</a>writeln<a class="stri" href="#tokens_String_literals">(</a>「おもしろいね、君の名前はなんというのか」<span class="func_no_ul">いつ</span>{<a class="stri" href="#tokens_String_literals">&quot;ライナス&quot;</a><a class="keywd_no_ul" href="#stats_case-statement">&quot;トーバルズ&quot;</a>writeln<a class="stri" href="#tokens_String_literals">(</a>「あなたはLinuxの発明者ですか?」<span class="func_no_ul">そうでなければ</span>writeln<a class="stri" href="#tokens_String_literals">(</a>「ハイ」<a class="keywd_no_ul" href="#stats_case-statement"></a>&lt;&amp;<a class="stri" href="#tokens_String_literals">名前</a>&lt;&amp;<a class="stri" href="#tokens_String_literals"></a>&quot;!&quot;<span class="func_no_ul">格を終わらせる</span>関数終了<a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_case-statement"></a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_case-statement"></a><span class="keywd"></span></pre><p>ご覧のように、キーワード<tt><a class="keywd_no_ul" href="#stats_case-statement">いつ</a></tt>この後に、中括弧で囲まれた値のカンマ区切りリストが続きます。 これは、このwhen部分の対象となる値の集合です。 &#39;name&#39;の値に応じて、when-partが実行されます。 whenパートが適合しない場合、otherwiseパートが実行されます。</p><p>挨拶プログラムを改善する方法はこれだけではありません。 あるいは、ループを使用して名前の入力を要求することもできます。</p><pre class="indent">
$
;






;





);

(名称)

;

);

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:name</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>繰り返す<a class="stri" href="#tokens_String_literals">書く</a>(<span class="keywd">「あなたのお名前は?」</span>readln<a class="keywd_no_ul" href="#stats_repeat-statement">まで</a>名前<span class="func_no_ul">&lt;></span><a class="stri" href="#tokens_String_literals">&quot;&quot;</a>writeln<span class="func_no_ul">(</span>「ハイ」<a class="keywd_no_ul" href="#stats_repeat-statement"></a>&lt;&amp;<span class="op_no_ul">名前</span>&lt;&amp;<a class="stri" href="#tokens_String_literals"></a>&quot;!&quot;<span class="func_no_ul">関数終了</span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span></pre><p>その<tt><span class="keywd">繰り返す</span><span class="keywd">まで</span></tt>loopは、条件が満たされるまで2つのキーワード間のステートメントを繰り返します。<tt>名前<span class="op">&lt;></span><a class="stri" href="#tokens_String_literals">&quot;&quot;</a></tt>は<tt><span class="var">TRUE</span></tt>なお<tt><a class="keywd" href="#stats_repeat-statement">繰り返す</a></tt>ループを少なくとも1回実行する。 を使用したソリューション<tt><a class="keywd" href="#stats_while-statement">一方で</a></tt>loop:</p><pre class="indent">
$
;






;



);

(名称)



);

(名称)

;

);

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:name</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>書く<a class="stri" href="#tokens_String_literals">(</a>「あなたのお名前は?」<span class="keywd">readln</span>一方で<span class="func_no_ul">名前</span>=<a class="stri" href="#tokens_String_literals"></a>&quot;&quot;<span class="func_no_ul"></span>do<a class="keywd_no_ul" href="#stats_while-statement">書く</a>(<span class="op_no_ul">「単にenterを押すだけではだめです。あなたの名前は?」</span>readln<a class="stri" href="#tokens_String_literals">whileを終了する</a>writeln<a class="keywd_no_ul" href="#stats_while-statement">(</a>「ハイ」<span class="func_no_ul"></span>&lt;&amp;<a class="stri" href="#tokens_String_literals">名前</a>&lt;&amp;<span class="func_no_ul"></span>&quot;!&quot;<a class="keywd_no_ul" href="#stats_while-statement">関数終了</a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span></pre><p>その<tt><a class="keywd" href="#stats_while-statement">一方で</a></tt>ループは、キーワード間のステートメントを繰り返す<tt><span class="keywd">do</span></tt>および<tt><span class="keywd">終わり</span></tt>状態が続く限り<tt>名前<span class="op">=</span><a class="stri" href="#tokens_String_literals">&quot;&quot;</a></tt>は<tt><span class="var">TRUE</span></tt>なお<tt><a class="keywd" href="#stats_while-statement">一方で</a></tt>ループはまったく実行されないかもしれない。 上の例では、「What&#39;s your name?(あなたの名前は?)」という質問の後に空でない名前が入力された場合に、これが発生します。</p>
          <a name="tutorial_Assignment">
        <h3>2.3配置</h3>
          </a>
        <p>次のプログラムは、1から10までの数を書き込みます。</p><pre class="indent">
$
;






1;





(count);
数える
1;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>整数<a class="keywd_no_ul" href="#decls_Variable_declarations">:count</a>は<a class="type_no_ul" href="#types_integer">begin</a>一方で<span class="keywd">数える</span>&lt;=<span class="keywd">10</span>do<a class="keywd_no_ul" href="#stats_while-statement">writeln</a>:=<span class="op_no_ul">数える</span>+<a class="keywd_no_ul" href="#stats_while-statement">whileを終了する</a>関数終了<span class="func_no_ul"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_while-statement"></a><span class="keywd"></span></pre><p>このプログラムは、型のローカル変数を宣言する。<tt><a class="type" href="#types_integer">整数</a></tt>:</p><pre class="indent">

1;
<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type_no_ul" href="#types_integer">整数</a>:count<span class="keywd">は</span></pre><p>変数<tt>数える</tt>で初期化される。<tt>1</tt>変数の値は<a class="link" href="#stats_Assignment">譲渡</a>(<tt><span class="op">:=</span></tt>):</p><pre class="indent">
数える
1;
<a class="op_no_ul" href="#stats_Assignment">:=</a>数える<span class="op_no_ul">+</span></pre><p>右側の式は<tt><span class="op">:=</span></tt>シンボルが評価され<tt><span class="op">:=</span></tt>シンボル。 変数の上の場合<tt>数える</tt>1増やします。 この特殊なケースでは、代入の代わりに使用できるショートカットがあります。</p><pre class="indent">

(count);
<span class="func_no_ul">増加</span></pre><p>このプログラムによる出力は次のようになります。</p><pre class="indent">1
2
3
4
5
6
7
8
9
10
</pre><p>代わりに10から0までカウントダウンするには、どのような変更が必要ですか?</p>
          <a name="tutorial_Constants">
        <h3>2.4定数</h3>
          </a>
        <p>華氏から摂氏への変換テーブルを記述するには、次のプログラムを使用します。</p><pre class="indent">(*華氏-摂氏の表を印刷する
(華氏の値が0から300*の場合)


$
;






300;

20;

0;

0;




摂氏
9;

);
fahr
increment;

;

;
<a class="comment" href="#tokens_Comments">含む</a><span class="keywd">&quot;seed7_05.s7i&quot;</span>const<span class="lib"></span>proc<a class="keywd_no_ul" href="#decls_Procedure_declarations">:main</a>is func<a class="type_no_ul" href="#types_proc">地域の</a>const<span class="keywd"></span>整数<span class="keywd">:上部</span>は<a class="keywd_no_ul" href="#decls_Constant_declarations">const</a><a class="type_no_ul" href="#types_integer">整数</a>:increment<span class="keywd">は</span>var<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>整数<a class="type_no_ul" href="#types_integer">:fahr</a>は<span class="keywd">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">整数</a>:℃<a class="type_no_ul" href="#types_integer">は</a>begin<span class="keywd">一方で</span>fahr<a class="keywd_no_ul" href="#decls_Variable_declarations">&lt;=</a>上<a class="type_no_ul" href="#types_integer">do</a>:=<span class="keywd">5</span>*<span class="keywd">(fahr</span>-<a class="keywd_no_ul" href="#stats_while-statement">32)</a>div<span class="op_no_ul">writeln</span>(fahr<a class="keywd_no_ul" href="#stats_while-statement">&lt;&amp;</a><a class="op_no_ul" href="#stats_Assignment">&quot;&quot;</a><span class="op_no_ul">&lt;&amp;</span>+:=<span class="op_no_ul">whileを終了する</span>関数終了<span class="op_no_ul"></span><span class="func_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_while-statement"></a><span class="keywd"></span></pre><p>間のすべて<a class="comment" href="#tokens_Comments">(*および*)</a>は<a class="link" href="#tokens_Comments">コメント</a>は無視されます。 このプログラムには、タイプのローカル定数および変数が含まれています。<tt><a class="type" href="#types_integer">整数</a></tt>定数宣言は次のように導入されます。<tt><a class="keywd_no_ul" href="#decls_Constant_declarations">const</a></tt>:</p><pre class="indent">

300;

20;
<a class="keywd_no_ul" href="#decls_Constant_declarations">const</a><a class="type_no_ul" href="#types_integer">整数</a>:上部<span class="keywd">は</span>const<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>整数<a class="type_no_ul" href="#types_integer">:increment</a>は<span class="keywd"></span></pre><p>Like variables constants must be initialized with a value that is specified after the keyword<tt><span class="keywd">は</span></tt>Constants like<tt>上</tt>は変更できません。 すべての定数は初期値のみを維持します。 定数を変更しようとすると<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst352.sd7(14):58:

lower:=10;
<a name="tutorial_WRONGACCESSRIGHT_example"></a><a class="link" href="#errors_WRONGACCESSRIGHT">変数{lower:=10}が定数integer:lowerを検出しました。</a></pre><p>エラーはプログラム実行開始前に報告されることに注意してください。</p><p>プログラムには<a class="link" href="#stats_while-statement">while文</a>を計算するための式と<tt>「摂氏」</tt>value. 変数<tt>&#39;fahr&#39;</tt>がインクリメントされる。<tt><span class="op">+:=</span></tt>オペレータ。 次の文:</p><pre class="indent">
fahr
increment;
<span class="op_no_ul">+:=</span></pre><p>は、次の文のショートカットです。</p><pre class="indent">
fahr
increment;
<a class="op_no_ul" href="#stats_Assignment">:=</a>fahr<span class="op_no_ul">+</span></pre><p>を計算するための式<tt>「摂氏」</tt>値は整数除算(<tt><span class="op">div</span></tt>)。 このプログラムによる出力は次のようになります。</p><pre class="indent">0-17歳
20-6
40 4
60 15
80 26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</pre><p></p>
          <a name="tutorial_For_loop_and_float_expressions">
        <h3>2.5ループ式およびfloat式の場合</h3>
          </a>
        <p>華氏から摂氏への変換テーブルを書き込むためのプログラムの改良版は次のとおりです。</p><pre class="indent">

$









0;

300;

20;

0;

0.0;




摂氏
9.0;

6);

;

;
<a class="comment" href="#tokens_Line_comments">#浮動小数点数を使用して華氏-摂氏の表を印刷します。</a>含む<span class="keywd"></span>&quot;seed7_05.s7i&quot;<span class="lib">;</span>#これは最初に含める必要があります。<a class="comment" href="#tokens_Line_comments">含む</a><span class="keywd">&quot;</span>float.s7i<span class="lib">&quot;<span class="lib">;</span>#以降のincludeには$は必要ありません。</span>const<a class="comment" href="#tokens_Line_comments"></a><a class="keywd_no_ul" href="#decls_Procedure_declarations">:main</a>is func<a class="type_no_ul" href="#types_proc">地域の</a>const<span class="keywd"></span>整数<span class="keywd">:lower</span>は<a class="keywd_no_ul" href="#decls_Constant_declarations">const</a><a class="type_no_ul" href="#types_integer">整数</a>:上部<span class="keywd">は</span>const<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>整数<a class="type_no_ul" href="#types_integer">:increment</a>は<span class="keywd">var</span><a class="keywd_no_ul" href="#decls_Constant_declarations">整数</a>:fahr<a class="type_no_ul" href="#types_integer">は</a>var<span class="keywd"></span>浮かぶ<a class="keywd_no_ul" href="#decls_Variable_declarations">:℃</a>は<a class="type_no_ul" href="#types_integer">begin</a>の<span class="keywd">fahr</span>範囲<a class="keywd_no_ul" href="#decls_Variable_declarations">下げる</a>へ<a class="type_no_ul" href="#types_float">上</a>ステップ<span class="keywd">増加</span>do<span class="keywd">:=</span><a class="keywd_no_ul" href="#stats_for-step-statement">浮かぶ</a>(5<a class="keywd_no_ul" href="#stats_for-step-statement">*</a>(fahr<a class="keywd_no_ul" href="#stats_for-step-statement">-</a>32))<a class="keywd_no_ul" href="#stats_for-step-statement">/</a>writeln<a class="keywd_no_ul" href="#stats_for-step-statement">(fahr</a>パッド<a class="op_no_ul" href="#stats_Assignment">3</a>&lt;&amp;<span class="func_no_ul"></span>&quot;&quot;<span class="op_no_ul"></span>&lt;&amp;<span class="op_no_ul">摂氏</span>指<span class="op_no_ul">2</span>パッド<span class="func_no_ul">終わる</span>関数終了<span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_for-step-statement"></a><span class="keywd"></span></pre><p>間のすべて<tt><a class="comment" href="#tokens_Line_comments">#</a></tt>行の終わりは<a class="link" href="#tokens_Line_comments">行コメント</a>は無視されます。 タイプを使用するには<tt><a class="type" href="#types_float">浮かぶ</a></tt>以下を含む必要がある<tt><span class="lib">float.s7i</span></tt>その<tt><a class="type" href="#types_float">浮かぶ</a></tt>変わりやすい<tt>「摂氏」</tt>は(0ではなく)0.0で初期化する必要があります。 その<tt><a class="link" href="#stats_for-statement">for-loop</a></tt>ループ本体を異なる値で実行します。<tt>fahr</tt>(0, 20, 40.280, 300) の省略<tt><span class="keywd">ステップ</span></tt>パートは、1のステップに相当します。</p><pre class="indent">
摂氏
9.0;

6);

;
<span class="keywd">の</span>fahr<span class="keywd">範囲</span>下げる<span class="keywd">へ</span>上<span class="keywd">do</span>:=<a class="op_no_ul" href="#stats_Assignment"></a>浮かぶ<span class="func_no_ul">(5</span>*<span class="op_no_ul">(fahr</span>-<span class="op_no_ul">32))</span>/<span class="op_no_ul">writeln</span>(fahr<span class="func_no_ul">パッド</span>3<span class="op_no_ul">&lt;&amp;</span><span class="op_no_ul">&quot;&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>摂氏<span class="op_no_ul">指</span>2<span class="op_no_ul">パッド</span>終わる<span class="op_no_ul"></span><span class="keywd"></span></pre><p>キーワード<tt><span class="keywd">ダウントゥ</span></tt>を使用して<tt><a class="link" href="#stats_for-statement">for-loop</a></tt>後方:</p><pre class="indent">
摂氏
9.0;

6);

;
<span class="keywd">の</span>fahr<span class="keywd">範囲</span>上<span class="keywd">ダウントゥ</span>下げる<span class="keywd">do</span>:=<a class="op_no_ul" href="#stats_Assignment"></a>浮かぶ<span class="func_no_ul">(5</span>*<span class="op_no_ul">(fahr</span>-<span class="op_no_ul">32))</span>/<span class="op_no_ul">writeln</span>(fahr<span class="func_no_ul">パッド</span>3<span class="op_no_ul">&lt;&amp;</span><span class="op_no_ul">&quot;&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>摂氏<span class="op_no_ul">指</span>2<span class="op_no_ul">パッド</span>終わる<span class="op_no_ul"></span><span class="keywd"></span></pre><p>Seed7は強い型なので<tt><a class="type" href="#types_integer">整数</a></tt>および<tt><a class="type" href="#types_float">浮かぶ</a></tt>式の中で値を混在させることはできません。 したがって<tt><a class="type" href="#types_integer">整数</a></tt>表現<tt>&#39;5*(fahr-32)&#39;</tt>に変換されます。<tt><a class="type" href="#types_float">浮かぶ</a></tt>関数で<tt><span class="func">浮かぶ</span></tt>同様の理由により<tt>&#39;<span class="func">/</span>&#39;</tt>除算と値<tt>&#39;9.0&#39;</tt>を使用しなければならない。 その<tt><span class="op">&lt;&amp;</span></tt>演算子は、書き込む前に要素を連結するために使用されます。<tt><span class="op">&lt;&amp;</span></tt>オペレータがタイプを持っていません<tt><a class="type" href="#types_string">文字列</a></tt>に変換されます。<tt><a class="type" href="#types_string">文字列</a></tt>を使用して<tt>&#39;str&#39;</tt>関数を使用します。 その<tt><span class="op">パッド</span></tt>演算子は<tt>&#39;fahr&#39;</tt>を文字列に変換し、文字列の長さが3になるまで左に空白を埋めます。 その<tt><span class="op">指</span></tt>演算子は<tt>「摂氏」</tt>10進数2桁の文字列に変換されます。 結果のストリングは、6の長さまでパディングされます。</p>
          <a name="tutorial_Arrays">
        <h3>2.6アレイ</h3>
          </a>
        <p>配列では、変数が複数値を持つことができます。 例:配列を使用して、日番号から日名へのマッピングを格納できます。</p><pre class="indent">
$
;






;

0;


weekdayName
;
weekdayName
;
weekdayName
;
weekdayName
;
weekdayName
;
weekdayName
;
weekdayName
;



);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>配列<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>文字列<a class="type_no_ul" href="#types_array">:weekdayName</a>は<a class="type_no_ul" href="#types_string">7</a>回<span class="keywd"></span>&quot;&quot;<span class="op_no_ul">var</span><a class="stri" href="#tokens_String_literals">整数</a>:数<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a>begin<a class="type_no_ul" href="#types_integer">[</a>1<span class="keywd">]</span><span class="keywd">:=</span><span class="op_no_ul">&quot;monday&quot;</span>[<span class="op_no_ul">2</span>]<a class="op_no_ul" href="#stats_Assignment"></a>:=<a class="stri" href="#tokens_String_literals"></a>&quot;火曜日&quot;<span class="op_no_ul">[</span>3<span class="op_no_ul">]</span><a class="op_no_ul" href="#stats_Assignment">:=</a><a class="stri" href="#tokens_String_literals">&quot;wednesday&quot;</a>[<span class="op_no_ul">4</span>]<span class="op_no_ul"></span>:=<a class="op_no_ul" href="#stats_Assignment"></a>&quot;thursday&quot;<a class="stri" href="#tokens_String_literals">[</a>5<span class="op_no_ul">]</span><span class="op_no_ul">:=</span><a class="op_no_ul" href="#stats_Assignment">&quot;friday&quot;</a>[<a class="stri" href="#tokens_String_literals">6</a>]<span class="op_no_ul"></span>:=<span class="op_no_ul"></span>&quot;saturday&quot;<a class="op_no_ul" href="#stats_Assignment">[</a>7<a class="stri" href="#tokens_String_literals">]</a><span class="op_no_ul">:=</span><span class="op_no_ul">&quot;sunday&quot;</span>の<a class="op_no_ul" href="#stats_Assignment">数</a>範囲<a class="stri" href="#tokens_String_literals">1</a>へ<span class="op_no_ul">7</span>do<span class="op_no_ul">writeln</span>(weekdayName<a class="op_no_ul" href="#stats_Assignment">[</a>数<a class="stri" href="#tokens_String_literals">]</a>終わり<a class="keywd_no_ul" href="#stats_for-statement"></a>の<a class="keywd_no_ul" href="#stats_for-statement">終わり</a><a class="keywd_no_ul" href="#stats_for-statement">機能</a><a class="keywd_no_ul" href="#stats_for-statement"></a><span class="func_no_ul"></span><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_for-statement"></a><a class="keywd_no_ul" href="#stats_for-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>以来<tt>weekdayName</tt>は、値が割り当てられた後に変更されないため、配列リテラルで初期化された定数として宣言できます。</p><pre class="indent">
$
;






);

0;





);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>const<span class="keywd"></span>配列<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>文字列<a class="type_no_ul" href="#types_array">:weekdayName</a>は<a class="type_no_ul" href="#types_string">[](</a>&quot;monday&quot;<span class="keywd"></span>&quot;火曜日&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;wednesday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;thursday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;friday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;saturday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;sunday&quot;<a class="stri" href="#tokens_String_literals">var</a><a class="stri" href="#tokens_String_literals">整数</a>:数<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a>begin<a class="type_no_ul" href="#types_integer">の</a>数<span class="keywd">範囲</span>1<span class="keywd">へ</span>7<a class="keywd_no_ul" href="#stats_for-statement">do</a>writeln<a class="keywd_no_ul" href="#stats_for-statement">(weekdayName</a>[<a class="keywd_no_ul" href="#stats_for-statement">数</a>]<a class="keywd_no_ul" href="#stats_for-statement">終わり</a><span class="func_no_ul">の</span>終わり<span class="op_no_ul"></span>機能<span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_for-statement"></a><a class="keywd_no_ul" href="#stats_for-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>上記の例では配列リテラルを使用しています。</p><pre class="indent">
[](
)
<a class="stri" href="#tokens_String_literals">&quot;monday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;火曜日&quot;</a><a class="stri" href="#tokens_String_literals">&quot;wednesday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;thursday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;friday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;saturday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;sunday&quot;</a></pre><p>この配列リテラルは<tt><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a></tt>1から始まるインデックスが付けられます。 対応する0から始まる配列リテラルは次のようになります。</p><pre class="indent">
[0](
)
<a class="stri" href="#tokens_String_literals">&quot;monday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;火曜日&quot;</a><a class="stri" href="#tokens_String_literals">&quot;wednesday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;thursday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;friday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;saturday&quot;</a><a class="stri" href="#tokens_String_literals">&quot;sunday&quot;</a></pre><p>その<a class="link" href="#stats_for-statement">for-loop</a>上記では、リテラル<tt>7</tt>を上限とする。 機能<tt><span class="func">長さ</span></tt>を代わりに使用することもできます。</p><pre class="indent"><a class="keywd_no_ul" href="#stats_for-statement">の</a>数<a class="keywd_no_ul" href="#stats_for-statement">範囲</a>1<a class="keywd_no_ul" href="#stats_for-statement">へ</a><span class="func">長さ</span>(weekdayName)<a class="keywd_no_ul" href="#stats_for-statement">do</a></pre><p>これは、配列が<tt>weekdayName</tt>インデックスは1から始まります。 そうでない場合は、その機能は<tt><span class="func">minIdx</span></tt>および<tt><span class="func">maxIdx</span></tt>を使用することができる。</p><pre class="indent"><a class="keywd_no_ul" href="#stats_for-statement">の</a>数<a class="keywd_no_ul" href="#stats_for-statement">範囲</a><span class="func">minIdx</span>(weekdayName)<a class="keywd_no_ul" href="#stats_for-statement">へ</a><span class="func">maxIdx</span>(weekdayName)<a class="keywd_no_ul" href="#stats_for-statement">do</a></pre><p>この場合には、便利な<a class="link" href="#stats_for-key-statement">for-key-loop</a>:</p><pre class="indent">

);

;
<a class="keywd_no_ul" href="#stats_for-key-statement">の</a><a class="keywd_no_ul" href="#stats_for-key-statement">キー</a>数<a class="keywd_no_ul" href="#stats_for-key-statement">範囲</a>weekdayName<a class="keywd_no_ul" href="#stats_for-key-statement">do</a>writeln<span class="func_no_ul">(weekdayName</span>[<span class="op_no_ul">数</span>]<span class="op_no_ul">終わる</span><a class="keywd_no_ul" href="#stats_for-key-statement"></a></pre><p>これは<a class="link" href="#stats_for-key-statement">for-key-loop</a>のインデックスをループします。<tt><a class="type" href="#types_array">配列</a></tt><tt>weekdayName</tt>(1から7まで) ループ本体では、配列から要素にアクセスするためにインデックスが使用されるだけです。 この場合には、便利な<a class="link" href="#stats_for-each-statement">for-each-loop</a>:</p><pre class="indent">
$
;






);

;





(名称)

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>const<span class="keywd"></span>配列<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>文字列<a class="type_no_ul" href="#types_array">:weekdayName</a>は<a class="type_no_ul" href="#types_string">[](</a>&quot;monday&quot;<span class="keywd"></span>&quot;火曜日&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;wednesday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;thursday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;friday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;saturday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;sunday&quot;<a class="stri" href="#tokens_String_literals">var</a><a class="stri" href="#tokens_String_literals">文字列</a>:name<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_string">&quot;&quot;</a>begin<span class="keywd">の</span>名前<a class="stri" href="#tokens_String_literals">範囲</a>weekdayName<span class="keywd">do</span>writeln<a class="keywd_no_ul" href="#stats_for-each-statement">終わり</a><a class="keywd_no_ul" href="#stats_for-each-statement">の</a>終わり<a class="keywd_no_ul" href="#stats_for-each-statement"></a>機能<span class="func_no_ul"></span><a class="keywd_no_ul" href="#stats_for-each-statement"></a><a class="keywd_no_ul" href="#stats_for-each-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>A<a class="link" href="#stats_for-each-statement">for-each-loop</a>の要素を反復する<tt><a class="type" href="#types_array">配列</a></tt>場合によっては、要素とそれに対応する索引が必要になります。 これはサポートされています。<a class="link" href="#stats_for-each-key-statement">キーごとのループ</a>:</p><pre class="indent">
$
;






);

;

0;





名前);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>const<span class="keywd"></span>配列<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>文字列<a class="type_no_ul" href="#types_array">:weekdayName</a>は<a class="type_no_ul" href="#types_string">[](</a>&quot;monday&quot;<span class="keywd"></span>&quot;火曜日&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;wednesday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;thursday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;friday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;saturday&quot;<a class="stri" href="#tokens_String_literals"></a>&quot;sunday&quot;<a class="stri" href="#tokens_String_literals">var</a><a class="stri" href="#tokens_String_literals">文字列</a>:name<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_string">&quot;&quot;</a>var<span class="keywd"></span>整数<a class="stri" href="#tokens_String_literals">:index</a>は<a class="keywd_no_ul" href="#decls_Variable_declarations">begin</a>の<a class="type_no_ul" href="#types_integer">名前</a>キー<span class="keywd">索引</span>範囲<span class="keywd">weekdayName</span>do<a class="keywd_no_ul" href="#stats_for-each-key-statement">writeln</a>(<a class="keywd_no_ul" href="#stats_for-each-key-statement">「日」</a><a class="keywd_no_ul" href="#stats_for-each-key-statement">&lt;&amp;</a>索引<a class="keywd_no_ul" href="#stats_for-each-key-statement">&lt;&amp;</a><span class="func_no_ul">&quot;:&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>終わり<span class="op_no_ul"></span>の<span class="op_no_ul">終わり</span><a class="stri" href="#tokens_String_literals">機能</a><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_for-each-key-statement"></a><a class="keywd_no_ul" href="#stats_for-each-key-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>の別の例<tt><a class="link" href="#stats_for-each-statement">for-each-loop</a></tt>は:</p><pre class="indent">
$
;






0;





);

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>整数<a class="keywd_no_ul" href="#decls_Variable_declarations">:数</a>は<a class="type_no_ul" href="#types_integer">begin</a>の<span class="keywd">数</span>範囲<span class="keywd">[](0、1、2、3、5、8、13、20、40、100)</span>do<a class="keywd_no_ul" href="#stats_for-each-statement">書く</a>(番号<a class="keywd_no_ul" href="#stats_for-each-statement">&lt;&amp;</a><a class="keywd_no_ul" href="#stats_for-each-statement">&quot;&quot;</a>終わる<span class="func_no_ul">writeln</span>関数終了<span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_for-each-statement"></a><span class="func_no_ul"></span><span class="keywd"></span></pre><p>上記の例では配列リテラルを使用しています。</p><pre class="indent">[](0、1、2、3、5、8、13、20、40、100)
</pre><p>この配列リテラルは<tt><a class="type" href="#types_array">配列</a><a class="type" href="#types_integer">整数</a></tt>配列の添字型は整数に限定されない。 A type like<tt><a class="type" href="#types_char">char</a></tt>への1:1マッピングを持つ<tt><a class="type" href="#types_integer">整数</a></tt>また、インデックスとしても使用できます。</p><pre class="indent">
$
;







[
);

0;

;


数
(1, 9999999);

);



);

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>const<span class="keywd"></span>配列<a class="keywd_no_ul" href="#decls_Constant_declarations">[</a>char<a class="type_no_ul" href="#types_array">]</a>文字列<a class="type_no_ul" href="#types_char">:digitName</a>は<a class="type_no_ul" href="#types_string">&#39;0&#39;</a>](<span class="keywd">「ゼロ」</span><a class="stri" href="#tokens_Character_literals">「1」</a><a class="stri" href="#tokens_String_literals">「2」</a><a class="stri" href="#tokens_String_literals">「3」</a><a class="stri" href="#tokens_String_literals">「4」</a><a class="stri" href="#tokens_String_literals">「5」</a><a class="stri" href="#tokens_String_literals">「6」</a><a class="stri" href="#tokens_String_literals">「7」</a><a class="stri" href="#tokens_String_literals">「8」</a><a class="stri" href="#tokens_String_literals">「9」</a>var<a class="stri" href="#tokens_String_literals"></a>整数<a class="stri" href="#tokens_String_literals">:数</a>は<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type_no_ul" href="#types_integer">char</a>:ch<span class="keywd">は</span><a class="keywd_no_ul" href="#decls_Variable_declarations">「」</a>begin<a class="type_no_ul" href="#types_char">:=</a><span class="keywd">ランド</span>書く<a class="stri" href="#tokens_Character_literals">(番号</a>&lt;&amp;<span class="keywd"></span>&quot;:&quot;<a class="op_no_ul" href="#stats_Assignment">の</a>ch<span class="func_no_ul">範囲</span><span class="func_no_ul">str</span>(数)<span class="op_no_ul">do</span>書く<a class="stri" href="#tokens_String_literals">(digitName[ch]</a>&lt;&amp;<span class="keywd_no_ul"></span>&quot;&quot;<span class="keywd_no_ul">終わる</span>writeln<span class="func_no_ul">関数終了</span><span class="keywd_no_ul"></span><span class="func_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd_no_ul"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>上記の例では配列リテラルを使用しています。</p><pre class="indent">
[
)
<a class="stri" href="#tokens_Character_literals">&#39;0&#39;</a>](<a class="stri" href="#tokens_String_literals">「ゼロ」</a><a class="stri" href="#tokens_String_literals">「1」</a><a class="stri" href="#tokens_String_literals">「2」</a><a class="stri" href="#tokens_String_literals">「3」</a><a class="stri" href="#tokens_String_literals">「4」</a><a class="stri" href="#tokens_String_literals">「5」</a><a class="stri" href="#tokens_String_literals">「6」</a><a class="stri" href="#tokens_String_literals">「7」</a><a class="stri" href="#tokens_String_literals">「8」</a><a class="stri" href="#tokens_String_literals">「9」</a></pre><p>この配列リテラルは<tt><a class="type_no_ul" href="#types_array">配列</a>[<a class="type_no_ul" href="#types_char">char</a>]<a class="type_no_ul" href="#types_string">文字列</a></tt>この配列の最小のインデックスは文字<tt><a class="stri" href="#tokens_Character_literals">&#39;0&#39;</a></tt></p>
          <a name="tutorial_Hashes">
        <h3>2.7ハッシュ</h3>
          </a>
        <p>A<tt><a class="type" href="#types_hash">ハッシュ</a></tt>は<tt><a class="type" href="#types_array">配列</a></tt>ただし、インデックスは任意のタイプにすることができます(単にインデックスを<tt><a class="type" href="#types_integer">整数</a></tt>)。 型式<tt><a class="type" href="#types_hash">ハッシュ</a><span class="type">[</span><a class="type" href="#types_string">文字列</a><span class="type">]</span><a class="type" href="#types_integer">整数</a></tt>でハッシュを定義します。<tt><a class="type" href="#types_string">文字列</a></tt>引数indexおよび<tt><a class="type" href="#types_integer">整数</a></tt>価値として。 この型は型宣言で使用できます。</p><pre class="indent">;
<a class="keywd_no_ul" href="#decls_Type_declarations">const</a><a class="type_no_ul" href="#types_type">タイプ</a>:nameToDigitType<span class="keywd">は</span><a class="type_no_ul" href="#types_hash">ハッシュ</a>[<a class="type_no_ul" href="#types_string">文字列</a>]<a class="type_no_ul" href="#types_integer">整数</a></pre><p>ハッシュリテラルは、ハッシュ定数または変数を初期化するために使用できます。</p><pre class="indent">
const
[](
[
:4]
[
:9]);
<span class="type">nameToDigitType</span>:nameToDigit<span class="keywd">は</span>「ゼロ」<a class="stri" href="#tokens_String_literals">:0]、[</a>「1」<a class="stri" href="#tokens_String_literals">:1],[</a>「2」<a class="stri" href="#tokens_String_literals">:2],[</a>「3」<a class="stri" href="#tokens_String_literals">:3],[</a>「4」<a class="stri" href="#tokens_String_literals">「5」</a>:5],[<a class="stri" href="#tokens_String_literals">「6」</a>:6],[<a class="stri" href="#tokens_String_literals">「7」</a>:7]、[<a class="stri" href="#tokens_String_literals">「8」</a>:8],[<a class="stri" href="#tokens_String_literals">「9」</a><a class="stri" href="#tokens_String_literals"></a></pre><p>配列と同様に、ハッシュ内の要素には</p><pre class="indent">nameToDigit[name]
</pre><p>次の例では、数字名を要求し、対応する数字を記述します。</p><pre class="indent">
$
;


;





const
[](
[
:4]
[
:9]);
var string:name is&quot;&quot;;



);

(名称)



nameToDigit[name]);



);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Type_declarations"></a>タイプ<a class="type_no_ul" href="#types_type">:nameToDigitType</a>は<span class="keywd"></span>ハッシュ<a class="type_no_ul" href="#types_hash">[</a>文字列<a class="type_no_ul" href="#types_string">]</a>整数<a class="type_no_ul" href="#types_integer">const</a><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type_no_ul" href="#types_proc">is func</a>地域の<span class="keywd">nameToDigitType</span>:nameToDigit<span class="keywd">は</span>「ゼロ」<span class="type">:0]、[</span>「1」<span class="keywd">:1],[</span>「2」<a class="stri" href="#tokens_String_literals">:2],[</a>「3」<a class="stri" href="#tokens_String_literals">:3],[</a>「4」<a class="stri" href="#tokens_String_literals">「5」</a>:5],[<a class="stri" href="#tokens_String_literals">「6」</a>:6],[<a class="stri" href="#tokens_String_literals">「7」</a>:7]、[<a class="stri" href="#tokens_String_literals">「8」</a>:8],[<a class="stri" href="#tokens_String_literals">「9」</a>begin<a class="stri" href="#tokens_String_literals">書く</a>(<a class="stri" href="#tokens_String_literals">&quot;数字の名前を入力:&quot;</a>readln<a class="stri" href="#tokens_String_literals">if</a>名前<span class="keywd">で</span>nameToDigit<span class="func_no_ul">その時</span>writeln<a class="stri" href="#tokens_String_literals">(</a>&quot;の値&quot;<span class="func_no_ul"></span>&lt;&amp;<a class="keywd_no_ul" href="#stats_if-statement">名前</a>&lt;&amp;<span class="op_no_ul"></span>「は」<a class="keywd_no_ul" href="#stats_if-statement"></a>&lt;&amp;<span class="func_no_ul">else</span>writeln<a class="stri" href="#tokens_String_literals">(</a>&quot;入力しました&quot;<span class="op_no_ul"></span>&lt;&amp;<span class="op_no_ul">名前</span>&lt;&amp;<a class="stri" href="#tokens_String_literals"></a>&quot;、数字の名前ではありません。&quot;<span class="op_no_ul">if終了</span>関数終了<a class="keywd_no_ul" href="#stats_if-statement"></a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre><p>上の例では</p><pre class="indent">
名前
nameToDigit
<span class="op_no_ul">で</span></pre><p>キー<tt>名前</tt>ハッシュ表にある<tt>nameToDigit</tt>これにより、対応する値を得ることが保証される。</p><pre class="indent">nameToDigit[name]
</pre><p>成功します。 for-eachループはハッシュテーブルでも使用できます。 以下の例では<tt><span class="var">keyDescription</span></tt>これは次のように定義されてい<tt><a class="type" href="#types_hash">ハッシュ</a><span class="type">[</span><a class="type" href="#types_char">char</a><span class="type">]</span><a class="type" href="#types_string">文字列</a></tt>で<tt><span class="lib">&quot;</span><span class="lib">keydescr.s7i</span><span class="lib">&quot;</span></tt>キーボードのキーに関する説明文が含まれています。 A<tt><span class="link">for-loop</span></tt>はaの値をループすることができる。<tt><a class="type" href="#types_hash">ハッシュ</a></tt>:</p><pre class="indent">
$
;

;






;





);

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keydescr.s7i</span><span class="lib">&quot;</span><span class="lib">const</span>><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type_no_ul" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">文字列</span>:description<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_string">&quot;&quot;</a>begin<span class="keywd">の</span>記述<a class="stri" href="#tokens_String_literals">範囲</a><span class="keywd">keyDescription</span><span class="keywd_no_ul">do</span>書く<span class="keywd_no_ul">(説明</span>&lt;&amp;<span class="var"></span>&quot;&quot;<span class="keywd_no_ul">終わる</span>writeln<span class="func_no_ul">関数終了</span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd_no_ul"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>A<tt><span class="link">for-loop</span></tt>のキー(インデックス)と値をループすることもできます。<tt><a class="type" href="#types_hash">ハッシュ</a></tt>:</p><pre class="indent">
$
;

;






;

;





(aChar));

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keydescr.s7i</span><span class="lib">&quot;</span><span class="lib">const</span><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type_no_ul" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">char</span>:aChar<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_char">「」</a>var<span class="keywd"></span>文字列<a class="stri" href="#tokens_Character_literals">:description</a>は<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>&quot;&quot;<a class="type_no_ul" href="#types_string">begin</a>の<span class="keywd">記述</span>キー<a class="stri" href="#tokens_String_literals">aChar</a>範囲<span class="keywd"></span>keyDescription<span class="keywd_no_ul"></span>do<span class="keywd_no_ul">writeln</span>(<span class="keywd_no_ul">&quot;const char:&quot;</span><span class="var">&lt;&amp;</span>記述<span class="keywd_no_ul">&lt;&amp;</span><span class="func_no_ul">「は」</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a><span class="op_no_ul">文字通りの</span>終わる<span class="op_no_ul">関数終了</span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="func_no_ul"></span><span class="keywd_no_ul"></span><span class="keywd"></span></pre><p></p>
          <a name="tutorial_For_loop_and_containers">
        <h3>2.8ループ及び容器用</h3>
          </a>
        <p><tt><span class="link">forループ</span></tt>の各要素に対して繰り返すこともできます。<tt><a class="type" href="#types_set">設定する</a></tt>:</p><pre class="indent">
$
;






;





);

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:innerPlanet</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>の<a class="stri" href="#tokens_String_literals">innerPlanet</a>範囲<span class="keywd">{</span>「水銀」<span class="keywd_no_ul"></span>「金星」<span class="keywd_no_ul"></span>「地球」<a class="stri" href="#tokens_String_literals"></a>「火星」<a class="stri" href="#tokens_String_literals">}</a>do<a class="stri" href="#tokens_String_literals">書く</a>(innerPlanet<a class="stri" href="#tokens_String_literals">&lt;&amp;</a><span class="keywd_no_ul">&quot;&quot;</span>終わる<span class="func_no_ul">writeln</span>関数終了<span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd_no_ul"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>上の例では<tt>{<a class="stri" href="#tokens_String_literals">「水銀」</a><a class="stri" href="#tokens_String_literals">「金星」</a><a class="stri" href="#tokens_String_literals">「地球」</a><a class="stri" href="#tokens_String_literals">「火星」</a>}</tt>はセット・リテラルです。 このリテラルのタイプは<tt><a class="type" href="#types_set">設定する</a><a class="type" href="#types_set">の</a><a class="type" href="#types_string">文字列</a></tt>その他のセットリテラルは次のとおりです。</p><pre class="indent">
{1, 2}
{
}
<a class="stri" href="#tokens_Character_literals">&#39;a&#39;</a><a class="stri" href="#tokens_Character_literals">「e」</a><a class="stri" href="#tokens_Character_literals">&#39;i&#39;</a><a class="stri" href="#tokens_Character_literals">「o」</a><a class="stri" href="#tokens_Character_literals">「u」</a></pre><p><tt><a class="link" href="#stats_for-each-statement">forループ</a></tt>の文字を繰り返すことができる<tt><a class="type" href="#types_string">文字列</a></tt>:</p><pre class="indent">
$
;






};

;







(文字)

;

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>const<span class="keywd"></span>のセット<a class="keywd_no_ul" href="#decls_Constant_declarations"></a>char<a class="type_no_ul" href="#types_set">:母音</a>は<a class="type_no_ul" href="#types_char">{</a>&#39;a&#39;<span class="keywd"></span>「e」<a class="stri" href="#tokens_Character_literals"></a>&#39;i&#39;<a class="stri" href="#tokens_Character_literals"></a>「o」<a class="stri" href="#tokens_Character_literals"></a>「u」<a class="stri" href="#tokens_Character_literals">var</a><a class="stri" href="#tokens_Character_literals">char</a>:文字<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_char">「」</a>begin<span class="keywd">の</span>手紙<a class="stri" href="#tokens_Character_literals">範囲</a><span class="keywd">&quot;速い茶色のキツネは、怠け者の犬を飛び越える&quot;</span><span class="keywd_no_ul">do</span>if<span class="keywd_no_ul">手紙</span>ない<a class="stri" href="#tokens_String_literals">母音</a>その時<span class="keywd_no_ul">書く</span>if終了<a class="keywd_no_ul" href="#stats_if-statement">終わる</a>writeln<span class="op_no_ul">関数終了</span><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="func_no_ul"></span><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd_no_ul"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>A<tt><span class="link">for-loop</span></tt>のキー(インデックス)と値をループすることができます。<tt><a class="type" href="#types_array">配列</a></tt>:</p><pre class="indent">
$
;






0;

;







名前);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>整数<a class="keywd_no_ul" href="#decls_Variable_declarations">:数</a>は<a class="type_no_ul" href="#types_integer">var</a><span class="keywd">文字列</span>:name<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_string">&quot;&quot;</a>begin<span class="keywd">の</span>名前<a class="stri" href="#tokens_String_literals">キー</a>数<span class="keywd">範囲</span>[0](<span class="keywd_no_ul">「ゼロ」</span><span class="keywd_no_ul">「1」</span><span class="keywd_no_ul">「2」</span><a class="stri" href="#tokens_String_literals">「3」</a><a class="stri" href="#tokens_String_literals">「4」</a>「5」<a class="stri" href="#tokens_String_literals"></a>「6」<a class="stri" href="#tokens_String_literals"></a>「7」<a class="stri" href="#tokens_String_literals"></a>「8」<a class="stri" href="#tokens_String_literals"></a>「9」<a class="stri" href="#tokens_String_literals">)</a>do<a class="stri" href="#tokens_String_literals">writeln</a>(番号<a class="stri" href="#tokens_String_literals">&lt;&amp;</a><a class="stri" href="#tokens_String_literals">&quot;:&quot;</a><span class="keywd_no_ul">&lt;&amp;</span>終わる<span class="func_no_ul">関数終了</span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="keywd_no_ul"></span><span class="keywd"></span></pre><p>コンテナ内で繰り返されるループはすべて<tt><span class="func">まで</span></tt>条件:</p><pre class="indent">
$
;






;

;

;



);

(testText);


control文字が見つかりました
32;

;



);

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:testText</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">var</span><a class="stri" href="#tokens_String_literals">char</a>:ch<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_char">「」</a>var<span class="keywd"></span>ブール<a class="stri" href="#tokens_Character_literals">:controlCharFound</a>は<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>FALSE<a class="type_no_ul" href="#types_boolean">begin</a>書く<span class="keywd">(</span>&quot;テキストを入力:&quot;<span class="var">readln</span>の<span class="keywd">ch</span>範囲<span class="func_no_ul">testText</span>まで<a class="stri" href="#tokens_String_literals">control文字が見つかりました</a>do<span class="func_no_ul">:=</span><span class="keywd">ord</span>(ch)<span class="keywd">&lt;</span>終わる<span class="keywd">if</span>control文字が見つかりました<span class="keywd">その時</span>writeln<a class="op_no_ul" href="#stats_Assignment">(</a>&quot;テキストに制御文字が含まれています。&quot;<span class="func_no_ul">if終了</span>関数終了<span class="op_no_ul"></span><span class="keywd"></span><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre>
          <a name="tutorial_Functions">
        <h3>2.9機能</h3>
          </a>
        <p>以下のプログラムは、その機能を使用する。<tt><span class="func">flipCoin</span></tt>表が出るまでコインを投げること:</p><pre class="indent">
$
;




);






;





);

;
頭
;

);

頭;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<a class="keywd_no_ul" href="#decls_Function_declarations"></a>機能<a class="type_no_ul" href="#types_func"></a>ブール<a class="type_no_ul" href="#types_boolean">:flipCoin</a>は<span class="keywd">リターン</span><span class="keywd_no_ul">ランド</span>(<span class="func">FALSE</span><span class="var">TRUE</span>const<span class="var"></span>proc<a class="keywd_no_ul" href="#decls_Procedure_declarations">:main</a>is func<a class="type_no_ul" href="#types_proc">地域の</a>var<span class="keywd"></span>ブール<span class="keywd">:頭</span>は<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>FALSE<a class="type_no_ul" href="#types_boolean">begin</a>繰り返す<span class="keywd">書く</span>(<span class="var">「Enterを押してコインを投げます。」</span>readln<span class="keywd">:=</span><a class="keywd_no_ul" href="#stats_repeat-statement">flipCoin</a>writeln<span class="func_no_ul">(頭</span><a class="stri" href="#tokens_String_literals"></a>「ヘッド」<span class="func_no_ul"></span>:<a class="op_no_ul" href="#stats_Assignment"></a>「尻尾」<span class="func">まで</span>関数終了<span class="func_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_repeat-statement"></a><span class="keywd"></span></pre><p>上記の例では<tt><span class="func">flipCoin</span></tt>は定数として宣言される。 As<tt><span class="keywd">const</span></tt>のコード<tt><span class="func">flipCoin</span></tt>実行時に変更されません。 型式<tt><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a></tt>は、この関数が<tt><a class="type" href="#types_boolean">ブール</a></tt>value. 職務のタスク<tt><span class="func">flipCoin</span></tt>は、乱数を返すことである。<tt><a class="type_no_ul" href="#types_boolean">ブール</a></tt>value. これは次のようにして行います。</p><pre class="indent">);
<span class="keywd_no_ul">リターン</span><span class="func">ランド</span>(<span class="var">FALSE</span><span class="var">TRUE</span></pre><p>実際の乱数は以下の式で計算される。</p><pre class="indent">);
<span class="func">ランド</span>(<span class="var">FALSE</span><span class="var">TRUE</span></pre><p>ステートメント</p><pre class="indent">
頭
;
<a class="op_no_ul" href="#stats_Assignment">:=</a><span class="func">flipCoin</span></pre><p>の結果を割り当てる。<tt><span class="func">flipCoin</span></tt>へ<tt>頭</tt>その後<tt>頭</tt>で上書きされます。<span class="link">三項演算子</span>(<tt><span class="op_no_ul">:</span></tt>)。 もし<tt>頭</tt>は<tt><span class="var">TRUE</span></tt>と書いている。<tt><a class="stri" href="#tokens_String_literals">「ヘッド」</a></tt>そうでなければ<tt><a class="stri" href="#tokens_String_literals">「尻尾」</a></tt></p><p>に注意してください。<tt><span class="keywd_no_ul">リターン</span></tt>は文ではありません。 代わりに<tt><span class="keywd_no_ul">リターン</span></tt>は<span class="link">結果変数</span>:</p><pre class="indent">



;


coinState
);

;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:flipCoin<span class="keywd">is func</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">ブール</a>:coinState<a class="type_no_ul" href="#types_boolean">は</a><span class="keywd">FALSE</span>begin<span class="var">:=</span><span class="keywd">ランド</span>(<a class="op_no_ul" href="#stats_Assignment">FALSE</a><span class="func">TRUE</span>終わり<span class="var"></span>機能<span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>A<span class="link">結果変数</span>は、関数の結果として使用される特定のローカル変数です。</p><p>の宣言<tt><span class="func">flipCoin</span></tt>上記は、次の構文を含みます。</p><pre class="indent">


<span class="keywd">機能</span>関数終了<span class="keywd"></span></pre><p>機能<tt><span class="func">flipCoin</span></tt>を取得します。<tt><span class="keywd">機能</span><span class="keywd">関数終了</span></tt>値として構築します。 このコンストラクトは、関数およびプロシージャの初期化に使用できます。 の内部<tt><span class="keywd">機能</span><span class="keywd">関数終了</span></tt>キーワードを構成する<tt><span class="keywd_no_ul">結果</span></tt><tt><span class="keywd">地域の</span></tt>および<tt><span class="keywd">begin</span></tt>を使用することができる。</p><ul>
<li>キーワード<tt><span class="keywd_no_ul">結果</span></tt>の宣言を紹介する。<span class="link">結果変数</span>関数が終了すると、結果変数の現在の値が返されます。 もしそうでなければ<a class="link" href="#stats_Assignment">譲渡</a>を実行して<a class="link" href="#decls_Initialization">初期値</a>結果値のが関数の結果です。</li>
<li>キーワード<tt><span class="keywd">地域の</span></tt>は、関数に対してローカルな定数宣言と変数宣言を導入します。</li>
<li>キーワード<tt><span class="keywd">begin</span></tt>は、関数が呼び出されたときに実行される一連のステートメントを導入します。</li>
</ul><p>の宣言からわかるように<tt><span class="func">主要な</span></tt>上記の<tt><span class="keywd_no_ul">結果</span></tt>および<tt><span class="keywd">地域の</span></tt>partsはオプションです。関数タイプが<tt><a class="type" href="#types_proc">proc</a></tt><tt><span class="keywd_no_ul">結果</span></tt>を省略しなければならない。 その他すべての機能については<tt><span class="keywd_no_ul">結果</span></tt>部分は必須です。</p><p>必ず関数の結果を使用します(<a class="link" href="#stats_Assignment">割り当てられた</a>、書かれた、パラメータとして使用されるなど)。 関数を宣言文として使用して、関数の結果を無視する事はできません。 使用しようとする試み<tt><span class="func">flipCoin</span></tt>asステートメント:</p><pre class="indent">


flipCoin;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type_no_ul" href="#types_proc">proc</a>:main<span class="keywd">is func</span>begin<span class="keywd">終わり</span><span class="keywd">機能</span><span class="keywd"></span></pre><p>結果は<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst609.sd7(8):35:

flipCoin;
<a class="link" href="#errors_PROC_EXPECTED">プロシージャで&quot;func boolean&quot;式が見つかりました</a></pre>
          <a name="tutorial_Parameters">
        <h3>2.10パラメータ</h3>
          </a>
        <p>ほとんどのパラメータは、関数内で変更されません。 Seed7使用<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータを使用します。</p><pre class="indent">

num1;






1;




心房細動
2);

;

;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_integer">整数</a>:negate(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:num1)<span class="keywd">は</span>リターン<span class="keywd_no_ul"></span>-<span class="op_no_ul">const</span><a class="keywd_no_ul" href="#decls_Function_declarations">機能</a><a class="type_no_ul" href="#types_func">整数</a>:fib(<a class="type_no_ul" href="#types_integer">で</a><a class="keywd_no_ul" href="#params_in_parameter">整数</a>:num1)<a class="type_no_ul" href="#types_integer">is func</a>結果<span class="keywd">var</span><span class="keywd_no_ul">整数</span>:fib<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a>begin<a class="type_no_ul" href="#types_integer">if</a>1番<span class="keywd">&lt;></span>1<span class="keywd">および</span>1番<a class="keywd_no_ul" href="#stats_if-statement">&lt;></a>2<span class="op_no_ul">その時</span>:=<span class="op_no_ul">fib(</span>pred<span class="op_no_ul">(num1))</span>+<a class="keywd_no_ul" href="#stats_if-statement">fib(num1</a>-<a class="op_no_ul" href="#stats_Assignment">if終了</a>関数終了<span class="func_no_ul"></span><span class="op_no_ul"></span><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre><p>上記の機能は<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>というパラメータ<tt>&#39;num1&#39;</tt>の譲渡<tt>&#39;num1&#39;</tt>は使用できません。 正式な<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータlike<tt>&#39;num1&#39;</tt>定数のように動作します。 フォーマルなものを変えようとすること<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータ:</p><pre class="indent">


2番
0;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type_no_ul" href="#types_proc">proc</a>:間違っている(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:num2)<span class="keywd">is func</span>begin<span class="keywd">:=</span>関数終了<a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span></pre><p>結果は<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst77.sd7(5):53:

num2:=0;
<a class="link" href="#errors_WRONGACCESSRIGHT">変数{num2:=0}でパラメータ(整数:num2)が見つかりました</a></pre><p>関数が実パラメータの値を変更したい場合<tt>&#39;<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a>&#39;</tt>パラメータ:</p><pre class="indent">


2番
0;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type_no_ul" href="#types_proc">proc</a>:reset(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><a class="type_no_ul" href="#types_integer">整数</a>:num2)<span class="keywd">is func</span>begin<span class="keywd">:=</span>関数終了<a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span></pre><p>この関数を</p><pre class="indent">reset(number);
</pre><p>変数<tt>&#39;数&#39;</tt>その後の値は0になります。 使命<tt>&#39;リセット&#39;</tt>変数の代わりに定数を使用して</p><pre class="indent">reset(8);
</pre><p>結果は<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst77.sd7(12):53:

reset(8);
<a class="link" href="#errors_WRONGACCESSRIGHT">{8 reset}で予期される変数で、定数整数:8が見つかりました</a></pre><p>場合によっては<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは必要ですが、実際のパラメータに影響を与えずに関数内の仮パラメータを変更する必要があります。 この場合は<tt>&#39;<a class="keywd_no_ul" href="#params_in_var_parameter">var内</a>&#39;</tt>パラメータ:</p><pre class="indent">



;






stri
stri;
数
8;

0;

;

;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_string">文字列</a>:oct_str(<a class="keywd_no_ul" href="#params_in_var_parameter">var内</a><a class="type_no_ul" href="#types_integer">整数</a>:番号)<span class="keywd">is func</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">文字列</a>:stri<a class="type_no_ul" href="#types_string">は</a><span class="keywd">&quot;&quot;</span>begin<a class="stri" href="#tokens_String_literals">if</a>数<span class="keywd">>=</span>0<a class="keywd_no_ul" href="#stats_if-statement">その時</a>繰り返す<span class="op_no_ul">:=</span><a class="keywd_no_ul" href="#stats_if-statement">str</a>(番号<a class="keywd_no_ul" href="#stats_repeat-statement">mod</a>8)<a class="op_no_ul" href="#stats_Assignment">&amp;</a>:=<span class="func_no_ul">数</span>mdiv<span class="op_no_ul">まで</span>数<span class="op_no_ul">=</span>if終了<a class="op_no_ul" href="#stats_Assignment">関数終了</a><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_repeat-statement"></a><span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre><p>ご覧のように、これは<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータをローカル変数<tt>&#39;<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a>&#39;</tt></p><p>通常、2種類のパラメータがあります。<tt>「値渡し」</tt>および<tt>「参照渡し」</tt>アクセス権(定数または変数)を考慮すると、次の表が得られます。</p><table border="1" cellspacing="0" cellpadding="5">

    <tr><th>パラメーター</th><th>呼び掛ける</th><th>アクセス権</th></tr>

    <tr><td>
          <tt>
            <a class="keywd_no_ul" href="#params_val_parameter">val</a>
          </tt>
        </td><td align="center">価値</td><td>const</td></tr>
    <tr><td>
          <tt>
            <a class="keywd_no_ul" href="#params_ref_parameter">参照</a>
          </tt>
        </td><td align="center">参考</td><td>const</td></tr>
    <tr><td>
          <tt>
            <a class="keywd_no_ul" href="#params_in_parameter">で</a>
          </tt>
        </td><td align="center">val/ref</td><td>const</td></tr>
    <tr><td>
          <tt>
            <a class="keywd_no_ul" href="#params_in_var_parameter">var内</a>
          </tt>
        </td><td align="center">価値</td><td>var</td></tr>
    <tr><td>
          <tt>
            <a class="keywd_no_ul" href="#params_inout_parameter">入力する</a>
          </tt>
        </td><td align="center">参考</td><td>var</td></tr>

</table><p>すでにわかっているパラメータに加えて、この表では次のパラメータについても説明します。<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>および<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>&#39;constant&#39;と&#39;constant&#39;を使用し、値渡しな仮パラメータを持つ参照渡し。 その<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータが呼び出されました。<tt>&#39;val/ref&#39;</tt>この表で簡単に説明できます。</p><dl><dd>An<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>または<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>パラメータのタイプによって異なります。</dd></dl><p>パラメータ</p><pre class="indent">:数
<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a></pre><p>は、&#39;val&#39;パラメータです。</p><pre class="indent">:数
<a class="keywd_no_ul" href="#params_val_parameter">val</a><a class="type_no_ul" href="#types_integer">整数</a></pre><p>一方、パラメータ</p><pre class="indent">:stri
<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_string">文字列</a></pre><p>は「ref」パラメータで</p><pre class="indent">:stri
<a class="keywd_no_ul" href="#params_ref_parameter">参照</a><a class="type_no_ul" href="#types_string">文字列</a></pre><p>の意味<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは、ほとんどのタイプに事前定義されています。 通常はデータ使用量が少ないタイプ<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>as<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>より大きなデータを持つ型が使用するパラメータ<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>ほとんどの場合、注意する必要はありません。<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは実際には<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>または<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>パラメータを使用します。</p><p>まれにa<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>パラメータがグローバル変数やその他の<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>パラメータ。 このような場合は、明示的な<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>パラメータを使用します。<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは意味をなします。</p><p>すべての正常な場合<tt>&#39;<a class="keywd_no_ul" href="#params_in_parameter">で</a>&#39;</tt>パラメータは明示的なものよりも優先されるべきです。<tt>&#39;<a class="keywd_no_ul" href="#params_val_parameter">val</a>&#39;</tt>および<tt>&#39;<a class="keywd_no_ul" href="#params_ref_parameter">参照</a>&#39;</tt>パラメータを使用します。</p>
          <a name="tutorial_Overloading">
        <h3>2.11オーバーロード</h3>
          </a>
        <p>関数は識別子だけでなく、パラメータの型によっても識別されます。 したがって、いくつかのバージョンの関数を定義することができます。</p><pre class="indent">
$
;

;

;

;


10.0;

10.0;

10_;






(tenPercent(123));

(tenPercent(123.0));

(tenPercent(123_));

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">float.s7i</span><span class="lib">&quot;</span><span class="lib">含む</span><span class="keywd">&quot;</span>bigint.s7i<span class="lib">&quot;</span><span class="lib">含む</span><span class="lib"></span>&quot;<span class="keywd">bigrat.s7i</span>&quot;<span class="lib">const</span><span class="lib"></span><span class="lib">機能</span><a class="keywd_no_ul" href="#decls_Function_declarations">浮かぶ</a>:tenPercent(<a class="type_no_ul" href="#types_func">で</a><a class="type_no_ul" href="#types_float">浮かぶ</a>:量)<a class="keywd_no_ul" href="#params_in_parameter">は</a><a class="type_no_ul" href="#types_float">リターン</a>量<span class="keywd">/</span>const<span class="keywd_no_ul"></span>機能<span class="op_no_ul"></span>浮かぶ<a class="keywd_no_ul" href="#decls_Function_declarations">:tenPercent(</a>で<a class="type_no_ul" href="#types_func"></a>整数<a class="type_no_ul" href="#types_float">:量)</a>は<a class="keywd_no_ul" href="#params_in_parameter"></a>リターン<a class="type_no_ul" href="#types_integer"></a>浮かぶ<span class="keywd">(額)</span>/<span class="keywd_no_ul">const</span><span class="func_no_ul">機能</span><span class="op_no_ul">bigRational</span>:tenPercent(<a class="keywd_no_ul" href="#decls_Function_declarations">で</a><a class="type_no_ul" href="#types_func">bigInteger</a>:量)<a class="type_no_ul" href="#types_bigRational">は</a><a class="keywd_no_ul" href="#params_in_parameter">リターン</a>量<a class="type_no_ul" href="#types_bigInteger">/</a>const<span class="keywd"></span>proc<span class="keywd_no_ul">:main</span>is func<span class="op_no_ul">begin</span>writeln<a class="keywd_no_ul" href="#decls_Procedure_declarations">writeln</a>writeln<a class="type_no_ul" href="#types_proc">関数終了</a><span class="keywd"></span><span class="keywd"></span><span class="func_no_ul"></span><span class="func_no_ul"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>上記の例は関数を定義する。<tt>tenPercent</tt>タイプ用<tt><a class="type" href="#types_float">浮かぶ</a></tt><tt><a class="type" href="#types_integer">整数</a></tt>および<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>これらの関数のうち2つは<tt><a class="type" href="#types_float">浮かぶ</a></tt>を返し<tt><a class="type" href="#types_bigRational">bigRational</a></tt>このように同じ関数名を再利用することを、オーバーロードと呼ぶ。 リテラルは<tt>123</tt><tt>123.0</tt>および<tt>123_</tt>タイプがある<tt><a class="type" href="#types_float">浮かぶ</a></tt><tt><a class="type" href="#types_integer">整数</a></tt>および<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>である。 これにより<tt>tenPercent</tt>関数を使用する。 に注意してください。<tt><span class="func">writeln</span></tt>オーバーロードされる。 それ以外の場合<tt><span class="func">writeln</span></tt>受け入れることができない<tt><a class="type" href="#types_float">浮かぶ</a></tt>および<tt><a class="type" href="#types_bigRational">bigRational</a></tt>引数。</p><p>多重定義では関数の結果を考慮しない。 次の例では、多重定義を試みます。<tt>addOne</tt>パラメータタイプが同じで結果タイプが異なる場合:</p><pre class="indent">1;

1.0;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_integer">整数</a>:addOne(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:num)<span class="keywd">は</span><span class="keywd_no_ul">リターン</span>num<span class="op">+</span>const<a class="keywd_no_ul" href="#decls_Function_declarations"></a>機能<a class="type_no_ul" href="#types_func"></a>浮かぶ<a class="type_no_ul" href="#types_float">:addOne(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>整数<a class="type_no_ul" href="#types_integer">:num)</a>は<span class="keywd"></span>リターン<span class="keywd_no_ul"></span>浮かぶ<span class="func_no_ul">(数)</span>+<span class="op"></span></pre><p><span class="link">戻り値の型のオーバーロード</span>はサポートされていません。 したがって、上記の試行は<a class="link" href="#errors_Parsing_errors">翻訳時エラー</a>:</p><pre class="indent">
***tst344.sd7(5):34:

const func float:addOne(in integer:num)is return float(num)+1.0;
----------------------------------------------------------------------------------------------------------------------------------------------------
***tst344.sd7(4):35:

const func integer:addOne(in integer:num)は、num+1を返します。
<a class="link" href="#errors_REDECLARATION">&quot;addOne(val integer:num)&quot;の再宣言</a>先の「addOne(val integer:num)」の宣言<a class="link" href="#errors_PREVIOUS_DECLARATION"></a></pre><p>の欠如<span class="link">戻り型の多重定義</span>以下の理由により、読みやすさが向上します</p><dl><dd><table border="1" cellspacing="0" cellpadding="5"><tr><td>すべての式(および副式)の型は、コンテキストから独立しています。</td></tr></table></dd></dl><p>式が使用されている場所を調べる必要はありません。 この式だけで、式の型を判断するのに十分な情報が得られます。</p><p>Operators like<tt><span class="op">+</span></tt>は以下で多重定義することができる。</p><pre class="indent">
$
;

;




summand2;




(summand2);






123.456)

123)

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">float.s7i</span><span class="lib">&quot;</span><span class="lib">const</span><a class="keywd_no_ul" href="#decls_Function_declarations">機能</a><a class="type_no_ul" href="#types_func">浮かぶ</a>:(<a class="type_no_ul" href="#types_float">で</a><a class="keywd_no_ul" href="#params_in_parameter">整数</a>:summand1)+(<a class="type_no_ul" href="#types_integer">で</a><a class="keywd_no_ul" href="#params_in_parameter">浮かぶ</a>:summand2)<a class="type_no_ul" href="#types_float">は</a>リターン<span class="keywd"></span>浮かぶ<span class="keywd_no_ul">(summand1)</span>+<span class="func_no_ul">const</span><span class="op_no_ul">機能</span><a class="keywd_no_ul" href="#decls_Function_declarations">浮かぶ</a>:(<a class="type_no_ul" href="#types_func">で</a><a class="type_no_ul" href="#types_float">浮かぶ</a>:summand1)+(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_float">整数</a>:summand2)<a class="keywd_no_ul" href="#params_in_parameter">は</a>リターン<a class="type_no_ul" href="#types_integer">減算1</a>+<span class="keywd"></span>浮かぶ<span class="keywd_no_ul">const</span><span class="op_no_ul">proc</span>:main<span class="func_no_ul">is func</span>begin<a class="keywd_no_ul" href="#decls_Procedure_declarations">writeln</a>(123<a class="type_no_ul" href="#types_proc">+</a>writeln<span class="keywd">(123.456</span>+<span class="keywd">関数終了</span><span class="func_no_ul"></span><span class="op_no_ul"></span><span class="func_no_ul"></span><span class="op_no_ul"></span><span class="keywd"></span></pre><p>の定義は<tt><span class="op">+</span></tt>上記の演算子は、の混合を可能にする<tt><a class="type_no_ul" href="#types_integer">整数</a></tt>および<tt><a class="type_no_ul" href="#types_float">浮かぶ</a></tt>引数。 過負荷の<tt><span class="op">+</span></tt>上記の演算子は<tt><span class="lib">mixarith.s7i</span></tt>ライブラリ。</p>
          <a name="tutorial_Templates">
        <h3>2.12テンプレート</h3>
          </a>
        <p>テンプレートを使用すると、実際の型が後で指定される関数を宣言できます。 関数の宣言は、型をパラメータとするプロシージャ内で行います。 図書館<span class="lib">integer.s7i</span>テンプレートを定義します。<tt>DECLARE_MIN_MAX</tt>as:</p><pre class="indent">




:value2)は

value1&lt;value2?value1:value2;


:value2)は

value1>value2?value1:value2;


;
<a class="keywd_no_ul" href="#decls_Templates">const</a><a class="type_no_ul" href="#types_proc">proc</a>:DECLARE_MIN_MAX(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_type">タイプ</a>:aType)<span class="keywd">is func</span>begin<span class="keywd">const</span><a class="keywd_no_ul" href="#decls_Function_declarations">機能</a><a class="type_no_ul" href="#types_func">aType</a>:min(<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">aType</a>:value1<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">aType</a>リターン<span class="type">const</span><span class="keywd_no_ul">機能</span><a class="keywd_no_ul" href="#decls_Function_declarations">aType</a>:最大(<a class="type_no_ul" href="#types_func">で</a><span class="type">aType</span>:value1<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">aType</span>リターン<a class="keywd_no_ul" href="#params_in_parameter">関数終了</a><span class="type"></span><span class="keywd_no_ul"></span><span class="keywd"></span></pre><p>テンプレート手順<tt>DECLARE_MIN_MAX</tt>タイプパラメータを使用します。<tt><span class="type_no_ul">aType</span></tt>関数を宣言する<tt><span class="func">分</span></tt>および<tt><span class="func">最大</span></tt>テンプレートは、以下を必要とするすべての実型に対してインスタンス化されます。<tt><span class="func">分</span></tt>および<tt><span class="func">最大</span></tt>例:</p><pre class="indent">
DECLARE_MIN_MAX(

DECLARE_MIN_MAX(

DECLARE_MIN_MAX(

<a class="type_no_ul" href="#types_integer">整数</a>);<a class="comment" href="#tokens_Line_comments">#integer.s7iライブラリでインスタンス化されました</a>bigInteger<a class="type_no_ul" href="#types_bigInteger">);</a>#bigint.s7iライブラリでインスタンス化されます<a class="comment" href="#tokens_Line_comments">浮かぶ</a>);<a class="type_no_ul" href="#types_float">#float.s7iライブラリでインスタンス化されます。</a><a class="comment" href="#tokens_Line_comments"></a></pre><p>これにより、次のような式が可能になります。<tt>最小(2、5)</tt>または<tt>最小(PI、E)</tt></p>
          <a name="tutorial_Declare_a_statement">
        <h3>2.13宣言</h3>
          </a>
        <p>このサンプルプログラムは、引数を記述します。</p><pre class="indent">
$







;




write(stri&lt;&amp;
);

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>;<a class="comment" href="#tokens_Line_comments">#Standard Seed7ライブラリ</a>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>文字列<a class="keywd_no_ul" href="#decls_Variable_declarations">:stri</a>は<a class="type_no_ul" href="#types_string"></a>&quot;&quot;<span class="keywd">begin</span>の<a class="stri" href="#tokens_String_literals">stri</a>範囲<span class="keywd">argv(PROGRAM)</span>do<span class="keywd">&quot;&quot;</span>終わる<span class="keywd">writeln</span>関数終了<span class="keywd"></span><a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>その<tt><a class="link" href="#stats_for-statement">for文</a></tt>繰り返される<tt><a class="func" href="#os_argv_PROGRAM">argv</a>(プログラム)</tt>・機能<tt><a class="func" href="#os_argv_PROGRAM">argv</a>(プログラム)</tt>は<tt><a class="type" href="#types_array">配列文字列</a></tt>(=<tt><a class="type" href="#types_array">配列</a></tt>の<tt><a class="type" href="#types_string">文字列</a></tt>要素)。 その<tt><a class="link" href="#stats_for-statement">for文</a></tt>様々なコレクション型に対してオーバーロードされます。 標準Seed7ライブラリに<tt><span class="lib">seed7_05.s7i</span></tt>その<tt><a class="link" href="#stats_for-statement">for文</a></tt>の<a class="type" href="#types_array">配列</a>sは次のように宣言される。</p><pre class="indent">:arr_obj)do
(
:ステートメント)
終わる




0;




変わりやすい
arr_obj[number];
文;

;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type_no_ul" href="#types_proc">proc</a>:for(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><span class="type">baseType</span>:variable)range(<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">arrayType</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type_no_ul" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">整数</span>:数<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a>begin<a class="type_no_ul" href="#types_integer">の</a>数<span class="keywd">範囲</span>1<span class="keywd">へ</span>長さ(arr_obj)<span class="keywd">do</span>:=<span class="keywd">終わる</span>関数終了<span class="keywd"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span></pre><p>この構文は、次のとおりです。<tt><a class="link" href="#stats_for-statement">for文</a></tt>は次のように宣言されます。</p><pre class="indent">
$
->25;
<span class="keywd">構文</span><span class="type">expr</span>:.for.().range.().to.().do.().end.for<span class="keywd">は</span></pre><p>さらに、誰もが<tt><a class="link" href="#stats_for-statement">for文</a></tt>も同様です。 これらの強力な機能のために、Seed7はイテレーターを必要としません。</p>
          <a name="tutorial_Template_declaring_a_statement">
        <h3>2.14文を宣言するテンプレート</h3>
          </a>
        <p>テンプレートは通常の関数です。<a class="type" href="#types_type">タイプ</a>sをパラメータとする。 次のテンプレート関数は<tt><a class="link" href="#stats_for-statement">for文</a></tt>:</p><pre class="indent">




:high)do
(



変わりやすい
low;


文;


incr(変数);
文;

;

;

;


;

FOR_DECLS(
);
FOR_DECLS(
);
<a class="keywd_no_ul" href="#decls_Templates">const</a><a class="type_no_ul" href="#types_proc">proc</a>:FOR_DECLS(<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">タイプ</span>:aType)<span class="keywd">is func</span>begin<span class="keywd">const</span><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:for(<a class="type_no_ul" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">aType</a>:variable)range(<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">aType</a>:低)から(<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">aType</a>で<span class="type"></span>proc<a class="keywd_no_ul" href="#params_in_parameter">:ステートメント)終了</a>is func<a class="type_no_ul" href="#types_proc">begin</a>:=<span class="keywd">if</span>変数&lt;=高<span class="keywd">その時</span>一方で<a class="op_no_ul" href="#stats_Assignment">変数&lt;高</a>do<a class="keywd_no_ul" href="#stats_if-statement">whileを終了する</a>if終了<a class="keywd_no_ul" href="#stats_if-statement">関数終了</a>関数終了<a class="keywd_no_ul" href="#stats_while-statement">char</a>ブール<a class="keywd_no_ul" href="#stats_while-statement"></a><a class="keywd_no_ul" href="#stats_while-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="type"></span></pre><p>FOR_DECLS関数の本体には、次の宣言が含まれます。<tt><a class="link" href="#stats_for-statement">for文</a></tt>タイプの<tt><span class="type">aType</span></tt>で&#39;FOR_DECLS&#39;を呼び出す<tt><a class="type" href="#types_char">char</a></tt>および<tt><a class="type" href="#types_boolean">ブール</a></tt>asパラメータは、対応する宣言を作成します。<tt><a class="link" href="#stats_for-statement">for文</a></tt>上記の例は、ライブラリの一部を簡略化したものです。<tt><span class="lib">forloop.s7i</span></tt></p>
          <a name="decls_file_start"></a>
        <p></p>
          <a name="decls_DECLARATIONS">
        <h2>3宣言</h2>
          </a>
        <p>宣言は、識別子、型、および変数、定数、関数などの言語要素のその他の側面を指定します。 Seed7では、使用する前にすべてを宣言する必要があります。 すべての宣言は特定のキーワードで導入され、共通のパターンに従います。 キーワードの後にタイプが続く<!--(*-->(サンプルコード<span class="type">赤</span>が使用される)<!--*)-->・下表中<tt><span class="type">aType</span></tt>は、任意ののプレースホルダです。<a class="link" href="#types_file_start">タイプ</a></p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>宣言</th><th>コメント</th></tr>

  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><span class="type">aType</span>:name<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Variable_declarations">変数宣言</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Constant_declarations">const</a><span class="type">aType</span>:name<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Constant_declarations">定数宣言</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_val_parameter">val</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_val_parameter">value-parameter</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_ref_parameter">参照</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_ref_parameter">参照パラメータ</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_in_parameter">インパラメータ</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_var_parameter">var内</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_in_var_parameter">in-var-parameter</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_inout_parameter">inout-parameter</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><span class="type">aType</span>:name</tt>
        </td><td>の宣言<a class="link" href="#params_call_by_name_parameter">名前呼びパラメーター</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Type_declarations">const</a><a class="type_no_ul" href="#types_type">タイプ</a>:name<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Type_declarations">型宣言</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type_no_ul" href="#types_proc">proc</a>:name<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Procedure_declarations">プロシージャ宣言</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><span class="type">aType</span>:name<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Function_declarations">関数宣言</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Abstract_data_types">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_type">タイプ</a>:name<span class="keywd">は</span></tt>
        </td><td>の宣言<a class="link" href="#decls_Abstract_data_types">抽象データ型</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Templates">const</a><a class="type_no_ul" href="#types_proc">proc</a>:name(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_type">タイプ</a>:<span class="type">aType</span>)<span class="keywd">は</span></tt>
        </td><td>の宣言<a class="link" href="#decls_Templates">テンプレート(template)</a></td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#decls_Syntax_declarations">構文</a><a class="type_no_ul" href="#types_expr">expr</a>:pattern<span class="keywd">は</span></tt>
        </td><td>A<a class="link" href="#decls_Syntax_declarations">構文宣言</a></td></tr>

</table></dd></dl><p></p>
          <a name="decls_Variable_declarations">
        <h3>3.1変数の宣言</h3>
          </a>
        <p>変数とは、値の場所の名前です。 変数の値は<a class="link" href="#stats_Assignment">譲渡</a>変数は使用する前に宣言する必要があります。 例:</p><pre class="indent">0;
<span class="keywd">var</span><a class="type_no_ul" href="#types_integer">整数</a>:数<span class="keywd">は</span></pre><p>これは<tt><a class="type" href="#types_integer">整数</a></tt>変わりやすい<tt>&#39;数&#39;</tt>変数は値0で初期化されます。 その後、変数の値を次のように変更できます。</p><pre class="indent">
数
1;
<a class="op_no_ul" href="#stats_Assignment">:=</a></pre><p>変数は、その型の値のみを保持できます。 間違った型の値を代入しようとすると、コンパイルエラーになります。</p><pre class="indent">
***tst545.sd7(7):57:

number:=&quot;hello&quot;;
<a name="decls_NO_MATCH_example"></a><a class="link" href="#errors_NO_MATCH">{number:=&quot;hello&quot;}との一致は失敗しました</a></pre><p></p>
          <a name="decls_Constant_declarations">
        <h3>3.2定数宣言</h3>
          </a>
        <p>定数は、実行中に変更できない名前付きの値です。 定数は、使用する前に宣言する必要があります。 例:</p><pre class="indent">1;
<span class="keywd">const</span><a class="type_no_ul" href="#types_integer">整数</a>:ONE<span class="keywd">は</span></pre><p>これは<tt><a class="type" href="#types_integer">整数</a></tt>一定した<tt>「1つ」</tt>の値は1です。 定数を変更しようとすると、コンパイルエラーになります。</p><pre class="indent">
***tst544.sd7(7):58:

ONE:=2;
<a class="link" href="#errors_WRONGACCESSRIGHT">{ONE:=2}で予期される変数が定数integer:ONEを検出しました</a></pre><p></p>
          <a name="decls_Type_declarations">
        <h4>3.2.1型式宣言</h4>
          </a>
        <p>型宣言は、型の名前を定義します。 型宣言は定数宣言として行われ、宣言された定数の型は次のとおりです。<tt><a class="type" href="#types_type">タイプ</a></tt>例:</p><pre class="indent">;
<span class="keywd">const</span><a class="type_no_ul" href="#types_type">タイプ</a>:myChar<span class="keywd">は</span><a class="type_no_ul" href="#types_char">char</a></pre><p>その後、新しい型を他の宣言で使用することができます。 例:</p><pre class="indent">;
<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><span class="type">myChar</span>:aChar<span class="keywd">は</span><a class="stri" href="#tokens_Character_literals">「x」</a></pre><p></p>
          <a name="decls_Procedure_declarations">
        <h4>3.2.2手続き宣言</h4>
          </a>
        <p>プロシージャのコードは実行時に変更されません。 したがって、プロシージャは定数宣言で宣言されます。</p><pre class="indent">



);

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:helloWorld<span class="keywd">is func</span>begin<span class="keywd">writeln</span>(<span class="func_no_ul">&quot;hello world&quot;</span>関数終了<a class="stri" href="#tokens_String_literals"></a><span class="keywd"></span></pre><p>キーワードを使用して、プロシージャにローカル宣言を追加できます。<tt><span class="keywd">地域の</span></tt>例:</p><pre class="indent">



;



(挨拶);

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:helloWorld<span class="keywd">is func</span>地域の<span class="keywd">const</span><span class="keywd">文字列</span>:greeting<a class="type_no_ul" href="#types_string">は</a><span class="keywd">&quot;hello world&quot;</span>begin<a class="stri" href="#tokens_String_literals">writeln</a>関数終了<span class="keywd"></span><span class="func_no_ul"></span><span class="keywd"></span></pre><p>パラメータ(<tt>挨拶</tt>)は次のように定義されています。</p><pre class="indent">



(挨拶);

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:hello(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_string">文字列</a>:greeting)<span class="keywd">is func</span>begin<span class="keywd">writeln</span>関数終了<span class="func_no_ul"></span><span class="keywd"></span></pre><p>プロシージャと関数パラメータは、に説明があります。<a class="link" href="#params_file_start">第6章(パラメータ)</a></p>
          <a name="decls_Function_declarations">
        <h4>3.2.3関数の宣言</h4>
          </a>
        <p>手続きと同様に、関数のコードは実行時に変更されません。 したがって、関数は定数宣言でも宣言されます。</p><pre class="indent">

);
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:flipCoin<span class="keywd">は</span>リターン<span class="keywd_no_ul"></span>ランド<span class="func">(</span>FALSE<span class="var"></span>TRUE<span class="var"></span></pre><p>に注意してください。<tt><span class="keywd_no_ul">リターン</span></tt>は文ではありません。 代わりに<tt><span class="keywd_no_ul">リターン</span></tt>は<span class="link">結果変数</span>:</p><pre class="indent">



;


coinState
);

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:flipCoin<span class="keywd">is func</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">ブール</a>:coinState<a class="type_no_ul" href="#types_boolean">は</a><span class="keywd">FALSE</span>begin<span class="var">:=</span><span class="keywd">ランド</span>(<a class="op_no_ul" href="#stats_Assignment">FALSE</a><span class="func">TRUE</span>終わり<span class="var"></span>機能<span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>A<span class="link">結果変数</span>は、関数の結果として使用される特定のローカル変数です。 もしそうでなければ<a class="link" href="#stats_Assignment">譲渡</a>を実行して<a class="link" href="#decls_Initialization">初期値</a>結果値のは関数の結果です。</p><pre class="indent">



0;





(count);

;

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_integer">整数</a>:countDigits<span class="keywd">is func</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">整数</a>:count<a class="type_no_ul" href="#types_integer">は</a>begin<span class="keywd">一方で</span><span class="keywd">getc</span>(<a class="keywd_no_ul" href="#stats_while-statement">IN</a>)<span class="func">で</span>{<span class="var">&#39;0&#39;</span><span class="op">&#39;9&#39;</span>}<a class="stri" href="#tokens_Character_literals">do</a>増加<a class="stri" href="#tokens_Character_literals">終わり</a><a class="keywd_no_ul" href="#stats_while-statement">一方で</a>終わり<span class="func"></span>機能<a class="keywd_no_ul" href="#stats_while-statement"></a><a class="keywd_no_ul" href="#stats_while-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>キーワード<tt>地域の</tt>では、ローカル宣言を導入できます。</p><pre class="indent">



;



;




abc
ch;

;

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_string">文字列</a>:アルファベット<span class="keywd">is func</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">文字列</a>:abc<a class="type_no_ul" href="#types_string">は</a><span class="keywd">&quot;&quot;</span>地域の<a class="stri" href="#tokens_String_literals">var</a><span class="keywd">char</span>:ch<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_char">「」</a>begin<span class="keywd">の</span>ch<a class="stri" href="#tokens_Character_literals">範囲</a><span class="keywd">&#39;a&#39;</span><a class="keywd_no_ul" href="#stats_for-statement">へ</a><a class="keywd_no_ul" href="#stats_for-statement">&#39;z&#39;</a><a class="stri" href="#tokens_Character_literals">do</a>&amp;:=<a class="keywd_no_ul" href="#stats_for-statement">終わり</a><a class="stri" href="#tokens_Character_literals">の</a>終わり<a class="keywd_no_ul" href="#stats_for-statement"></a>機能<span class="op_no_ul"></span><a class="keywd_no_ul" href="#stats_for-statement"></a><a class="keywd_no_ul" href="#stats_for-statement"></a><span class="keywd"></span><span class="keywd"></span></pre><p>パラメータ(<tt>数</tt>)は次のように定義されています。</p><pre class="indent">

数;
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_float">浮かぶ</a>:inverse(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_float">浮かぶ</a>:番号)<span class="keywd">は</span>リターン<span class="keywd_no_ul">1.0</span>/<span class="op_no_ul"></span></pre><p>プロシージャと関数パラメータは、に説明があります。<a class="link" href="#params_file_start">第6章(パラメータ)</a></p>
          <a name="decls_Forward_declarations">
        <h4>3.2.4宣言の転送</h4>
          </a>
        <p>Seed7では、使用する前にすべてを宣言する必要があります。</p><p>これにより、コードの追跡が容易になり、コンパイラの実装が容易になります。</p><p>完全に宣言する前に使用する必要がある場合は、前方宣言が必要です。</p><pre class="indent">;




(数));




(数));
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:isOdd(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:番号)<span class="keywd">は</span><span class="keywd">前方の</span>const<a class="keywd_no_ul" href="#decls_Function_declarations"></a>機能<a class="type_no_ul" href="#types_func"></a>ブール<a class="type_no_ul" href="#types_boolean">:isEven(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>整数<a class="type_no_ul" href="#types_integer">:番号)</a>は<span class="keywd">リターン</span>数<span class="keywd_no_ul">=</span>0<span class="op_no_ul"></span><span class="op_no_ul">TRUE</span><span class="var_no_ul">:</span><span class="op_no_ul">isOdd</span>(<span class="func">pred</span>const<span class="func_no_ul"></span>機能<a class="keywd_no_ul" href="#decls_Function_declarations"></a>ブール<a class="type_no_ul" href="#types_func">:isOdd(</a>で<a class="type_no_ul" href="#types_boolean"></a>整数<a class="keywd_no_ul" href="#params_in_parameter">:番号)</a>は<a class="type_no_ul" href="#types_integer">リターン</a>数<span class="keywd">=</span>0<span class="keywd_no_ul"></span><span class="op_no_ul">FALSE</span><span class="op_no_ul">:</span><span class="var_no_ul">isEven</span>(<span class="op_no_ul">pred</span><span class="func"></span><span class="func_no_ul"></span></pre>
          <a name="decls_Interface_declarations">
        <h4>3.2.5インタフェース宣言</h4>
          </a>
        <p>その<a class="link" href="#objects_file_start">物体定位</a>Seed7のは、インタフェースタイプとインタフェース関数に基づいています。 例:</p><pre class="indent"><a class="keywd_no_ul" href="#decls_Type_declarations">const</a><a class="type_no_ul" href="#types_type">タイプ</a>:file<span class="keywd">は</span><a class="keywd_no_ul" href="#objects_inheritance">サブ</a><a class="type_no_ul" href="#types_object">物</a><a class="keywd_no_ul" href="#objects_interface_and_implementation">インターフェース</a>;<a class="comment" href="#tokens_Line_comments">#インタフェースの型を宣言する</a>const<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>proc<a class="type_no_ul" href="#types_proc">:write(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>ファイルする<a class="type_no_ul" href="#types_file">:outFile</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>文字列<a class="type_no_ul" href="#types_string">:stri)</a>は<span class="keywd">DYNAMIC;</span>#インタフェース関数を宣言する<a class="comment" href="#tokens_Line_comments"></a></pre><p>実際の型と関数は、次のインタフェースを実装しています。</p><pre class="indent">

;

1;

;

type_implements_interface(





<a class="keywd_no_ul" href="#decls_Type_declarations">const</a><a class="type_no_ul" href="#types_type">タイプ</a>:stritFile<span class="keywd">は</span><a class="keywd_no_ul" href="#types_struct">サブ</a><span class="type_no_ul">空ファイル</span><a class="keywd_no_ul" href="#types_struct">構造体</a><a class="comment" href="#tokens_Line_comments">#Implementation type</a>var<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>文字列<a class="type_no_ul" href="#types_string">:内容</a>は<span class="keywd"></span>&quot;&quot;<a class="stri" href="#tokens_String_literals">var</a><a class="keywd_no_ul" href="#decls_Variable_declarations">整数</a>:位置<a class="type_no_ul" href="#types_integer">は</a>終わり<span class="keywd"></span>構造体<a class="keywd_no_ul" href="#types_struct">striFile</a><a class="keywd_no_ul" href="#types_struct">ファイルする</a>);<span class="type_no_ul">#Connect implementation type to interface type</span>const<a class="type_no_ul" href="#types_file"></a>proc<a class="comment" href="#tokens_Line_comments">:write(</a>入力する<a class="keywd_no_ul" href="#decls_Procedure_declarations"></a>striFile<a class="type_no_ul" href="#types_proc">:outStritFile</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>文字列<span class="type_no_ul">:stri)</span>は<a class="keywd_no_ul" href="#params_in_parameter"></a>機能<a class="type_no_ul" href="#types_string"></a>#Implementation function<span class="keywd"></span><span class="keywd"></span><a class="comment" href="#tokens_Line_comments"></a></pre><p>関数は、インタフェース型と実装型を使用して、新しいインタフェース値を作成します。</p><pre class="indent">



;



value;


new_striFile.content
内容;
新しいファイル
toInterface(new_stritFile);

;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_file">ファイルする</a>:openStriFile(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_string">文字列</a>:含有量)<span class="keywd">は</span><span class="keywd">機能</span>結果<span class="keywd_no_ul">var</span><a class="keywd_no_ul" href="#decls_Variable_declarations">ファイルする</a>:newFile<a class="type_no_ul" href="#types_file">は</a><span class="keywd">STD_NULL</span>地域の<span class="var_no_ul">var</span><span class="keywd">striFile</span>:new_stritFile<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><span class="type_no_ul">striFile</span>begin<span class="keywd">:=</span>:=<span class="type_no_ul">終わり</span><span class="keywd">機能</span><a class="op_no_ul" href="#stats_Assignment"></a><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span></pre><p>機能<tt>toInterface</tt>から所有権を移す<tt>new_stritFile</tt>へ<tt>新しいファイル</tt></p>
          <a name="decls_Abstract_data_types">
        <h4>3.2.6抽象データ型</h4>
          </a>
        <p>抽象データ型は付加情報を必要とする型である。 例:抽象データ型<tt><a class="type" href="#types_array">配列</a></tt>は、付加情報として配列要素の型を必要とします。 事前定義された抽象データ型は次のとおりである。<tt><a class="type" href="#types_array">配列</a></tt><tt><span class="type">副型</span></tt><tt><a class="type" href="#types_struct">構造体</a></tt><tt><span class="type">部分範囲</span></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt><tt><a class="type" href="#types_set">設定する</a></tt><tt><span class="type">インターフェース</span></tt>および<tt><span class="type">列挙型</span></tt>・定義済み抽象データ型の定義<tt><a class="type" href="#types_array">配列</a></tt>図書館で<span class="lib">s7i</span>は次のように始まります。</p><pre class="indent">
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_type">タイプ</a>:array(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_type">タイプ</a>:baseType)<span class="keywd">は</span></pre><p>パラメータ<tt><span class="type">baseType</span></tt>のタイプを指定します。<tt><a class="type" href="#types_array">配列</a></tt>要素。 抽象データ型<tt><a class="type" href="#types_array">配列</a></tt>は、次のように宣言で使用できます。</p><pre class="indent">[](1);
<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type_no_ul" href="#types_array">配列</a><a class="type_no_ul" href="#types_integer">整数</a>:数字<span class="keywd">は</span></pre><p>他の抽象データ型は以下のように宣言されます。<tt><a class="type" href="#types_array">配列</a></tt></p><p>ユーザ定義の抽象データ型も使用できます。</p>
          <a name="decls_Templates">
        <h4>3.2.7テンプレート</h4>
          </a>
        <p>テンプレートは、特定の型を宣言します。 テンプレートはコンパイル時に実行されます。 機能<tt>FOR_ENUM_DECLS</tt>図書館から<span class="lib">forloop.s7i</span>は、特定の列挙型のすべての値をループするfor-loopを定義します。</p><pre class="indent">




)do
(





文;

;

;


;
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:FOR_ENUM_DECLS(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_type">タイプ</a>:<span class="type">aType</span>)<span class="keywd">is func</span>begin<span class="keywd">const</span><span class="keywd">proc</span>:for(<a class="type_no_ul" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">aType</a>:variable)range(<span class="type">attr</span><a class="keywd_no_ul" href="#params_attr_parameter">aType</a>で<span class="type"></span>proc<a class="keywd_no_ul" href="#params_in_parameter">:ステートメント)終了</a>is func<a class="type_no_ul" href="#types_proc">begin</a>の<span class="keywd">変わりやすい</span>範囲<span class="keywd">aType.first</span>へ<span class="keywd">aType.last</span>do<span class="keywd">終わる</span>関数終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>テンプレート<tt>FOR_ENUM_DECLS</tt>ライブラリで呼び出されます。<span class="lib">列挙型.s7i</span>変更後:</p><pre class="indent">FOR_ENUM_DECLS(enumType);
</pre><p></p>
          <a name="decls_Initialization">
        <h3>3.3初期化</h3>
          </a>
        <p>で宣言された各オブジェクトは<tt>&#39;<span class="keywd">const</span>&#39;</tt>または<tt>&#39;<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a>&#39;</tt>宣言は初期値を取得します。 使用できない<tt>&#39;<span class="keywd">const</span>&#39;</tt>または<tt>&#39;<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a>&#39;</tt>初期値のない宣言。 初期値の型は変数や定数の型に適合していなければなりません。 そうでない場合、コンパイルエラーがトリガーされます。</p><pre class="indent">
***tst546.sd7(3):57:

var integer:numberは&#39;&#39;;
-------------------------^
***tst546.sd7(3):42:

var integer:numberは&#39;&#39;;
<a class="link" href="#errors_NO_MATCH">{number::=&#39;&#39;}の一致は失敗しました</a><a name="decls_DECL_FAILED_example">&quot;number&quot;の宣言に失敗しました。</a><a class="link" href="#errors_DECL_FAILED"></a></pre><p>初期値として式を使用することができます。 例:</p><pre class="indent">;
<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type_no_ul" href="#types_string">文字列</a>:fileName<span class="keywd">は</span>NAME<span class="op_no_ul">&amp;</span><span class="stri">&quot;.txt&quot;</span></pre><p>式が評価され、結果が新しいオブジェクトに代入されます。 これは、インタプリタまたはコンパイラによってコンパイル時に行われます。 初期設定式には、任意の関数(または演算子)呼び出しを含めることができます。 そうすることで、ユーザ定義関数を使用して定数や変数を初期化することもできます。</p><pre class="indent">flipCoin;
<span class="keywd">const</span><a class="type_no_ul" href="#types_boolean">ブール</a>:たぶん<span class="keywd">は</span></pre><p></p>
          <a name="decls_How_the_initialization_works">
        <h4>3.3.1初期化の仕組み</h4>
          </a>
        <p>変数と定数の初期化はコンパイル時に行われます。 初期化では<a class="link" href="#types_creator">作成演算子</a>(<tt><a class="op_no_ul" href="#types_creator">::=</a></tt>)。 に注意してください。<tt><a class="op_no_ul" href="#types_creator">::=</a></tt>はインタプリタとコンパイラによって内部的に使用されます。 の明示的な呼び出し<tt><a class="op_no_ul" href="#types_creator">::=</a></tt>ユーザプログラム内では使用できません。 その<a class="link" href="#types_creator">作成演算子</a>は<a class="link" href="#stats_Assignment">代入文</a>(<tt><a class="op_no_ul" href="#stats_Assignment">:=</a></tt>)、しかし2つの重要な違いがあります。</p><ol><li>割当て先は正当な値であると仮定できる。<a class="link" href="#types_creator">オペレータを作成する</a>デスティネーションに未定義の値があると仮定する。A<a class="link" href="#types_creator">作成演算子</a>必要なすべての初期化を実行する必要があります。</li><li>代入は、値を変数に代入する場合にのみ使用できます。<a class="link" href="#types_creator">オペレータを作成する</a>は変数に限定されません。 インタプリタとコンパイラの使用<tt><a class="op_no_ul" href="#types_creator">::=</a></tt>定数を初期化します。</li></ol><p>オブジェクトのライフタイムは次のようになります。</p><ol><li>メモリーは、新しいオブジェクト用に予約されます(スタック・メモリーまたはヒープメモリによる違いはありません)。</li><li>新しいメモリの内容は未定義である(ゴミが含まれている可能性がある)。<a class="link" href="#types_creator">作成演算子</a>(<a class="op_no_ul" href="#types_creator">::=</a>)が必要です。<a class="link" href="#stats_Assignment">代入文</a>(<a class="op_no_ul" href="#stats_Assignment">:=</a>)。</li><li>その<a class="link" href="#types_creator">作成演算子</a>(<a class="op_no_ul" href="#types_creator">::=</a>)は、左の式が未定義であることを考慮して、右の式を左の式にコピーします。</li><li>オブジェクトが可変の場合、他の値は<a class="link" href="#stats_Assignment">代入文</a>(<a class="op_no_ul" href="#stats_Assignment">:=</a>)。 この代入では、代入先に正当な値が含まれていると仮定できます。</li><li>文字列(およびその他の一部のタイプ)は、データが存在するメモリ領域への参照にすぎません。 これらの参照がメモリ領域の唯一の所有者となります。 これにより、割当てによってメモリー領域を再割当てできます。</li><li>オブジェクトの存続期間が終了すると<a class="link" href="#types_destroyer">破壊操作</a>を実行する。 文字列(およびメモリ領域への単なる参照であるその他のタイプ)の場合、参照されたメモリは解放されます。</li><li>オブジェクトのメモリーは解放されます。</li></ol><p>最初の3つのステップは通常、宣言文の中に隠されています。 宣言文が実行されます。</p><pre class="indent">
ONE
1
<a class="op_no_ul" href="#types_creator">::=</a></pre><p>割り当てる<tt>1</tt>その物体に<tt>ONE</tt>その<a class="link" href="#types_destroyer">破壊操作</a>は<a class="link" href="#types_creator">作成演算子</a>オブジェクトの存続期間が終了すると自動的に実行されます。 ランタイムライブラリが実行されます。</p><pre class="indent">(fileName)
<a class="func_no_ul" href="#types_destroyer">破壊する</a></pre><p>で参照されるメモリを解放します。<tt><a class="type_no_ul" href="#types_string">文字列</a></tt>変わりやすい<tt>fileName</tt>次のような単純なタイプの場合<tt><a class="type_no_ul" href="#types_integer">整数</a></tt>その<a class="link" href="#types_destroyer">破壊操作</a>は何もしない。</p><p>createとdestroyを使用したメカニズムは、値渡しパラメータ(<tt><a class="keywd_no_ul" href="#params_val_parameter">val</a></tt><tt><a class="keywd_no_ul" href="#params_in_var_parameter">var内</a></tt>および<tt><a class="keywd_no_ul" href="#params_in_parameter">で</a></tt>(値渡しを使用している場合)。 関数が呼び出されると、値渡しパラメータは<a class="link" href="#types_creator">作成演算子</a>:</p><pre class="indent">
formalパラメータ
actualパラメータ
<a class="op_no_ul" href="#types_creator">::=</a></pre><p>関数の最後に<a class="link" href="#types_destroyer">破壊操作</a>を実行する。</p><pre class="indent">(formalParameter)
<a class="func_no_ul" href="#types_destroyer">破壊する</a></pre><p>すべての定義済みタイプについて<a class="link" href="#types_creator">作成演算子</a>(<tt><a class="op_no_ul" href="#types_creator">::=</a></tt>)および<a class="link" href="#types_destroyer">破壊操作</a>はすでに定義されています。 新しいユーザー定義型のオブジェクトを宣言できるようにするには、この型のcreate操作とdestroy操作を定義する必要があります。</p>
          <a name="decls_Syntax_declarations">
        <h3>3.4構文の宣言</h3>
          </a>
        <p>構文宣言は、演算子、ステートメント、宣言、およびその他の構成要素の構文、優先順位、および結合性を指定するために使用されます。 構文宣言。<tt>&#39;+&#39;</tt>operator:</p><pre class="indent">
$
->7;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.(). +.()<span class="keywd">は</span></pre><p>ほとんどの構文定義は次のファイルにあります。<tt><span class="lib">構文.s7i</span></tt>構文宣言の詳細な説明は<a class="link" href="#syntax_file_start">第9章(構造化構文定義)</a>また、括弧で囲まれたパラメータリストを持つ関数呼び出しのハードコードされた構文もあります。この場合、パラメータはカンマで区切られます。 ハードコードされた構文は<a class="link" href="#expr_file_start">第11章(式)</a>ここでは、より複雑な構文記述を使用します。</p>
          <a name="decls_System_declarations">
        <h3>3.5システム宣言</h3>
          </a>
        <p>システム宣言により、アナライザとインタプリタは、様々なシステム内部の目的のためにどのオブジェクトを使用すべきかを知ることができます。 システム宣言の例を以下に示します。</p><pre class="indent">
$
;
<span class="keywd">システム</span><span class="stri">&quot;integer&quot;</span><span class="keywd">は</span><a class="type_no_ul" href="#types_integer">整数</a></pre><p>これは、すべての整数リテラルの型が<tt><a class="type" href="#types_integer">整数</a></tt>さらに<tt><a class="type" href="#types_integer">整数</a></tt>は、プリミティブアクションで生成されるすべての整数の型として使用されます。 システム宣言で定義されるさまざまなオブジェクトがあります。</p><ul>
    <li>リテラルと単純表現のタイプ例:<tt><a class="type" href="#types_string">文字列</a></tt>文字列と<tt><a class="type" href="#types_integer">整数</a></tt>整数の場合</li>

    <li>プリミティブアクションの結果値として使用するオブジェクト。例:<dl><dd><tt><span class="var">TRUE</span></tt><tt><span class="var">FALSE</span></tt>および<tt><a class="var" href="#types_void">空の</a></tt></dd></dl></li>

    <li>プリミティブなアクションによって発生する例外。例えば:<dl><dd><tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt>および<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt></dd></dl></li>

    <li>いくつかの暗黙的アクションに使用するオブジェクトの例:<dl><dd><tt>:=</tt><tt>::=</tt><tt><span class="func">破壊する</span></tt><tt><span class="func">書く</span></tt>および<tt><span class="func">フラッシュ</span></tt></dd></dl></li>
</ul><p>次のシステム宣言が存在します。</p><pre class="indent">
$
;
$
;
$
;
$
;
$
;
$
;
$
;
$
;

$
;
$
;
$
;

$
;
$
;
$
;
$
;
$
;
$
;
$
;
$
;
$
;

$
:=;
$
::=;
$
destroy;
$
ord;
$
;
$
PROT_OUTFILE;
$
flush;
$
write;
$
writeln;
$
main;
<span class="keywd">システム</span><a name="decls_expr"><span class="stri">&quot;expr&quot;</span></a><span class="keywd">は</span><a class="type" href="#types_expr">expr</a>システム<span class="keywd"></span>&quot;f_param&quot;<a name="decls_f_param"><span class="stri"></span></a>は<span class="keywd"></span>f_param<span class="type">システム</span><span class="keywd">&quot;integer&quot;</span><a name="decls_integer"><span class="stri">は</span></a><span class="keywd">整数</span>システム<a class="type" href="#types_integer"></a>&quot;bigInteger&quot;<span class="keywd"></span>は<a name="decls_bigInteger"><span class="stri"></span></a>bigInteger<span class="keywd">システム</span><a class="type" href="#types_bigInteger">&quot;char&quot;</a><span class="keywd">は</span><a name="decls_char"><span class="stri">char</span></a>システム<span class="keywd"></span>&quot;文字列&quot;<a class="type" href="#types_char"></a>は<span class="keywd"></span>文字列<a name="decls_string"><span class="stri">システム</span></a><span class="keywd">&quot;proc&quot;</span><a class="type" href="#types_string">は</a><span class="keywd">proc</span>システム<a name="decls_proc"><span class="stri"></span></a>&quot;float&quot;<span class="keywd"></span>は<a class="type" href="#types_proc"></a>浮かぶ<span class="keywd">システム</span><a name="decls_float"><span class="stri">「true」</span></a><span class="keywd">は</span><a class="type" href="#types_float">TRUE</a>システム<span class="keywd"></span>「間違い」<a name="decls_true"><span class="stri"></span></a>は<span class="keywd"></span>FALSE<span class="var">システム</span><span class="keywd">「空」</span><a name="decls_false"><span class="stri">は</span></a><span class="keywd">空の</span>システム<span class="var"></span>&quot;memory_error&quot;<span class="keywd"></span>は<a name="decls_empty"><span class="stri"></span></a>メモリエラー<span class="keywd">システム</span><a class="var" href="#types_void">&quot;数値エラー&quot;</a><span class="keywd">は</span><a name="decls_memory_error"><span class="stri">NUMERIC_ERROR</span></a>システム<span class="keywd"></span>&quot;overflow_error&quot;<a class="exception" href="#errors_MEMORY_ERROR"></a>は<span class="keywd"></span>OVERFLOW_ERROR<a name="decls_numeric_error"><span class="stri">システム</span></a><span class="keywd">&quot;範囲エラー&quot;</span><a class="exception" href="#errors_NUMERIC_ERROR">は</a><span class="keywd">範囲エラー</span>システム<a name="decls_overflow_error"><span class="stri"></span></a>&quot;index_error&quot;<span class="keywd"></span>は<a class="exception" href="#errors_OVERFLOW_ERROR"></a>INDEX_ERROR<span class="keywd">システム</span><a name="decls_range_error"><span class="stri">&quot;file_error&quot;</span></a><span class="keywd">は</span><a class="exception" href="#errors_RANGE_ERROR">FILE_ERROR</a>システム<span class="keywd"></span>&quot;database_error&quot;<a name="decls_index_error"><span class="stri"></span></a>は<span class="keywd"></span>DATABASE_ERROR<a class="exception" href="#errors_INDEX_ERROR">システム</a><span class="keywd">&quot;グラフィックエラー&quot;</span><a name="decls_file_error"><span class="stri">は</span></a><span class="keywd">GRAPHIC_ERROR</span>システム<a class="exception" href="#errors_FILE_ERROR"></a>&quot;illegible_action&quot;<span class="keywd"></span>は<a name="decls_database_error"><span class="stri"></span></a>ILLEGAL_ACTION<span class="keywd">システム</span><a class="exception" href="#errors_DATABASE_ERROR">&quot;assign&quot;</a><span class="keywd">は</span>システム<a name="decls_graphic_error"><span class="stri"></span></a>&quot;create&quot;<span class="keywd"></span>は<a class="exception" href="#errors_GRAPHIC_ERROR">システム</a><span class="keywd">「破壊する」</span><a name="decls_illegal_action"><span class="stri">は</span></a>システム<span class="keywd"></span>&quot;ord&quot;<a class="exception" href="#errors_ILLEGAL_ACTION"></a>は<span class="keywd">システム</span><span class="stri">&quot;in&quot;</span><span class="keywd">は</span><span class="keywd">で</span>システム<span class="stri"></span>&quot;prot_outfile&quot;<span class="keywd"></span>は<span class="keywd">システム</span><span class="stri">「フラッシュ」</span><span class="keywd">は</span>システム<span class="keywd"></span>&quot;write&quot;<span class="stri"></span>は<span class="keywd">システム</span><span class="keywd">&quot;writeln&quot;</span><span class="stri">は</span>システム<span class="keywd"></span>「主」<span class="keywd"></span>は<span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre>
          <a name="decls_Pragmas">
        <h3>3.6プラグマ</h3>
          </a>
        <p>プラグマは、プログラムの処理方法を指定する。 いいね<a class="link" href="#decls_System_declarations">システム宣言</a>プラグマは、ドル記号($)で始まり、その後にプラグマの名前が続きます。 次のプラグマが存在します。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>プラグマ</th><th>パラメーター</th><th>コメント</th></tr>

  <tr><td>
          <tt>$<span class="keywd">図書館</span></tt>
        </td><td>
          <tt>
            <a class="type" href="#types_string">文字列</a>
          </tt>
        </td><td>*.s7iファイル用の追加ディレクトリを指定してください。</td></tr>
  <tr><td>
          <tt>$<span class="keywd">メッセージ</span></tt>
        </td><td>
          <tt>
            <a class="type" href="#types_string">文字列</a>
          </tt>
        </td><td>解析中にメッセージを書き込みます。</td></tr>
  <tr><td>
          <tt>$<span class="keywd">info</span></tt>
        </td><td><tt><span class="keywd">オン</span></tt>または<tt><span class="keywd">オフ</span></tt></td><td>コンパイル情報のオン/オフを切り替えてください。</td></tr>
  <tr><td>
          <tt>$<span class="keywd">形跡</span></tt>
        </td><td>
          <tt>
            <a class="type" href="#types_string">文字列</a>
          </tt>
        </td><td>コンパイル時のトレース・フラグを設定します。</td></tr>
  <tr><td>
          <tt>$<span class="keywd">デック</span></tt>
        </td><td>-</td><td>宣言をトレースします。</td></tr>
  <tr><td>
          <tt>$<span class="keywd">名前</span></tt>
        </td><td><tt><span class="keywd">ユニコード</span></tt>または<tt><span class="keywd">ASCII</span></tt></td><td>Unicode(またはASCII)識別子を使用できます。</td></tr>

</table></dd></dl><p>未知のプラグマが<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***pragma.sd7(1):8:<td><a name="decls_ILLEGALPRAGMA_example">$unknownプラグマ
--------------^
</a><a class="link" href="#errors_ILLEGALPRAGMA">無効なプラグマ&quot;unknownプラグマ&quot;</a></pre><p><a name="decls_pragma_message">プラグマ<tt>メッセージ</tt>メッセージを書くのに用いられる</a>解析中に生成されます。 書くこと<tt><span class="stri">&quot;hello world&quot;</span></tt>解析時には以下を使用します。</p><pre class="indent">
$
;
<span class="keywd">メッセージ</span><span class="stri">&quot;hello world&quot;</span></pre><p><a name="decls_pragma_info">プラグマ<tt>info</tt>冗長レベルを変更するために使用できる</a>解析フェーズの。 これは<span class="link"><tt>-vn</tt></span>の<span class="link">通訳</span>with</p><pre class="indent">
$
;
<span class="keywd">info</span><span class="keywd">オン</span></pre><p>パーサはライブラリ名と現在処理されている行番号に関する情報を書き込みます。 有</p><pre class="indent">
$
;
<span class="keywd">info</span><span class="keywd">オフ</span></pre><p>そのような情報は書き込まれません。</p><p><a name="decls_pragma_trace">プラグマ<tt>形跡</tt>インタプリタのトレースを実行するために使用できる</a>プログラムの解析中はonまたはoff。 これは<span class="link"><tt>-dx</tt></span>の<span class="link">通訳</span>その<tt><a class="type" href="#types_string">文字列</a></tt>パラメータを使用して<tt><span class="keywd">形跡</span></tt>プラグマは、文字の連続を許す<tt><span class="keywd">+</span></tt><tt><span class="keywd">-</span></tt><tt><span class="keywd">a</span></tt><tt><span class="keywd">c</span></tt><tt><span class="keywd">d</span></tt><tt><span class="keywd">e</span></tt><tt><span class="keywd">h</span></tt><tt><span class="keywd">m</span></tt><tt><span class="keywd">u</span></tt><tt><span class="keywd">s</span></tt>および<tt><span class="keywd">*</span></tt>これらの文字は次の意味を持ちます。</p><ul>
    <li><b>+</b>以下のフラグをオン(デフォルト)にします。</li>
    <li><b>-</b>以下のフラグをオフにします。</li>
    <li><b>a</b>プリミティブアクションをトレースする</li>
    <li><b>c</b>Do action check</li>
    <li><b>d</b>動的呼び出しをトレースする</li>
    <li><b>e</b>トレース例外とハンドラ</li>
    <li><b>h</b>トレースヒープサイズ(&#39;a&#39;との組み合わせ)</li>
    <li><b>m</b>式のマッチングをトレースする</li>
    <li><b>u</b>トレースEX ECユーティリティ機能</li>
    <li><b>s</b>トレース信号</li>
    <li><b>*</b>すべてのフラグ</li>
</ul><p><a name="decls_pragma_names">プラグマ<tt>名前</tt>Unicodeを可能にするために使用できる</a>で<a class="link" href="#tokens_Name_identifiers">名前の識別子</a>:</p><pre class="indent">
$
;
<span class="keywd">名前</span><span class="keywd">ユニコード</span></pre><p>これにより、ドイツ語のウムラウト文字やキリル文字などの変数を使用できます。 これにより、初心者は母国語の変数名や関数名を使用することができます。</p>
          <a name="stats_file_start"></a>
        <p></p>
          <a name="stats_PREDEFINED_STATEMENTS">
        <h2>4. 定義済みの記述</h2>
          </a>
        <p>ライブラリには、いくつかの定義済みステートメントが含まれています。<a class="link" href="#stats_Assignment">譲渡</a><a class="link" href="#stats_while-statement">while文</a><a class="link" href="#stats_repeat-statement">反復文</a><a class="link" href="#stats_for-statement">for文</a><a class="link" href="#stats_if-statement">if文</a><a class="link" href="#stats_case-statement">判決理由陳述書</a>プロシージャコールなどがあります。</p>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_statement">声明</a>::=</dt><dd><a class="ebnf" href="#stats_ebnf_single_statement">単一文</a>[&#39;;&#39;[<a class="ebnf" href="#stats_ebnf_statement">声明</a>]]。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="stats_ebnf_single_statement">単一文</a>::=</dt><dd><a class="ebnf" href="#stats_ebnf_assignment_statement">代入文</a><a class="ebnf" href="#stats_ebnf_while_statement">while文</a><a class="ebnf" href="#stats_ebnf_repeat_statement">repeat_statement</a><br /><a class="ebnf" href="#stats_ebnf_for_statement">for_statement</a><a class="ebnf" href="#stats_ebnf_for_step_statement">for_step_statement</a><a class="ebnf" href="#stats_ebnf_for_each_statement">for_each_statement</a><br /><a class="ebnf" href="#stats_ebnf_for_each_key_statement">for_each_key_statement</a><a class="ebnf" href="#stats_ebnf_for_key_statement">for_key_statement</a><a class="ebnf" href="#stats_ebnf_if_statement">if_statement</a><br /><a class="ebnf" href="#stats_ebnf_case_statement">case_statement</a>procedure_call<a class="ebnf" href="#stats_ebnf_empty_statement">empty_statement</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="stats_ebnf_empty_statement">empty_statement</a>::=</dt><dd>「noop」。</dd>
</dl>
          </tt>
        </dd></dl><p>の執行<tt><span class="keywd">偵察衛星</span></tt>ステートメント(NO OPerationの略)は効果がありません。 命令文が必要な箇所があります。 そのような場所で何もする必要がない場合は<tt><span class="keywd">偵察衛星</span></tt>も使用できます。</p><p>1つのステートメントを記述できるところではどこでも、一連のステートメントを使用することもできます。 セミコロン演算子は2つの文を連結して新しい文にする。 セミコロン演算子は、文シーケンスの最後の文の後ろにも使用できます。 この場合、セミコロンは単に無視されます。</p><p><a name="stats_semicolon_operator_declaration">宣言</a>:</p><pre class="indent">
$
&lt;-50;
$
&lt;-50[1];


noop;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.().;.()<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.().;</a>は<span class="keywd">const</span><span class="keywd">proc</span>:(<a class="type" href="#types_proc">参照</a><span class="keywd">無</span>:statement1);(<a class="type" href="#types_void">参照</a><span class="keywd">無</span>:statement2)<a class="type" href="#types_void">は</a><span class="keywd"></span></pre><p></p>
          <a name="stats_Assignment">
        <h3>4.1配置</h3>
          </a>
        <p>例:</p><pre class="indent">
minimum:=maximum
2;
<span class="op">div</span></pre><p></p><dl><dt>セマンティクス:</dt><dd>代入記号の右辺の式が評価され、左辺の変数に代入されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_assignment_statement">代入文</a>::=</dt><dd>指示子&#39;:=&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a></dd>
</dl>
          </tt>
        </dd></dl><p>代入文は、標準型ごとに定義されています。</p><p>新しいユーザー定義型に割り当てる場合は、追加で定義する必要があります。</p><p><a name="stats_assignment_statement_declaration">宣言</a>:</p><pre class="indent">
$
&lt;->20;


;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.(). :=.()<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>タイプ<a class="type" href="#types_type">:dest):=(</a>参照<span class="keywd"></span>タイプ<a class="type" href="#types_type">:source)</a>はアクションです<span class="keywd"></span>&quot;TYP_CPY&quot;<span class="stri">const</span><span class="keywd">proc</span>:(<a class="type" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">proc</a>:dest):=(<a class="type" href="#types_proc">参照</a><span class="keywd">proc</span>:source)<a class="type" href="#types_proc">はアクションです</a><span class="keywd">&quot;PRC_CPY&quot;</span>const<span class="stri"></span>proc<span class="keywd">:(</span>入力する<a class="type" href="#types_proc"></a>機能<a class="keywd_no_ul" href="#params_inout_parameter"></a>aType<a class="type" href="#types_func">:dest):=(</a>参照<span class="type"></span>機能<span class="keywd"></span>aType<a class="type" href="#types_func">:source)</a>はアクションです<span class="type"></span>&quot;PRC_CPY&quot;<span class="keywd">const</span><span class="stri">proc</span>:(<span class="keywd">入力する</span><a class="type" href="#types_proc">varfunc</a><a class="keywd_no_ul" href="#params_inout_parameter">aType</a>:dest):=(<a class="type" href="#types_varfunc">参照</a><span class="type">varfunc</span><span class="keywd">aType</span>:source)<a class="type" href="#types_varfunc">はアクションです</a><span class="type">&quot;PRC_CPY&quot;</span>const<span class="keywd"></span>proc<span class="stri">:(</span>入力する<span class="keywd"></span>ACTION<a class="type" href="#types_proc">:dest):=(</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>ACTION<span class="type">:source)</span>はアクションです<a class="keywd_no_ul" href="#params_in_parameter"></a>&quot;ACT_CPY&quot;<span class="type">const</span><span class="keywd">proc</span>:(<span class="stri">入力する</span><span class="keywd">ブール</span>:dest)<a class="type" href="#types_proc">:=</a>(<a class="keywd_no_ul" href="#params_inout_parameter">で</a><a class="type" href="#types_boolean">ブール</a>:source)<a name="stats_(inout_boolean):=(in_boolean)">はアクションです</a><a class="keywd_no_ul" href="#params_in_parameter">&quot;BLN_CPY&quot;</a>const<a class="type" href="#types_boolean"></a>proc<span class="keywd">:(</span>入力する<span class="stri"></span>整数<span class="keywd">:dest)</span>:=<a class="type" href="#types_proc">(</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>整数<a class="type" href="#types_integer">:source)</a>はアクションです<a name="stats_(inout_integer):=(in_integer)"></a>&quot;INT_CPY&quot;<a class="keywd_no_ul" href="#params_in_parameter">const</a><a class="type" href="#types_integer">proc</a>:(<span class="keywd">入力する</span><span class="stri">bigInteger</span>:dest):=(<span class="keywd">で</span><a class="type" href="#types_proc">bigInteger</a>:source)<a class="keywd_no_ul" href="#params_inout_parameter">はアクションです</a><a class="type" href="#types_bigInteger">&quot;BIG_CPY&quot;</a>const<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_bigInteger">:(</a>入力する<span class="keywd"></span>char<span class="stri">:dest)</span>:=<span class="keywd">(</span>で<a class="type" href="#types_proc"></a>char<a class="keywd_no_ul" href="#params_inout_parameter">:source)</a>はアクションです<a class="type" href="#types_char"></a>&quot;CHR_CPY&quot;<a name="stats_(inout_char):=(in_char)">const</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>:(<a class="type" href="#types_char">入力する</a><span class="keywd">文字列</span>:dest)<span class="stri">:=</span>(<span class="keywd">で</span><a class="type" href="#types_proc">文字列</a>:source)<a class="keywd_no_ul" href="#params_inout_parameter">はアクションです</a><a class="type" href="#types_string">&quot;STR_CPY&quot;</a>const<a name="stats_(inout_string):=(in_string)"></a>proc<a class="keywd_no_ul" href="#params_in_parameter">:(</a>入力する<a class="type" href="#types_string"></a>bin64<span class="keywd">:dest):=(</span>で<span class="stri"></span>bin64<span class="keywd">:source)</span>はアクションです<a class="type" href="#types_proc"></a>&quot;INT_CPY&quot;<a class="keywd_no_ul" href="#params_inout_parameter">const</a><a class="type" href="#types_bin64">proc</a>:(<a class="keywd_no_ul" href="#params_in_parameter">入力する</a><a class="type" href="#types_bin64">ビン32</a>:dest):=(<span class="keywd">で</span><span class="stri">ビン32</span>:source)<span class="keywd">はアクションです</span><a class="type" href="#types_proc">&quot;INT_CPY&quot;</a>const<a class="keywd_no_ul" href="#params_inout_parameter"></a>proc<a class="type" href="#types_bin32">:(</a>入力する<a class="keywd_no_ul" href="#params_in_parameter"></a>bstring<a class="type" href="#types_bin32">:dest):=(</a>で<span class="keywd"></span>bstring<span class="stri">:source)</span>はアクションです<span class="keywd"></span>&quot;BST_CPY&quot;<a class="type" href="#types_proc">const</a><a class="keywd_no_ul" href="#params_inout_parameter">proc</a>:(<a class="type" href="#types_bstring">入力する</a><a class="keywd_no_ul" href="#params_in_parameter">参考</a>:dest):=(<a class="type" href="#types_bstring">で</a><span class="keywd">参考</span>:source)<span class="stri">はアクションです</span><span class="keywd">&quot;REF_CPY&quot;</span>const<a class="type" href="#types_proc"></a>proc<a class="keywd_no_ul" href="#params_inout_parameter">:(</a>入力する<a class="type" href="#types_reference"></a>参照リスト<a class="keywd_no_ul" href="#params_in_parameter">:dest):=(</a>で<a class="type" href="#types_reference"></a>参照リスト<span class="keywd">:source)</span>はアクションです<span class="stri"></span>&quot;RFL_CPY&quot;<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><a class="type" href="#types_ref_list">ptrType</a>:dest):=(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_ref_list">ptrType</a>:source)<span class="keywd">はアクションです</span><span class="stri">&quot;REF_CPY&quot;</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>varptr型<span class="type">:dest):=(</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>varptr型<span class="type">:source)</span>はアクションです<span class="keywd"></span>&quot;REF_CPY&quot;<span class="stri">const</span><span class="keywd">proc</span>:(<a class="type" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">arrayType</a>:dest):=(<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">arrayType</a>:source)<span class="type">はアクションです</span><span class="keywd">&quot;ARR_CPY&quot;</span>const<span class="stri"></span>proc<span class="keywd">:(</span>入力する<a class="type" href="#types_proc"></a>ビットセット<a class="keywd_no_ul" href="#params_inout_parameter">:dest):=(</a>で<span class="type"></span>ビットセット<a class="keywd_no_ul" href="#params_in_parameter">:source)</a>はアクションです<span class="type"></span>&quot;SET_CPY&quot;<span class="keywd">const</span><span class="stri">proc</span>:(<span class="keywd">入力する</span><a class="type" href="#types_proc">structType</a>:dest):=(<a class="keywd_no_ul" href="#params_inout_parameter">で</a><a class="type" href="#types_set">structType</a>:source)<a class="keywd_no_ul" href="#params_in_parameter">はアクションです</a><a class="type" href="#types_set">&quot;SCT_CPY&quot;</a>const<span class="keywd"></span>proc<span class="stri">:(</span>入力する<span class="keywd"></span>列挙型<a class="type" href="#types_proc">:dest):=(</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>列挙型<span class="type">:source)</span>はアクションです<a class="keywd_no_ul" href="#params_in_parameter"></a>&quot;ENU_CPY&quot;<span class="type">const</span><span class="keywd">proc</span>:(<span class="stri">入力する</span><span class="keywd">clib_file</span>:dest):=(<a class="type" href="#types_proc">で</a><a class="keywd_no_ul" href="#params_inout_parameter">clib_file</a>:source)<span class="type">はアクションです</span><a class="keywd_no_ul" href="#params_in_parameter">&quot;FIL_CPY&quot;</a>const<span class="type"></span>proc<span class="keywd">:(</span>入力する<span class="stri"></span>プロセス<span class="keywd">:dest):=(</span>で<a class="type" href="#types_proc"></a>プロセス<a class="keywd_no_ul" href="#params_inout_parameter">:source)</a>はアクションです<span class="type"></span>&quot;PCS_CPY&quot;<a class="keywd_no_ul" href="#params_in_parameter">const</a><span class="type">proc</span>:(<span class="keywd">入力する</span><span class="stri">interfaceType</span>:dest):=(<span class="keywd">参照</span><a class="type" href="#types_proc">interfaceType</a>:source)<a class="keywd_no_ul" href="#params_inout_parameter">はアクションです</a><a class="type" href="#types_process">&quot;ITF_CPY&quot;</a>const<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_process">:(</a>入力する<span class="keywd"></span>interfaceType<span class="stri">:dest):=(</span>参照<span class="keywd"></span>aType<a class="type" href="#types_proc">:source)</a>はアクションです<a class="keywd_no_ul" href="#params_inout_parameter"></a>&quot;ITF_CPY2&quot;<span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><a class="type" href="#types_proc"></a><a class="keywd_no_ul" href="#params_inout_parameter"></a><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="stats_Ignoring_values">
        <h3>4.2値の無視</h3>
          </a>
        <p>使用されていない式の結果は、暗黙的に破棄されません。 ライティング:</p><pre class="indent">


1+1;
writeln;

;
<span class="keywd">begin</span>関数終了<span class="keywd"></span></pre><p>結果は<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst316.sd7(5):57:

1+1;
<a class="link" href="#errors_NO_MATCH">{INT_ADD({1+1});writeln}の一致が失敗しました</a></pre><p>使用しない式の結果は、明示的に無視する必要があります。 例:</p><pre class="indent">));
<span class="keywd">無視する</span>(<span class="func">getc</span>(<span class="var">キーボード</span></pre><p>この例では、キー上で押された文字を待つ。<tt><span class="var">キーボード</span></tt>その文字を無視します。 つまり、表現の副作用はすべて発生します。 無視されるのは式の結果のみです。</p><p>使用されていない式の結果を明示的に無視することで、別のエラーの原因を取り除くことができます。</p>
          <a name="stats_while-statement">
        <h3>4.3 while文</h3>
          </a>
        <p>例:</p><pre class="indent">
最小限
2*minimum+stepValue;
decr(stepValue);

;
<span class="keywd">一方で</span>最大>最小<span class="keywd">do</span>:=<a class="op_no_ul" href="#stats_Assignment">whileを終了する</a><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>まず、間の条件<tt><span class="keywd">一方で</span></tt>および<tt><span class="keywd">do</span></tt>が評価されます。 この評価が生じる場合<tt><span class="var">FALSE</span></tt>while文が終了しました。 評価が得られた場合<tt><span class="var">TRUE</span></tt>,間の文<tt><span class="keywd">do</span></tt>および<tt><span class="keywd">終わり</span></tt>が実行され、while文全体が再度実行されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_while_statement">while文</a>::=</dt><dd>&#39;<span class="keywd">一方で</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">一方で</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>式はタイプである必要があります。<tt><a class="type" href="#types_boolean">ブール</a></tt></p><p><a name="stats_while_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:while.().do.().end.while<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:while(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>機能<a class="type" href="#types_func"></a>ブール<a class="type" href="#types_boolean">:condition)do(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_proc">:statement)end while</a>はアクションです<span class="keywd"></span>&quot;PRC_WHILE&quot;<span class="stri">const</span><span class="keywd">proc</span>:while(<a class="type" href="#types_proc">参照</a><a class="keywd_no_ul" href="#params_ref_parameter">ブール</a>:condition)do(<a class="type" href="#types_boolean">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>:statement)end while<a class="type" href="#types_proc">はアクションです</a><span class="keywd">&quot;PRC_WHILE&quot;</span><span class="stri"></span></pre><p>代替宣言:</p><pre class="indent">




文;


文;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:while(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:condition)do(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_proc">proc</a>:statement)end while<span class="keywd">is func</span>begin<span class="keywd">if</span>状態<span class="keywd">その時</span>一方で<span class="keywd">状態</span>do<span class="keywd">whileを終了する</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="stats_repeat-statement">
        <h3>4.4 repeat-statement</h3>
          </a>
        <p>例:</p><pre class="indent">
incr(minimum);
最大限
maximum-stepValue;

2*最小>最大;
<span class="keywd">繰り返す</span>:=<a class="op_no_ul" href="#stats_Assignment">まで</a><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>以下の声明<tt><span class="keywd">繰り返す</span></tt>および<tt><span class="keywd">まで</span></tt>を実行する。 その後の条件<tt><span class="keywd">まで</span></tt>が評価されます。 この評価が生じる場合<tt><span class="var">TRUE</span></tt>で、リピート文は終了です。 評価が得られた場合<tt><span class="var">FALSE</span></tt>リピート文がもう一度実行されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_repeat_statement">repeat_statement</a>::=</dt><dd>&#39;<span class="keywd">繰り返す</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a></dd>
</dl>
          </tt>
        </dd></dl><p>式はタイプである必要があります。<tt><a class="type" href="#types_boolean">ブール</a></tt></p><p><a name="stats_repeat_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.repeat.().until.()<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:repeat(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_proc">:statement)until(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>機能<a class="type" href="#types_func"></a>ブール<a class="type" href="#types_boolean">:条件)</a>はアクションです<span class="keywd"></span>&quot;PRC_REPEAT&quot;<span class="stri">const</span><span class="keywd">proc</span>:repeat(<a class="type" href="#types_proc">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>:statement)until(<a class="type" href="#types_proc">参照</a><a class="keywd_no_ul" href="#params_ref_parameter">ブール</a>:条件)<a class="type" href="#types_boolean">はアクションです</a><span class="keywd">&quot;PRC_REPEAT&quot;</span><span class="stri"></span></pre><p>代替宣言:</p><pre class="indent">


文;




文;

condition;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:repeat(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_proc">proc</a>:statement)until(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:条件)<span class="keywd">is func</span>begin<span class="keywd">if</span><span class="keywd">ない</span>状態<span class="keywd">その時</span>繰り返す<span class="keywd">まで</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="stats_for-statement">
        <h3>4.5 for文</h3>
          </a>
        <p>例:</p><pre class="indent">sumValue+:=field[index];

;
<span class="keywd">の</span>索引<span class="keywd">範囲</span>最小インデックス<span class="keywd">へ</span>最大インデックス<span class="keywd">do</span>終わる<span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd><dl><dt>が<tt><span class="keywd">へ</span></tt>シンボルを使用する場合、for-statementは次のように定義されます。</dt><dd>1つ目はその背後にある下限値と上限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">へ</span></tt>が評価されます。 次に、下限が背後にある制御変数に割り当てられます。<tt><span class="keywd">の</span></tt>制御変数の値が上限以下の場合、その背後にある文は<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数はインクリメントされ、再度上限値と比較される。 この比較-実行-インクリメントのサイクルは、制御変数が上限よりも大きくなるまで繰り返される。</dd><dt>が<tt><span class="keywd">ダウントゥ</span></tt>シンボルを使用する場合、for-statementは次のように定義されます。</dt><dd>1つ目はその背後にある上限値と下限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">ダウントゥ</span></tt>が評価されます。 次に、その背後にある制御変数に上限を設定する。<tt><span class="keywd">の</span></tt>・制御変数の値が下限以上の場合、その背後にある文<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数はデクリメントされ、再び下限値と比較される。 この比較-実行-インクリメントのサイクルは、制御変数が下限値を下回るまで繰り返される。</dd></dl>
</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_statement">for_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">へ</span>「」<span class="keywd">ダウントゥ</span>&#39;]<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;
$
->25;


:upperLimit)do
(
:ステートメント)
終わる
;

:lowerLimit)do
(
:ステートメント)
終わる
;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.().range.().to.().do.().end.for<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.for.().range.().downto.().do.().end.for</a>は<span class="keywd">const</span><span class="keywd">proc</span>:for(<a class="type" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">整数</a>:aVar)範囲(<a class="type" href="#types_integer">で</a><a class="keywd_no_ul" href="#params_in_parameter">整数</a>:lowerLimit)to(<a class="type" href="#types_integer">で</a><a class="keywd_no_ul" href="#params_in_parameter">整数</a>で<a class="type" href="#types_integer"></a>proc<a class="keywd_no_ul" href="#params_in_parameter">はアクションです</a><a class="type" href="#types_proc">&quot;PRC_FOR_TO&quot;</a>const<span class="keywd"></span>proc<span class="stri">:for(</span>入力する<span class="keywd"></span>整数<a class="type" href="#types_proc">:aVar)範囲(</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>整数<a class="type" href="#types_integer">:upperLimit)を(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>整数<a class="type" href="#types_integer">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>はアクションです<a class="type" href="#types_integer"></a>&quot;PRC_FOR_DOWNTO&quot;<a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="stri"></span></pre><p>非整数型の宣言:</p><pre class="indent">



:variable)range
(
:upperLimit)do
(




;


変わりやすい
lowerLimit;
続く
variable&lt;=upperLimit;


文;


incr(変数);


続く
;

;

;

;


:variable)range
(
:lowerLimit)do
(




;


変わりやすい
upperLimit;
続く
variable>=lowerLimit;


文;


decr(変数);


続く
;

;

;

;


;

FOR_DECLS(
);
FOR_DECLS(
);
FOR_DECLS(
);
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:FOR_DECLS(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_type">タイプ</a>:aType)<span class="keywd">is func</span>begin<span class="keywd">const</span><span class="keywd">proc</span>:for(<a class="type" href="#types_proc">入力する</a><a class="keywd_no_ul" href="#params_inout_parameter">aType</a>で<span class="type"></span>aType<a class="keywd_no_ul" href="#params_in_parameter">:lowerLimit)to(</a>で<span class="type"></span>aType<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">proc</span>:ステートメント)終了<a class="keywd_no_ul" href="#params_in_parameter">is func</a>地域の<a class="type" href="#types_proc">var</a><span class="keywd">ブール</span>:continue<span class="keywd">は</span><span class="keywd">FALSE</span>begin<a class="type" href="#types_boolean">:=</a>:=<span class="keywd">一方で</span>続く<span class="var">do</span>if<span class="keywd">variable&lt;upperLimit</span>その時<a class="op_no_ul" href="#stats_Assignment">else</a>:=<a class="op_no_ul" href="#stats_Assignment"></a>FALSE<span class="keywd">if終了</span>whileを終了する<span class="keywd">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:for(</span>入力する<span class="keywd"></span>aType<a class="op_no_ul" href="#stats_Assignment">で</a><span class="var">aType</span>:upperLimit)を(<span class="keywd">で</span><span class="keywd">aType</span>で<span class="keywd"></span>proc<span class="keywd">:ステートメント)終了</span>is func<a class="type" href="#types_proc">地域の</a>var<a class="keywd_no_ul" href="#params_inout_parameter"></a>ブール<span class="type">:continue</span>は<a class="keywd_no_ul" href="#params_in_parameter"></a>FALSE<span class="type">begin</span>:=<a class="keywd_no_ul" href="#params_in_parameter">:=</a>一方で<span class="type">続く</span>do<a class="keywd_no_ul" href="#params_in_parameter">if</a>変数>lowerLimit<a class="type" href="#types_proc">その時</a>else<span class="keywd">:=</span><span class="keywd">FALSE</span>if終了<span class="keywd">whileを終了する</span>関数終了<a class="type" href="#types_boolean">関数終了</a>char<span class="keywd">ブール</span>bigInteger<span class="var"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="var"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_char"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_bigInteger"></a></pre><p></p>
          <a name="stats_for-until-statement">
        <h3>4.6 foruntilstatement</h3>
          </a>
        <p>例:</p><pre class="indent">


incr(numColumns);

;


selectedColumn
欄;

;

;
<span class="keywd">の</span>列<span class="keywd">範囲</span>1<span class="keywd">へ</span>length(maxRow)<span class="keywd">まで</span>selectedColumn&lt;>0<span class="keywd">do</span><span class="keywd">if maxRow[column]&lt;>0</span>その時<span class="keywd">if終了</span>if<span class="keywd">numColumns=selectedNum</span>その時<span class="keywd">:=</span>if終了<span class="keywd">終わる</span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd><dl><dt>が<tt><span class="keywd">へ</span></tt>シンボルを使用する場合、for-until-statementは次のように定義されます。</dt><dd>1つ目はその背後にある下限値と上限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">へ</span></tt>が評価されます。 次に、下限が背後にある制御変数に割り当てられます。<tt><span class="keywd">の</span></tt>If the value of the control variable is less or equal to the upper limit the condition behind<tt><span class="keywd">まで</span></tt>をチェックします。 条件が<tt><span class="var">FALSE</span></tt>背後にある声明<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数はインクリメントされ、再度上限値と比較される。 この比較-チェック条件-実行-インクリメントのサイクルは、制御変数が上限より大きくなるか、条件が<tt><span class="var">TRUE</span></tt></dd><dt>が<tt><span class="keywd">ダウントゥ</span></tt>シンボルを使用する場合、for-until-statementは次のように定義されます。</dt><dd>1つ目はその背後にある上限値と下限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">ダウントゥ</span></tt>が評価されます。 次に、その背後にある制御変数に上限を設定する。<tt><span class="keywd">の</span></tt>・制御変数の値が下限以上の場合条件の背後にある<tt><span class="keywd">まで</span></tt>をチェックします。 条件が<tt><span class="var">FALSE</span></tt>背後にある声明<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数はデクリメントされ、再び下限値と比較される。 この比較-チェック条件-実行-インクリメントのサイクルは、制御変数が下限値より小さくなるか、条件が<tt><span class="var">TRUE</span></tt></dd></dl>すべての場合において、制御変数が範囲の下限値を超えることはない。 上限値</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_until_statement">for_until_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">へ</span>「」<span class="keywd">ダウントゥ</span>&#39;]<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_until_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;
$
->25;







:upperLimit)
まで(
:condition)do
(




;


変わりやすい
lowerLimit;
続く
variable&lt;=upperLimit;


文;


incr(変数);


続く
;

;

;

;


:upperLimit)
まで(
:condition)do
(




;


変わりやすい
upperLimit;
続く
variable>=lowerLimit;


文;


decr(変数);


続く
;

;

;

;


;

FOR_UNTIL_DECLS(
);
FOR_UNTIL_DECLS(
);
FOR_UNTIL_DECLS(
);
FOR_UNTIL_DECLS(
);
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.().range.().to.().until.().do.().end.for<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.for.().range.().downto.().until.().do.().end.for</a>は<span class="keywd">const</span><span class="keywd">proc</span>:FOR_UNTIL_DECLS(<a class="type" href="#types_proc">で</a><a class="keywd_no_ul" href="#params_in_parameter">タイプ</a>:aType)<a class="type" href="#types_type">is func</a>begin<span class="keywd">const</span><span class="keywd">proc</span>:for(<span class="keywd">入力する</span><a class="type" href="#types_proc">aType</a>:variable)range(<a class="keywd_no_ul" href="#params_inout_parameter">で</a><span class="type">aType</span>:lowerLimit)to(<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">aType</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>機能<span class="type"></span>ブール<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_func">proc</a>:ステートメント)終了<a class="type" href="#types_boolean">is func</a>地域の<a class="keywd_no_ul" href="#params_in_parameter">var</a><a class="type" href="#types_proc">ブール</a>:continue<span class="keywd">は</span><span class="keywd">FALSE</span>begin<span class="keywd">:=</span>:=<a class="type" href="#types_boolean">一方で</a>続く<span class="keywd">and not</span>状態<span class="var">do</span>if<span class="keywd">variable&lt;upperLimit</span>その時<a class="op_no_ul" href="#stats_Assignment">else</a>:=<a class="op_no_ul" href="#stats_Assignment"></a>FALSE<span class="keywd">if終了</span>whileを終了する<span class="op">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:for(</span>入力する<span class="keywd"></span>aType<span class="keywd">:variable)range(</span>で<a class="op_no_ul" href="#stats_Assignment"></a>aType<span class="var">:lowerLimit)を(</span>で<span class="keywd"></span>aType<span class="keywd">で</span><span class="keywd">機能</span><span class="keywd">ブール</span>で<a class="type" href="#types_proc"></a>proc<a class="keywd_no_ul" href="#params_inout_parameter">:ステートメント)終了</a>is func<span class="type">地域の</span>var<a class="keywd_no_ul" href="#params_in_parameter"></a>ブール<span class="type">:continue</span>は<a class="keywd_no_ul" href="#params_in_parameter"></a>FALSE<span class="type">begin</span>:=<a class="keywd_no_ul" href="#params_in_parameter">:=</a>一方で<a class="type" href="#types_func">続く</a>and not<a class="type" href="#types_boolean">状態</a>do<a class="keywd_no_ul" href="#params_in_parameter">if</a>変数>lowerLimit<a class="type" href="#types_proc">その時</a>else<span class="keywd">:=</span><span class="keywd">FALSE</span>if終了<span class="keywd">whileを終了する</span>関数終了<a class="type" href="#types_boolean">関数終了</a>整数<span class="keywd">char</span>ブール<span class="var">bigInteger</span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="op"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="var"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_char"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_bigInteger"></a></pre><p></p>
          <a name="stats_for-step-statement">
        <h3>4.7 for-step-statement</h3>
          </a>
        <p>例:</p><pre class="indent">write(evenNumber);

;
<span class="keywd">の</span>evenNumber<span class="keywd">範囲</span>0<span class="keywd">へ</span>10<span class="keywd">ステップ</span>2<span class="keywd">do</span>終わる<span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd><dl><dt>が<tt><span class="keywd">へ</span></tt>シンボルを使用する場合、for-statementは次のように定義されます。</dt><dd>1つ目はその背後にある下限値と上限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">へ</span></tt>が評価されます。 次に、下限が背後にある制御変数に割り当てられます。<tt><span class="keywd">の</span></tt>制御変数の値が上限以下の場合、その背後にある文は<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数は後続の値によってインクリメントされます。<tt><span class="keywd">ステップ</span></tt>そして、再度、制御変数と上限値とを比較する。 この比較-実行-インクリメントのサイクルは、制御変数が上限よりも大きくなるまで繰り返される。</dd><dt>が<tt><span class="keywd">ダウントゥ</span></tt>シンボルを使用する場合、for-statementは次のように定義されます。</dt><dd>1つ目はその背後にある上限値と下限値<tt><span class="keywd">範囲</span></tt>および<tt><span class="keywd">ダウントゥ</span></tt>が評価されます。 次に、その背後にある制御変数に上限を設定する。<tt><span class="keywd">の</span></tt>・制御変数の値が下限以上の場合、その背後にある文<tt><span class="keywd">do</span></tt>を実行する。 その後、制御変数は以下の値だけデクリメントされます。<tt><span class="keywd">ステップ</span></tt>次に、制御変数を再度下限値と比較する。 この比較-実行-インクリメントのサイクルは、制御変数が下限値を下回るまで繰り返される。</dd></dl>
</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_step_statement">for_step_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">へ</span>「」<span class="keywd">ダウントゥ</span>&#39;]<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">ステップ</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_step_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;
$
->25;









:upperLimit)
ステップ(
:incr_step)do
(



変わりやすい
lowerLimit;


文;
variable+:=incr_step;

;

;


;




:lowerLimit)
ステップ(
:decr_step)do
(



変わりやすい
upperLimit;


文;
variable-:=decr_step;

;

;


;

;

FOR_STEP_DECLS(
);
FOR_STEP_DECLS(
);
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.().range.().to.().step.().do.().end.for<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.for.().range.().downto.().step.().do.().end.for</a>は<span class="keywd">const</span><span class="keywd">proc</span>:FOR_STEP_DECLS(<a class="type" href="#types_proc">で</a><a class="keywd_no_ul" href="#params_in_parameter">タイプ</a>:aType)<a class="type" href="#types_type">is func</a>begin<span class="keywd">if</span>getobj((<span class="keywd">入力する</span><span class="keywd">aType</span>:変数)+:=(<a class="keywd_no_ul" href="#params_inout_parameter">で</a><span class="type">整数</span>:delta))&lt;>NIL<a class="keywd_no_ul" href="#params_in_parameter">その時</a>const<a class="type" href="#types_integer"></a>proc<span class="keywd">:for(</span>入力する<span class="keywd"></span>aType<a class="type" href="#types_proc">:variable)range(</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>aType<span class="type">:lowerLimit)to(</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>aType<span class="type">で</span><a class="keywd_no_ul" href="#params_in_parameter">整数</a>で<span class="type"></span>proc<a class="keywd_no_ul" href="#params_in_parameter">:ステートメント)終了</a>is func<a class="type" href="#types_integer">begin</a>:=<a class="keywd_no_ul" href="#params_in_parameter">一方で</a>variable&lt;=upperLimit<a class="type" href="#types_proc">do</a>whileを終了する<span class="keywd">関数終了</span>if終了<span class="keywd">if</span>getobj((<a class="op_no_ul" href="#stats_Assignment">入力する</a><span class="keywd">aType</span>:変数)-:=(<span class="keywd">で</span><span class="keywd">整数</span>:delta))&lt;>NIL<span class="keywd">その時</span>const<span class="keywd"></span>proc<span class="keywd">:for(</span>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>aType<span class="type">:variable)range(</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>aType<a class="type" href="#types_integer">:upperLimit)を(</a>で<span class="keywd"></span>aType<span class="keywd">で</span><a class="type" href="#types_proc">整数</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>proc<span class="type">:ステートメント)終了</span>is func<a class="keywd_no_ul" href="#params_in_parameter">begin</a>:=<span class="type">一方で</span>変数>=lowerLimit<a class="keywd_no_ul" href="#params_in_parameter">do</a>whileを終了する<span class="type">関数終了</span>if終了<a class="keywd_no_ul" href="#params_in_parameter">関数終了</a>整数<a class="type" href="#types_integer">bigInteger</a><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_bigInteger"></a></pre><p></p>
          <a name="stats_for-each-statement">
        <h3>4.8 for-each-statement</h3>
          </a>
        <p>for-each-statementは、コンテナ(<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt><tt><a class="type" href="#types_set">設定する</a></tt><tt><a class="type" href="#types_string">文字列</a></tt><tt><a class="type" href="#types_bstring">bstring</a></tt><tt><a class="type" href="#types_ref_list">参照リスト</a></tt>)。 例:</p><pre class="indent">

currObject);

;
<span class="keywd_no_ul">の</span>currObject<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">do</span>writeln<span class="func_no_ul">(</span>&quot;エレメント:&quot;<a class="stri" href="#tokens_String_literals"></a>&lt;&amp;<span class="op_no_ul">終わる</span><span class="keywd_no_ul"></span></pre><p>for-each-statementは<tt><span class="keywd">まで</span></tt>条件:</p><pre class="indent">



currObject);
見つかった
;

;

;
<span class="keywd_no_ul">の</span>currObject<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">まで</span>見つかった<span class="keywd_no_ul">do</span>if<a class="keywd_no_ul" , href="#stats_if-statement">currObject</a><span class="op">捜されたその時<a class="keywd_no_ul" , href="#stats_if-statement">writeln</a>(<span class="func_no_ul">&quot;found:&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>:=<span class="op_no_ul"></span>TRUE<a class="op_no_ul" href="#stats_Assignment">if終了</a>終わる<span class="var"></span><a class="keywd_no_ul" , href="#stats_if-statement"></a><span class="keywd_no_ul"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>最初に、後ろにある要素リスト<tt><span class="keywd">範囲</span></tt>が評価されます。 要素リストが空の場合、for-each-statementは終了します。 それ以外の場合は、要素リストの最初の要素が背後にある制御変数に割り当てられます。<tt><span class="keywd">の</span></tt>もし<tt><span class="keywd">まで</span></tt>背後の状態を分ける<tt><span class="keywd">まで</span></tt>がチェックされ<tt><span class="var">TRUE</span></tt>for-each-statementが終了しました。 for-each-statementが終了していない場合、その背後にあるステートメント<tt><span class="keywd">do</span></tt>(ループ本体)を実行します。 要素リストに次の要素がない場合は、for-each-statementは終了します。 それ以外の場合は、要素リストの次の要素が制御変数に代入されます。 この条件実行ループ本文サイクルまで可能な次の要素割当ての確認は、要素リストに次の要素がなくなるまで繰り返されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_each_statement">for_each_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>]&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_each_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;


:stri)do
(
:statement)
終わる
;


:aRefList)do
(
:statement)
終わる
;


:arr_obj)do
(
:ステートメント)
終わる




0;




変わりやすい
arr_obj[number];
文;

;

;


:aHashMap)do
(
:ステートメント)
終わる



FOR_DATA(forVar, aHashMap, statements, hashType.dataCopy);

;


:aSet)do
(
:ステートメント)
終わる




value;

;




変わりやすい
(aSet);
upperBound
(aSet);


文;


去る
;


変わりやすい
(aSet, 変数);

;

leave;

;

;


:bstri)do
(
:ステートメント)
終わる




0;




forVar
bstri[number];
文;

;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.().range.().do.().end.for<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:for(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>char<a class="type" href="#types_char">:forVar)range(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>文字列<a class="type" href="#types_string">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>はアクションです<a class="type" href="#types_proc"></a>&quot;STR_FOR&quot;<span class="keywd">const</span><span class="stri">proc</span>:for(<span class="keywd">入力する</span><a class="type" href="#types_proc">参考</a>:variable)range(<a class="keywd_no_ul" href="#params_inout_parameter">で</a><a class="type" href="#types_reference">参照リスト</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_ref_list">はアクションです</a><a class="keywd_no_ul" href="#params_in_parameter">&quot;RFL_FOR&quot;</a>const<a class="type" href="#types_proc"></a>proc<span class="keywd">:for(</span>入力する<span class="stri"></span>baseType<span class="keywd">:variable)range(</span>で<a class="type" href="#types_proc"></a>arrayType<a class="keywd_no_ul" href="#params_inout_parameter">で</a><span class="type">proc</span>is func<a class="keywd_no_ul" href="#params_in_parameter">地域の</a>var<span class="type"></span>整数<a class="keywd_no_ul" href="#params_in_parameter">:数</a>は<a class="type" href="#types_proc">begin</a>の<span class="keywd">数</span>範囲<span class="keywd">minIdx(arr_obj)</span>へ<span class="keywd">maxIdx(arr_obj)</span>do<a class="type" href="#types_integer">:=</a>終わる<span class="keywd">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:for(</span>入力する<span class="keywd"></span>baseType<span class="keywd">:forVar)range(</span>で<span class="keywd"></span>hashType<a class="op_no_ul" href="#stats_Assignment">で</a><span class="keywd">proc</span>is func<span class="keywd">begin</span>関数終了<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:for(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><span class="type">baseType</span>:variable)range(<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">setType</span>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">baseType</span>:upperBound<span class="keywd">は</span><span class="keywd">baseType</span>var<a class="type" href="#types_proc"></a>ブール<a class="keywd_no_ul" href="#params_inout_parameter">:leave</a>は<span class="type"></span>FALSE<a class="keywd_no_ul" href="#params_in_parameter">begin</a>if<span class="type">aSet&lt;>setType.EMPTY_SET</span>その時<a class="keywd_no_ul" href="#params_in_parameter">:=</a><a class="type" href="#types_proc">分</a>:=<span class="keywd"></span>最大<span class="keywd">繰り返す</span>if<span class="keywd">variable=upperBound</span>その時<span class="type">:=</span><span class="keywd">TRUE</span>else<span class="type">:=</span><span class="keywd">次の</span>if終了<a class="type" href="#types_boolean">まで</a>if終了<span class="keywd">関数終了</span>const<span class="var"></span>proc<span class="keywd">:for(</span>入力する<span class="keywd"></span>char<span class="keywd">:forVar)range(</span>で<a class="op_no_ul" href="#stats_Assignment"></a>bstring<span class="func_no_ul">で</span><a class="op_no_ul" href="#stats_Assignment">proc</a>is func<span class="func_no_ul">地域の</span>var<span class="keywd"></span>整数<span class="keywd">:数</span>は<span class="keywd">begin</span>の<a class="op_no_ul" href="#stats_Assignment">数</a>範囲<span class="var">1</span>へ<span class="keywd">長さ(bstri)</span>do<a class="op_no_ul" href="#stats_Assignment">:=</a>終わる<span class="func_no_ul">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_proc"></a><a class="keywd_no_ul" href="#params_inout_parameter"></a><a class="type" href="#types_char"></a><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_bstring"></a><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="stats_for-each-key-statement">
        <h3>4.9 for-each-key-statement</h3>
          </a>
        <p>for-each-key-statementは、コンテナ(<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt><tt><a class="type" href="#types_string">文字列</a></tt>)。 例:</p><pre class="indent">

currObject);

;
<span class="keywd_no_ul">の</span>currObject<span class="keywd_no_ul">キー</span>currIndex<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">do</span>writeln<span class="func_no_ul">(</span>&quot;key:&quot;<a class="stri" href="#tokens_String_literals"></a>&lt;&amp;<span class="op_no_ul">currIndex</span>&lt;&amp;<span class="op_no_ul"></span>&quot;、エレメント:&quot;<a class="stri" href="#tokens_String_literals"></a>&lt;&amp;<span class="op_no_ul">終わる</span><span class="keywd_no_ul"></span></pre><p>for-each-key-statementは<tt><span class="keywd">まで</span></tt>条件:</p><pre class="indent">



currObject);
見つかった
;

;

;
<span class="keywd_no_ul">の</span>currObject<span class="keywd_no_ul">キー</span>currIndex<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">まで</span>見つかった<span class="keywd_no_ul">do</span>if<a class="keywd_no_ul" , href="#stats_if-statement">currObject</a><span class="op">捜されたその時<a class="keywd_no_ul" , href="#stats_if-statement">writeln</a>(<span class="func_no_ul">&quot;found key:&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>currIndex<span class="op_no_ul">&lt;&amp;</span><span class="op_no_ul">&quot;、エレメント:&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>:=<span class="op_no_ul"></span>TRUE<a class="op_no_ul" href="#stats_Assignment">if終了</a>終わる<span class="var"></span><a class="keywd_no_ul" , href="#stats_if-statement"></a><span class="keywd_no_ul"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>最初に、後ろにある要素リスト<tt><span class="keywd">範囲</span></tt>が評価されます。 要素リストが空であれば、キーごとのステートメントは終了します。 それ以外の場合は、要素リストの最初の要素が背後にある制御変数に割り当てられます。<tt><span class="keywd">の</span></tt>第1要素のインデックス(キー)がキーワードの後ろにあるキー制御変数に割り当てられます。<tt><span class="keywd">キー</span></tt>もし<tt><span class="keywd">まで</span></tt>背後の状態を分ける<tt><span class="keywd">まで</span></tt>がチェックされ<tt><span class="var">TRUE</span></tt>for-each-statementが終了しました。 for-each-statementが終了していない場合、その背後にあるステートメント<tt><span class="keywd">do</span></tt>(ループ本体)を実行します。 要素リストに次の要素がない場合は、for-each-key-statementは終了します。 そうでない場合は、要素リストの次の要素が制御変数に代入され、次の要素のインデックスがキー制御変数に代入されます。 この次のelement-assignインデックスとelement-checkのチェックは、condition-execute loop body-cycleが要素リストに次の要素がなくなるまで繰り返されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_each_key_statement">for_each_key_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">キー</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>]&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_each_key_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;


:stri)do
(
:statement)
終わる
;


arrayType:arr)do
(
:statement)
終わる





forVar
arr[keyVar];
文;

;

;


:aHashMap)do
(
:ステートメント)
終わる



FOR_DATA_KEY(forVar, keyVar, aHashMap, statements, hashType.dataCopy, hashType.keyCopy);

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.().key.().range.().do.().end.for<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:for(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>char<a class="type" href="#types_char">:forVar)キー(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>整数<a class="type" href="#types_integer">:keyVar)range(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>文字列<a class="type" href="#types_string">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>はアクションです<a class="type" href="#types_proc"></a>&quot;STR_FOR_VAR_KEY&quot;<span class="keywd">const</span><span class="stri">proc</span>:for(<span class="keywd">入力する</span><a class="type" href="#types_proc">baseType</a>:forVar)キー(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><span class="type">整数</span>:keyVar)range(<a class="keywd_no_ul" href="#params_inout_parameter">で</a>で<a class="type" href="#types_integer"></a>proc<a class="keywd_no_ul" href="#params_in_parameter">is func</a>begin<a class="keywd_no_ul" href="#params_in_parameter">の</a>キー変数<a class="type" href="#types_proc">範囲</a>minIdx(arr)<span class="keywd">へ</span>maxIdx(arr)<span class="keywd">do</span>:=<span class="keywd">終わる</span>関数終了<span class="keywd">const</span><span class="keywd">proc</span>:for(<span class="keywd">入力する</span><a class="op_no_ul" href="#stats_Assignment">baseType</a>:forVar)キー(<span class="keywd">入力する</span><span class="keywd">キータイプ</span>:keyVar)range(<span class="keywd">で</span><a class="type" href="#types_proc">hashType</a>で<a class="keywd_no_ul" href="#params_inout_parameter"></a>proc<span class="type">is func</span>begin<a class="keywd_no_ul" href="#params_inout_parameter">関数終了</a><span class="type"></span><a class="keywd_no_ul" href="#params_in_parameter"></a><span class="type"></span><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="stats_for-key-statement">
        <h3>4.10 for-key-statement</h3>
          </a>
        <p>for-key-statementは、コンテナ(<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt><tt><a class="type" href="#types_string">文字列</a></tt>)。 例:</p><pre class="indent">

currIndex);

;
<span class="keywd_no_ul">の</span><span class="keywd_no_ul">キー</span>currIndex<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">do</span>writeln<span class="func_no_ul">(</span>&quot;key:&quot;<a class="stri" href="#tokens_String_literals"></a>&lt;&amp;<span class="op_no_ul">終わる</span><span class="keywd_no_ul"></span></pre><p>for-key-statementは<tt><span class="keywd">まで</span></tt>条件:</p><pre class="indent">



currIndex);
見つかった
;

;

;
<span class="keywd_no_ul">の</span><span class="keywd_no_ul">キー</span>currIndex<span class="keywd_no_ul">範囲</span>要素リスト<span class="keywd_no_ul">まで</span>見つかった<span class="keywd_no_ul">do</span>if<a class="keywd_no_ul" , href="#stats_if-statement">element_list[currIndex]</a><span class="op">捜されたその時<a class="keywd_no_ul" , href="#stats_if-statement">writeln</a>(<span class="func_no_ul">&quot;found key:&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>:=<span class="op_no_ul"></span>TRUE<a class="op_no_ul" href="#stats_Assignment">if終了</a>終わる<span class="var"></span><a class="keywd_no_ul" , href="#stats_if-statement"></a><span class="keywd_no_ul"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>最初に、後ろにある要素リスト<tt><span class="keywd">範囲</span></tt>が評価されます。 要素リストが空の場合、キー用ステートメントは終了します。 それ以外の場合は、第1要素のインデックス(キー)がキーワードの背後にあるキー制御変数に割り当てられます。<tt><span class="keywd">キー</span></tt>もし<tt><span class="keywd">まで</span></tt>背後の状態を分ける<tt><span class="keywd">まで</span></tt>がチェックされ<tt><span class="var">TRUE</span></tt>for-each-statementが終了しました。 for-each-statementが終了していない場合、その背後にあるステートメント<tt><span class="keywd">do</span></tt>(ループ本体)を実行します。 要素リストに次の要素がない場合は、キー用ステートメントは終了します。 それ以外の場合は、次の要素のインデックスがキー制御変数に割り当てられます。 この条件実行ループ本文サイクルまで可能な次の要素割当て索引検査は、要素リストに次の要素がなくなるまで繰り返されます。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_for_key_statement">for_key_statement</a>::=</dt><dd>&#39;<span class="keywd">の</span>「」<span class="keywd">キー</span>&#39;<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>&#39;<span class="keywd">範囲</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>[&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>]&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">の</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_for_key_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;


:stri)do
(
:statement)
終わる
;


arrayType:arr)do
(
:statement)
終わる





文;

;

;


:aHashMap)do
(
:ステートメント)
終わる



FOR_KEY(keyVar, aHashMap, statements, hashType.keyCopy);

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.for.key.().range.().do.().end.for<span class="keywd">は</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:キー(</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>整数<a class="type" href="#types_integer">:keyVar)range(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>文字列<a class="type" href="#types_string">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>はアクションです<a class="type" href="#types_proc"></a>&quot;STR_FOR_KEY&quot;<span class="keywd">const</span><span class="stri">proc</span>:キー(<span class="keywd">入力する</span><a class="type" href="#types_proc">整数</a>:keyVar)range(<a class="keywd_no_ul" href="#params_inout_parameter">で</a>で<a class="type" href="#types_integer"></a>proc<a class="keywd_no_ul" href="#params_in_parameter">is func</a>begin<a class="keywd_no_ul" href="#params_in_parameter">の</a>キー変数<a class="type" href="#types_proc">範囲</a>minIdx(arr)<span class="keywd">へ</span>maxIdx(arr)<span class="keywd">do</span>終わる<span class="keywd">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:キー(</span>入力する<span class="keywd"></span>キータイプ<span class="keywd">:keyVar)range(</span>で<span class="keywd"></span>hashType<span class="keywd">で</span><a class="type" href="#types_proc">proc</a>is func<a class="keywd_no_ul" href="#params_inout_parameter">begin</a>関数終了<span class="type"></span><a class="keywd_no_ul" href="#params_in_parameter"></a><span class="type"></span><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="stats_if-statement">
        <h3>4.11 if文</h3>
          </a>
        <p>例:</p><pre class="indent">
要因
sumValue;
sumValue
最低;


要因
-sumValue;
sumValue
maximum;


要因
0;

;
<span class="keywd">if</span>sumValue&lt;minimum<span class="keywd">その時</span>:=<a class="op_no_ul" href="#stats_Assignment">:=</a>elsif<a class="op_no_ul" href="#stats_Assignment">sumValue>maximum</a>その時<span class="keywd">:=</span>:=<span class="keywd">else</span>:=<a class="op_no_ul" href="#stats_Assignment">if終了</a><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>前の式は<tt><span class="keywd">その時</span></tt>は、で評価されます。 このような式が次のように評価される場合<tt><span class="var">TRUE</span></tt>背後にある声明<tt><span class="keywd">その時</span></tt>が実行されif文が終了します。 If all expressions before<tt><span class="keywd">その時</span></tt>評価する<tt><span class="var">FALSE</span></tt>else-partが存在する後ろにあるステートメント<tt><span class="keywd">else</span></tt>が実行されif文が終了します。 If all expressions before<tt><span class="keywd">その時</span></tt>評価する<tt><span class="var">FALSE</span></tt>else-partが存在しない場合、if文は終了します。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_if_statement">if_statement</a>::=</dt><dd>&#39;<span class="keywd">if</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />{&#39;<span class="keywd">elsif</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>}<br />[&#39;<span class="keywd">else</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>]<br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">if</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>式はタイプである必要があります。<tt><a class="type" href="#types_boolean">ブール</a></tt></p><p><a name="stats_if_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;
$
->25;

$
&lt;-60;
$
&lt;-60;
$
&lt;-60;


newtype;

;

enumlit;

;

;


:condition)then
(
:ステートメント)
if終了
;


:condition)then
(
:ステートメント)
(
:elsifPart)
if終了
;


:condition)then
(
;


:condition)then
(
:ステートメント)
(
;


:else
(
ELSIF_EMPTY;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.if.().then.().end.if<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.if.().then.().().end.if</a>は<span class="keywd">構文</span><span class="keywd">expr</span>:.elsif.().then.()<a class="type" href="#types_expr">は</a>構文<span class="keywd"></span>expr<span class="keywd">:.elsif.().then.().()</span>は<a class="type" href="#types_expr">構文</a><span class="keywd">expr</span>:.else.()<span class="keywd">は</span>const<a class="type" href="#types_expr"></a>タイプ<span class="keywd">:ELSIF_RESULT</span>は<span class="keywd">const</span><a class="type" href="#types_type">proc</a>:(<span class="keywd">参照</span><span class="keywd">ELSIF_RESULT</span>:dest)::=enumlit<a class="type" href="#types_proc">はアクションです</a><span class="keywd">&quot;ENU_GENLIT&quot;</span>const<span class="type"></span>ELSIF_RESULT<span class="keywd">:ELSIF_EMPTY</span>は<span class="stri">const</span><span class="keywd">タイプ</span>:ELSIF_PROC<span class="type">は</span>機能<span class="keywd">ELSIF_RESULT</span>const<span class="keywd"></span>proc<a class="type" href="#types_type">:(</a>参照<span class="keywd"></span>ELSIF_PROC<span class="type">:dest)::=(</span>参照<span class="keywd"></span>ELSIF_RESULT<a class="type" href="#types_proc">:source)</a>はアクションです<span class="keywd"></span>&quot;ENU_CREATE&quot;<span class="type">const</span><span class="keywd">proc</span>:if(<span class="type">で</span><span class="keywd">ブール</span>で<span class="stri"></span>proc<span class="keywd">はアクションです</span><a class="type" href="#types_proc">&quot;PRC_IF&quot;</a>const<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_boolean">:if(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>ブール<a class="type" href="#types_proc">で</a><span class="keywd">proc</span>で<span class="stri"></span>ELSIF_PROC<span class="keywd">はアクションです</span><a class="type" href="#types_proc">&quot;PRC_IF_ELSIF&quot;</a>const<a class="keywd_no_ul" href="#params_in_parameter"></a>ELSIF_PROC<a class="type" href="#types_boolean">:elsif(</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>ブール<a class="type" href="#types_proc">で</a><a class="keywd_no_ul" href="#params_in_parameter">proc</a>:ステートメント)<span class="type">はアクションです</span><span class="keywd">&quot;PRC_IF&quot;</span>const<span class="stri"></span>ELSIF_PROC<span class="keywd">:elsif(</span>で<span class="type"></span>ブール<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_boolean">proc</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>ELSIF_PROC<a class="type" href="#types_proc">:elsifPart)</a>はアクションです<span class="keywd"></span>&quot;PRC_IF_ELSIF&quot;<span class="stri">const</span><span class="keywd">ELSIF_PROC</span>で<span class="type"></span>無<a class="keywd_no_ul" href="#params_in_parameter">:elsePart)</a>は<a class="type" href="#types_boolean"></a><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_proc"></a><a class="keywd_no_ul" href="#params_in_parameter"></a><span class="type"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="type"></span><a class="keywd_no_ul" href="#params_in_parameter"></a><a class="type" href="#types_void"></a><span class="keywd"></span></pre><p></p>
          <a name="stats_case-statement">
        <h3>4.12 case-statement(ケースステートメント)</h3>
          </a>
        <p>例:</p><pre class="indent">

}:
characterClass
書簡

}:
characterClass
DIGIT;

&#39;/&#39;,
&#39;:&#39;
&#39;&#39;&#39;,
「」
}:
characterClass
SPECIAL;

}:
characterClass
PAREN;


characterClass
アポストロフィ;


characterClass
引用;

:
characterClass
ILLEGAL;

;
<span class="keywd">ケース</span>currChar<span class="keywd">の</span>いつ<span class="keywd">{</span>「A」<span class="stri"></span>「Z」<span class="stri">}{</span>&#39;a&#39;<span class="stri"></span>&#39;z&#39;<span class="stri">:=</span>いつ<a class="op_no_ul" href="#stats_Assignment">{</a>&#39;0&#39;<span class="keywd"></span>&#39;9&#39;<span class="stri">:=</span>いつ<span class="stri">{</span>&#39;!&#39;<a class="op_no_ul" href="#stats_Assignment"></a>&#39;$&#39;<span class="keywd"></span>「%」<span class="stri"></span>&#39;&amp;&#39;<span class="stri"></span>&#39;*&#39;<span class="stri"></span>&#39;+&#39;<span class="stri"></span>&#39;,&#39;<span class="stri"></span>&#39;-&#39;<span class="stri"></span>&#39;.&#39;<span class="stri"></span><span class="stri">&#39;;&#39;</span><span class="stri">&#39;&lt;&#39;</span><span class="stri">&#39;=&#39;</span><span class="stri">&#39;>&#39;</span><span class="stri">&#39;?&#39;</span><span class="stri">「@」</span><span class="stri">&#39;\&#39;</span><span class="stri">「^」</span><span class="stri"></span>&#39;~&#39;<span class="stri">:=</span>いつ<span class="stri">{</span>&#39;(&#39;<span class="stri"></span>&#39;)&#39;<span class="stri"></span>&#39;[&#39;<a class="op_no_ul" href="#stats_Assignment"></a>&#39;]&#39;<span class="keywd"></span>&#39;{&#39;<span class="stri"></span>&#39;}&#39;<span class="stri">:=</span>いつ<span class="stri">{</span>&quot;&quot;&quot;<span class="stri">}:</span>#&#39;\&quot;&#39;も可<span class="stri">:=</span>いつ<span class="stri">{</span>「」<a class="op_no_ul" href="#stats_Assignment">}:</a>#&#39;\&#39;も可<span class="keywd">:=</span>そうでなければ<span class="stri">:=</span>格を終わらせる<span class="comment"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><span class="stri"></span><span class="comment"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span><a class="op_no_ul" href="#stats_Assignment"></a><span class="keywd"></span></pre><p>case文は文字列に対しても機能します。</p><pre class="indent">

};

};

};

};

}:
alternateEndTags
};

;
<span class="keywd">ケース</span>elementName<span class="keywd">の</span>いつ<span class="keywd">{</span>「li」<span class="stri">}:alternateEndTags</span>:=<a class="op_no_ul" href="#stats_Assignment">{</a>&quot;&lt;li&quot;<span class="stri">いつ</span>{<span class="keywd">&quot;dt&quot;</span><span class="stri">&quot;dd&quot;</span>}:alternateEndTags<span class="stri">:=</span>{<a class="op_no_ul" href="#stats_Assignment">&quot;&lt;dt&quot;</a><span class="stri">&quot;&lt;dd&quot;</span>いつ<span class="stri">{</span>&quot;td&quot;<span class="keywd"></span>「th」<span class="stri">}:alternateEndTags</span>:=<span class="stri">{</span>&quot;&lt;td&quot;<a class="op_no_ul" href="#stats_Assignment"></a>&quot;&lt;th&quot;<span class="stri"></span>&quot;&lt;tr&quot;<span class="stri"></span>&quot;&lt;thead&quot;<span class="stri"></span>&quot;&lt;tbody&quot;<span class="stri"></span>&quot;&lt;tfoot&quot;<span class="stri">いつ</span>{<span class="stri">「tr」</span>}:alternateEndTags<span class="keywd">:=</span>{<span class="stri">&quot;&lt;tr&quot;</span><a class="op_no_ul" href="#stats_Assignment">&quot;&lt;thead&quot;</a><span class="stri">&quot;&lt;tbody&quot;</span><span class="stri">&quot;&lt;tfoot&quot;</span>いつ<span class="stri">{</span>「thead」<span class="stri"></span>&quot;tbody&quot;<span class="keywd"></span>「tfoot」<span class="stri">:=</span>{<span class="stri">&quot;&lt;thead&quot;</span><span class="stri">&quot;&lt;tbody&quot;</span><a class="op_no_ul" href="#stats_Assignment">&quot;&lt;tfoot&quot;</a>格を終わらせる<span class="stri"></span><span class="stri"></span><span class="stri"></span><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>間の式は<tt><span class="keywd">ケース</span></tt>および<tt><span class="keywd">の</span></tt>が評価されます。 結果の値が<tt><span class="keywd">いつ</span></tt>対応するコロンの背後にある文が実行され、case文が終了します。 値が後ろのセットの要素でない場合<tt><span class="keywd">いつ</span></tt>および<tt><span class="keywd">そうでなければ</span></tt>のコロンの後に文が存在します。<tt><span class="keywd">そうでなければ</span></tt>が実行され、case文が終了する。 値が後ろのセットの要素でない場合<tt><span class="keywd">いつ</span></tt>およびno<tt><span class="keywd">そうでなければ</span></tt>部分が存在すれば、case文は終了します。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="stats_ebnf_case_statement">case_statement</a>::=</dt><dd>&#39;<span class="keywd">ケース</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">の</span>&#39;<br />{&#39;<span class="keywd">いつ</span>&#39;<a class="ebnf" href="#stats_ebnf_set_expression">セット式</a>&#39;:&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>}<br />[&#39;<span class="keywd">そうでなければ</span>&#39;&#39;:&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>]<br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">ケース</span>&#39;.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="stats_ebnf_set_expression">セット式</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_expression">表現</a></dd>
</dl>
          </tt>
        </dd></dl><p><a name="stats_case_statement_declaration">宣言</a>:</p><pre class="indent">
$
->25;
$
->25;
$
->25;
$
->25;

$
&lt;-60;
$
&lt;-60;






;

;

;



newtype;

);

;

noop;

:decisionValue)の
そうでない場合:(
:ステートメント)
格を終わらせる



文;

;


getobj(ord(


:decisionValue)の
(
:whenPart)
格を終わらせる
;

:decisionValue)の
(
:whenPart)
そうでない場合:(
:ステートメント)
格を終わらせる
;



:decisionValue)の
(
:whenPart)
格を終わらせる
;

:decisionValue)の
(
:whenPart)
そうでない場合:(
:ステートメント)
格を終わらせる
;

;

;

)が列挙型で

;

);

:statement)
(
);

;

CASE_DECLS(
);
CASE_DECLS(
);
CASE_DECLS(
);
CASE_DECLS(
);
CASE_DECLS(
);
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.case.()of.().end.case<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.case.().of.().otherwise. :.().end.case</a>は<span class="keywd">構文</span><span class="keywd">expr</span>:.case.().of.otherwise. :.().end.case<a class="type" href="#types_expr">は</a>構文<span class="keywd"></span>expr<span class="keywd">:.case.().of.end.case</span>は<a class="type" href="#types_expr">構文</a><span class="keywd">expr</span>:.when.().:.().()<span class="keywd">は</span>構文<a class="type" href="#types_expr"></a>expr<span class="keywd">:.when.().:.()</span>は<span class="keywd">const</span><a class="type" href="#types_expr">proc</a>:CASE_DECLS(<span class="keywd">で</span><span class="keywd">タイプ</span>:aType)<a class="type" href="#types_proc">is func</a>地域の<a class="keywd_no_ul" href="#params_in_parameter">var</a><a class="type" href="#types_type">タイプ</a>:WHEN_RESULT<span class="keywd">は</span><span class="keywd">無</span>var<span class="keywd"></span>タイプ<a class="type" href="#types_type">:WHEN_PROC</a>は<span class="keywd"></span>無<a class="type" href="#types_void">var</a><span class="keywd">タイプ</span>:SELECTOR_TYPE<a class="type" href="#types_type">は</a><span class="keywd">無</span>begin<a class="type" href="#types_void">WHEN_RESULT</a><span class="keywd">:=</span>WHEN_PROC<a class="type" href="#types_type"></a>:=<span class="keywd">(</span>機能<a class="type" href="#types_void"></a>WHEN_RESULT<span class="keywd">セレクタタイプ</span><span class="type">:=</span><a class="op_no_ul" href="#stats_Assignment">設定する</a><span class="type">の</span><a class="op_no_ul" href="#stats_Assignment">aType</a>const<a class="type" href="#types_func"></a>proc<span class="type">:case(</span>参照<span class="type"></span>aType<a class="op_no_ul" href="#stats_Assignment">:decisionValue)</a>は<a class="type" href="#types_set">const</a><a class="type" href="#types_set">proc</a>:case(<span class="type">参照</span><span class="keywd">aType</span>参照<a class="type" href="#types_proc"></a>proc<span class="keywd">is func</span>begin<span class="type">関数終了</span>if<span class="keywd">getobj(ord(</span>参照<span class="keywd"></span>aType<a class="type" href="#types_proc">:decisionValue))&lt;>NIL</a>および<span class="keywd">参照</span><span class="type">aType</span>:decisionValue, mayRaiseRangeError))=NIL<span class="keywd">その時</span>const<a class="type" href="#types_proc"></a>proc<span class="keywd">:case(</span>参照<span class="keywd"></span>aType<span class="keywd">参照</span><span class="keywd">WHEN_PROC</span>はアクションです<span class="keywd"></span>&quot;PRC_CASE&quot;<span class="type">const</span><span class="op">proc</span>:case(<span class="keywd">参照</span><span class="type">aType</span>参照<span class="keywd"></span>WHEN_PROC<span class="keywd">参照</span><a class="type" href="#types_proc">proc</a>はアクションです<span class="keywd"></span>&quot;PRC_CASE_DEF&quot;<span class="type">else</span>const<span class="keywd"></span>proc<span class="type">:case(</span>参照<span class="keywd"></span>aType<span class="stri">参照</span><span class="keywd">WHEN_PROC</span>はアクションです<a class="type" href="#types_proc"></a>&quot;PRC_CASE_HASHSET&quot;<span class="keywd">const</span><span class="type">proc</span>:case(<span class="keywd">参照</span><span class="type">aType</span>参照<span class="keywd"></span>WHEN_PROC<a class="type" href="#types_proc">参照</a><span class="keywd">proc</span>はアクションです<span class="stri"></span>&quot;PRC_CASE_HASHSET_DEF&quot;<span class="keywd">if終了</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:(</a>参照<span class="keywd"></span>WHEN_RESULT<span class="type">:dest)::=enumlit</span>はアクションです<span class="keywd"></span>&quot;ENU_GENLIT&quot;<span class="type">const</span><span class="keywd">WHEN_RESULT</span>:WHEN_EMPTY(<span class="stri">attr</span><span class="keywd">aType</span>const<a class="type" href="#types_proc"></a>proc<span class="keywd">:(</span>参照<span class="type"></span>WHEN_PROC<span class="keywd">:dest)::=(</span>参照<span class="type"></span>WHEN_RESULT<span class="keywd">:source)</span>はアクションです<a class="type" href="#types_proc"></a>&quot;ENU_CREATE&quot;<span class="keywd">const</span><span class="stri">WHEN_PROC</span>:いつ(<span class="keywd">参照</span><span class="keywd">セレクタタイプ</span>:whenSet):(<a class="type" href="#types_proc">参照</a><span class="keywd">proc</span>:statement)<span class="type">は</span>WHEN_EMPTY(<span class="keywd">aType</span>const<span class="stri"></span>WHEN_PROC<span class="keywd">:いつ(</span>参照<span class="type"></span>セレクタタイプ<a class="keywd_no_ul" href="#params_attr_parameter">:whenSet):(</a>参照<span class="type"></span>proc<span class="keywd">参照</span><a class="type" href="#types_proc">WHEN_PROC</a>:whenPart)<span class="keywd">は</span>WHEN_EMPTY(<span class="type">aType</span>関数終了<span class="keywd">整数</span>char<span class="type">ブール</span>文字列<span class="keywd">bigInteger</span><span class="stri"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_char"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_string"></a><a class="type" href="#types_bigInteger"></a></pre><p></p>
          <a name="types_file_start"></a>
        <p></p>
          <a name="types_PREDEFINED_TYPES">
        <h2>5. 定義済みタイプ</h2>
          </a>
        <p>次の小章では、標準ライブラリの定義済みタイプを紹介します。 特に記述がない限り、演算子はパラメータ型および結果型としてのサブチャプタで説明される型を持ちます。 リレーションには、サブチャプタで説明されているパラメータタイプとタイプの結果もあります。<tt><a class="type" href="#types_boolean">ブール</a></tt>・説明の中で<tt><b>⇒</b></tt>は、等価式を示すために使用されます。</p>
          <a name="types_boolean">
        <h3>5.1論理</h3>
          </a>
        <p>型式<tt><span class="type">ブール</span></tt>2つの真理値から成る<tt><span class="var">TRUE</span></tt>および<tt><span class="var">FALSE</span></tt>その<tt><span class="type">ブール</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">boolean.s7i</span>&quot;</span></p><pre class="tt">
定数:

)

)

)
前置演算子:

否定
(


)
インフィックス演算子:

論理積
(

A
else)

包含的論理和
(

A
else)
A
C三項演算子条件?thenValue:elseValue
(
a

b)


(引数Aのタイプ:




)


(引数Aのタイプ:








)
リレーション:


(A関係B

ord(A)リレーションord(B))
機能:

(A)序数
(結果の種類:


0

1)

(A)序数
(結果の種類:


0

1)

(ア)承継人
(


)

①前任者
(
)

)

ブール値に
(引数Aのタイプ:








)


(引数Aのタイプ:










)


(結果の種類:




)

(A)ブール値をブールリテラルに変換する。
(結果の種類:




)

(A, B)[A, B]の範囲のランダムな値
ランダム値は一様分布です。
(
(A, B)は、以下のようなランダムな値を返す。
A&lt;=
(A, B)≦Bが成立する。

A

)

(A, B)比較関数
(結果の種類:


-1

0

1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)インクリメント
(
A:=succ(A))

(A)減分
(
A:=pred(A))

(A)値を無視(Ignore value)する
<span class="type">ブール</span><span class="var">価値</span>既定値<span class="type">ブール</span>(<span class="var">FALSE</span>ブール<span class="type"></span>1番目<span class="var">最小値</span>ブール<span class="type">(</span>FALSE<span class="var">ブール</span><span class="type">最後の</span>の最大値<span class="var">ブール</span>(<span class="type">TRUE</span>ない<span class="var">ない</span><span class="op">TRUE</span><span class="op">⇒</span><span class="var">FALSE</span>ない<b></b>FALSE<span class="var"></span>⇒<span class="op"></span>TRUE<span class="var">および</span>TRUE<b></b>および<span class="var"></span>TRUE<span class="op"></span>⇒<span class="var"></span>TRUE<span class="op">および</span>B<span class="var">⇒</span><b>FALSE</b>または<span class="var">FALSE</span><span class="op">または</span><b>FALSE</b><span class="var">⇒</span><span class="op">FALSE</span>または<span class="var">B</span>⇒<span class="op"></span>TRUE<span class="var"></span>B<b>:</b>TRUE<span class="var">a:b</span>⇒<span class="op">FALSE</span>a:b<b>⇒</b>ブール<span class="var"></span>conv<span class="op">A変換</span>整数<span class="op">へ</span>ブール<span class="var">整数</span>ブール<b></b>conv<span class="var">0</span>⇒<b></b>FALSE<span class="type">ブール</span><span class="op">conv</span>1<a class="type" href="#types_integer">⇒</a><span class="type">TRUE</span>ブール<a class="type" href="#types_integer"></a>解析する<span class="type">A変換</span>文字列<span class="op">へ</span>ブール<b>文字列</b>ブール<span class="var"></span>解析する<span class="type"></span>「間違い」<span class="op"></span>⇒<b></b>FALSE<span class="var">ブール</span><span class="type">解析する</span><span class="op">&quot;TRUE&quot;</span><a class="type" href="#types_string">⇒</a><span class="type">TRUE</span>ブール<a class="type" href="#types_string"></a>解析する<span class="type"></span>&quot;TRUE&quot;<span class="op"></span>⇒<span class="stri">例外</span>範囲エラー<b>ブール</b><span class="var">解析する</span><span class="type">「ASDF」</span><span class="op">⇒</span>例外<span class="stri">範囲エラー</span>=<b></b>&lt;><span class="var"></span>&lt;<span class="type"></span>&lt;=<span class="op"></span>><span class="stri"></span>>=<b>⇒</b>ord<a class="exception" href="#errors_RANGE_ERROR">整数</a>ord<span class="type">(</span>FALSE<span class="op">)</span>⇒<span class="stri">ord</span>(<b>TRUE</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>整数<span class="op">整数</span>整数<span class="op">(</span>FALSE<span class="op">)</span>⇒<span class="op">整数</span>(<span class="op">TRUE</span>)<span class="op">⇒</span>水<b>水</b>(<span class="func">FALSE</span>)<a class="type" href="#types_integer">⇒</a><span class="func">TRUE</span>水<span class="var">(</span>TRUE<b>)</b>⇒<span class="func">例外</span>範囲エラー<span class="var">pred</span>pred<b>(</b>FALSE<span class="func">)</span>⇒<a class="type" href="#types_integer">例外</a>範囲エラー<span class="func">pred</span>(<span class="var">TRUE</span>)<b>⇒</b><span class="func">FALSE</span>ブール<span class="var">(A)翻訳</span>整数<b>整数</b>ブール<span class="func">〇</span>⇒<span class="func"></span>FALSE<span class="var">ブール</span>(1)<b>⇒</b><span class="var">TRUE</span>ブール<span class="func">(2)</span>⇒<span class="var">例外</span>範囲エラー<b>ブール</b>(-1)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<span class="func">範囲エラー</span>ブール<span class="func">(ア)Conversion of</span>文字列<span class="var">へ</span>ブール<b>文字列</b>ブール<a class="exception" href="#errors_RANGE_ERROR">(</a>「間違い」<span class="func">)</span>⇒<span class="var"></span>FALSE<b>ブール</b>(<span class="var">&quot;TRUE&quot;</span>)<span class="func">⇒</span><a class="type" href="#types_integer">TRUE</a>ブール<a class="type" href="#types_integer">(</a>&quot;TRUE&quot;<span class="func">)</span>⇒<b>例外</b>範囲エラー<span class="var">ブール</span>(<span class="func">「true」</span>)<b>⇒</b>例外<span class="var">範囲エラー</span>ブール<span class="func">(</span>「ASDF」<b>)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="func">str</span>(A)〜への変換<b>文字列</b>文字列<a class="exception" href="#errors_RANGE_ERROR">str</a>(<span class="func">FALSE</span>)<a class="type" href="#types_string">⇒</a><span class="type">「間違い」</span>str<a class="type" href="#types_string">(</a>TRUE<span class="func">)</span>⇒<span class="stri"></span>&quot;TRUE&quot;<b>文字通りの</b>文字列<span class="var">文字通りの</span>(<span class="func">FALSE</span>)<span class="stri">⇒</span><b>「間違い」</b>文字通りの<span class="var">(</span>TRUE<span class="func">)</span>⇒<span class="stri"></span>&quot;TRUE&quot;<b>ランド</b>ランド<a class="exception" href="#errors_RANGE_ERROR">ランド</a>(A、B)<span class="func">および</span><span class="stri">ランド</span>ランド<b>(A、A)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">ランド</a>(<span class="func">TRUE</span><span class="stri">FALSE</span>)<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>比べる<span class="func">整数</span>比べる<a class="type" href="#types_string">(</a>FALSE<a class="type" href="#types_string"></a>TRUE<span class="func">)</span>⇒<span class="var">比べる</span>(<b>TRUE</b><span class="stri">TRUE</span>)<span class="func">⇒</span>比べる<span class="var">(</span>TRUE<b></b>FALSE<span class="stri">)</span>⇒<span class="func">hashCode</span>整数<a class="type" href="#types_string">増加</a>増加<span class="func">(A)</span>⇒<span class="var">decr</span>decr<b>(A)</b>⇒<span class="stri">無視する</span><span class="func"></span><span class="var"></span><b></b><span class="stri"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="op"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="var"></span><span class="var"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="var"></span><span class="var"></span><b></b><span class="func"></span><span class="var"></span><span class="var"></span><b></b><span class="func"></span><span class="var"></span><span class="var"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p>論理演算子<tt><span class="op">および</span></tt>および<tt><span class="op">または</span></tt>厳密に左から右に働く。最初に左オペランドを評価し、次に右オペランドを評価します。 左オペランドの評価後に演算結果が確定できる場合は、右オペランドは評価されません。 これは、ブール式内の境界をチェックするときに使用できる。 当然、右オペランドの副作用は<tt><span class="op">および</span></tt>および<tt><span class="op">または</span></tt>演算子のみがオペランドの実行時に適用されます。</p><p>異なるブール式の動作を示す表:</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th rowspan="2">式</th><th align="center" colspan="2">第1オペランドの評価結果</th></tr>

    <tr><th align="center">
          <span class="var">FALSE</span>
        </th><th align="center">
          <span class="var">TRUE</span>
        </th></tr>

    <tr><td><span class="op">ない</span>A</td><td align="center">
          <span class="var">TRUE</span>
        </td><td align="center">
          <span class="var">FALSE</span>
        </td></tr>

    <tr><td>A<span class="op">および</span>B<b>それぞれ</b><br /><span class="op">ない</span>((<span class="op">ない</span>A)<span class="op">または</span>(<span class="op">ない</span>B))</td><td align="center">
          <span class="var">FALSE</span>
        </td><td align="center">B</td></tr>

    <tr><td>A<span class="op">または</span>B<b>それぞれ</b><br /><span class="op">ない</span>((<span class="op">ない</span>A)<span class="op">および</span>(<span class="op">ない</span>B))</td><td align="center">B</td><td align="center">
          <span class="var">TRUE</span>
        </td></tr>

    <tr><td>A>B<b>それぞれ</b><br />A<span class="op">および</span>(<span class="op">ない</span>B)</td><td align="center">
          <span class="var">FALSE</span>
        </td><td align="center"><span class="op">ない</span>B</td></tr>

    <tr><td>A>=B<b>それぞれ</b><br />A<span class="op">または</span>(<span class="op">ない</span>B)</td><td align="center"><span class="op">ない</span>B</td><td align="center">
          <span class="var">TRUE</span>
        </td></tr>

    <tr><td>A&lt;B<b>それぞれ</b><br />(<span class="op">ない</span>A)<span class="op">および</span>B</td><td align="center">B</td><td align="center">
          <span class="var">FALSE</span>
        </td></tr>

    <tr><td>A&lt;=B<b>それぞれ</b><br />(<span class="op">ない</span>A)<span class="op">または</span>B</td><td align="center">
          <span class="var">TRUE</span>
        </td><td align="center">B</td></tr>

    <tr><td><span class="op">ない</span>(A<span class="op">および</span>B)<b>それぞれ</b><br />(<span class="op">ない</span>A)<span class="op">または</span>(<span class="op">ない</span>B)</td><td align="center">
          <span class="var">TRUE</span>
        </td><td align="center"><span class="op">ない</span>B</td></tr>

    <tr><td><span class="op">ない</span>(A<span class="op">または</span>B)<b>それぞれ</b><br />(<span class="op">ない</span>A)<span class="op">および</span>(<span class="op">ない</span>B)</td><td align="center"><span class="op">ない</span>B</td><td align="center">
          <span class="var">FALSE</span>
        </td></tr>

</table></dd></dl><p>論理式の最適化:</p><p>ブール式の結果がコンパイル時に決定できる場合は、式を定数に置き換えることができます。 さらに、以下の方程式を使用することができる:</p><pre class="box">
(A
C)
(A
C)
<span class="op">または</span>B)<span class="op">および</span>(A<span class="op">または</span>C)=A<span class="op">または</span>(B<span class="op">および</span>および<span class="op">B)</span>または<span class="op">(A</span>および<span class="op">C)=A</span>および<span class="op">(B</span>または<span class="op"></span></pre><p></p>
          <a name="types_integer">
        <h3>5.2整数</h3>
          </a>
        <p>型式<tt><span class="type">整数</span></tt>符号付き64ビット整数で構成されます。 整数<a class="link" href="#tokens_Integer_literals">整数リテラル</a>は、10進数と見なされる数字の並びです。 数字列の後には、文字Eまたはe、オプションの+記号、および10進指数が続く場合があります。<a name="types_based_integer"></a>ベース番号は、数字列の後に#文字と拡張数字列が続く場合に指定できます。 #文字の前にある10進数は、#文字の後に続く数の基数を指定します。 基数として2から36までの数が許される。 拡張桁として、文字Aまたはaは10に使用でき、Bまたはbは11などに使用でき、Zまたはzは35に使用できます。 例<tt><span class="type">整数</span></tt>リテラルは次のとおりです:</p><pre class="box">0 2147483647 1E6 2e+9 16#c0 16#FFFF 8#177777 2#1010101010
</pre><p>If an<tt><span class="type">整数</span></tt>操作<a class="link" href="#errors_OVERFLOW_ERROR">あふれる</a>それは例外を持ち出す<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt>その<tt><span class="type">整数</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">integer.s7i</span>&quot;</span></p><pre class="tt">
定数:

〇

(-9223372036854775808)

(9223372036854775807)
前置演算子:

アイデンティティ

符号を変える

階乗
インフィックス演算子:

追加

減算

掛け算

整数の除算をゼロ方向に切り捨てました
(A
trunc(float(A)/float(B))
A
)


(A
B)B*
A
)

整数の除算を負の無限大に切り捨てました。
(A
円形(floor(float(A)/float(B)))
A
)


(A
B)B*
A
)

電力
(A**BはB>=0であればよい。
A**0
A=0であってもすべてのAに対して1
1**B
B>=0の場合は1
A**B
-(-A)**B(A&lt;=0かつB>=0かつ奇数(B)の場合)
A**B
(-A)**B(A&lt;=0かつB>=0かつ奇数でない場合)(B)
A**-1
)
A
Bシフトレフト
(A&lt;&lt;BはB>=0かつB&lt;=63であればよい。
A&lt;&lt;B
B&lt;0またはB>=64のとき
A&lt;&lt;B
A*2**B
A&lt;&lt;0
A)
A
B算術右シフト
(A>>BはB>=0およびB&lt;=63では使用できます。
A>>B
B&lt;0またはB>=64のとき
A>>B
B&lt;=62の場合、2**B
A>>0
A
A>>B
A>=0の場合のC:C>=0
A>>B
A&lt;0の場合のC:C&lt;0
A>>B
A>=0かつB>ord(log2(A))の場合は0
A>>B
A&lt;0およびB>ord(log2(-A))の場合は-1
0>>B
0)

二項係数
(n!k
0(k&lt;0の場合)
n!0
1
n!1
n
n!k
n>=0かつk>nの場合は0
n!k
(!k*!(n-k))for k>=0 and k&lt;=n
n!k
(-1)**k*(n+k-1!k)ただしn&lt;0かつk>=0)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)
A
・変換
は、基数Bの記数法を使用します。
(結果の種類:

48879

-48879

123
)
A
・変換
は、基数Bの記数法を使用します。
(結果の種類:

48879

-48879

123
)

スペースによる左パディング
(123

123

123

123

123
)
-12

-12

-12
)

左詰めゼロ表示
(123

123

123

123

123

-12

-12

-12
)

右パディング(スペース)
(123

123

123

123

123
)
-12

-12

-12
)

科学的表記で
(結果の種類:

12345

12345

12345

3141592

27182818

2**62

-1

-0
)

アイデンティティ
(
A)


(引数Aのタイプ:


123

-123

5





)
リレーション:


機能:

(A)アイデンティティ

(ア)承継人
(succl(A)
A+1
succ(
)

①前任者
(pred(A)
A-1
pred(
)

(A)絶対値
(abs(A)
AはA>=0
(abs(A)
-A&lt;0の場合はA
(abs(
)

(A)奇数値
(結果の種類:
)


(結果の種類:

str(12345)
)

(A)直定数化
(結果の種類:

リテラル(A)
str(A))

(ア)文字列から整数への変換
(引数Aのタイプ:

整数(
123
整数(
-123
整数(
5
整数(

整数(

整数(
)

(A, B)指定した基数の数値列を整数に変換する
(引数Aのタイプ:

整数(
48879
整数(
-127
整数(
170
整数(
51966
整数(

整数(
)

バイト数
(引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
結果のタイプ:

bytes(1413829460, SIGNED, BE)
&quot;TEST&quot;
bytes(1497451343, SIGNED, LE)
&quot;OK&quot;)

lenバイトの
(引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
結果のタイプ:

bytes(1413829460, SIGNED, BE, 5)
&quot;\0;TEST&quot;
bytes(1413829460, SIGNED, BE, 4)
&quot;試験&quot;
bytes(1413829460, SIGNED, BE, 3)
)

バイト数を整数に
(引数Aのタイプ:

引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
bytes2Int(&quot;\210;\2;\150;I&quot;,UNSIGNED, LE)
1234567890)

(A)整数平方根
(sqrt(A)はA>=0の場合はOKです。
sqrt(A)
trunc(sqrt(float(A)))
sqrt(-1)
)

(A)10を底とする切断対数
(log10(A)はA>=0について定義され
log10(10**A)=A(A>=0の場合)
A>=0の場合、log10(pred(10**A))=pred(A)
log10(10)
1
log10(1)
0
log10(0)
-1
log10(-1)
)

(A)切り捨てられたbase 2対数
(log2(A)は
最上位ビットセット。 これはA>=0に対して定義されています。
A>=0の場合、log2(2**A)=A
A>=0の場合、log2(pred(2**A))=pred(A)
log2(2)
1
log2(1)
0
log2(0)
-1
log2(-1)
)

(A)最小の2の補数におけるビット数
符号ビットを除く。
(bitLength(A)
A>=0の場合はsucc(log2(A))
bitLength(A)
A&lt;0の場合はbitLength(pred(-A))
bitLength(0)
0
bitLength(-1)
0)

(A)最下位1ビットのインデックス
A&lt;>0の場合、これは
最下位の0ビット。
(A>>B&lt;&lt;B=A for A&lt;>0 and B=lowestSetBit(A)
lowestSetBit(0)
-1
lowestSetBit(1)
0
lowestSetBit(2)
1)

(A, B)[A, B]の範囲の乱数
ランダム値は一様分布です。
(rand(A, B)は
A&lt;=rand(A, B)
rand(A, B)&lt;=Bが成立する。
rand(A, A)
A
rand(1, 0)
)

(A, B)最低2桁の数値。
(最小(1、2)
1)

(A, B)最大2つの数値。
(最大(1、2)
2)

(A, B)比較関数
(compare(1, 2)
-1
比較(5, 5)
0
compare(8, 7)
1)

(ア)ハッシュ関数
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
Bシフトレフトコピー
(A&lt;&lt;:=B
A:=A&lt;&lt;B)
A
B右シフトコピー
(A>>:=B
A:=A>>B)

(A)1単位
(incr(A)
A+:=1
incr(A)
)

(A)1減分
(decr(A)
A-:=1
decr(A)
)

(A)値を無視(Ignore value)する
<span class="type">整数</span><span class="var">価値</span>既定値<span class="type">整数</span>整数<span class="type"></span>1番目<span class="var">最小値</span>整数<span class="type">整数</span><span class="type">最後の</span>の最大値<span class="var">整数</span>+<span class="type">-</span><span class="op">+</span>-<span class="op">*</span>div<span class="op">div</span>B<span class="op">⇒</span>div<span class="op">0</span>⇒<span class="op">例外</span>NUMERIC_ERROR<span class="op">レム</span>整数除算のリマインダー<span class="op">div</span>レム<b>B</b>⇒<span class="op">A-(A</span>div<b>レム</b>0<a class="exception" href="#errors_NUMERIC_ERROR">⇒</a>例外<span class="op">NUMERIC_ERROR</span>mdiv<span class="op">mdiv</span>B<span class="op">⇒</span>mdiv<b>0</b>⇒<span class="op">例外</span>NUMERIC_ERROR<span class="op">mod</span>整数除算のリマインダー<b>mdiv</b>mod<a class="exception" href="#errors_NUMERIC_ERROR">B</a>⇒<span class="op">A-(A</span>mdiv<span class="op">mod</span>0<b>⇒</b>例外<span class="op">NUMERIC_ERROR</span>**<b>⇒</b>⇒<a class="exception" href="#errors_NUMERIC_ERROR">⇒</a>⇒<span class="op">⇒</span>例外<span class="op">NUMERIC_ERROR</span>&lt;&lt;<span class="op">⇒</span>例外<b>OVERFLOW_ERROR</b>⇒<span class="op">⇒</span>>><span class="op">⇒</span>例外<b>OVERFLOW_ERROR</b>⇒<a class="exception" href="#errors_NUMERIC_ERROR">A</a>mdiv<span class="op">⇒</span>⇒<b>⇒</b>⇒<b>⇒</b>⇒<b></b>⇒<b>⇒</b>⇒<b>⇒</b>⇒<a class="exception" href="#errors_NUMERIC_ERROR">n</a>div<span class="op">⇒</span><b>B</b>:<a class="exception" href="#errors_OVERFLOW_ERROR">ブール</a>TRUE<b>a:b</b>⇒<b>FALSE</b>a:b<span class="op">⇒</span>基数<b>B変換</b>整数<a class="exception" href="#errors_OVERFLOW_ERROR">Aからa</a>文字列<b>文字列</b>基数<span class="op">16</span>⇒<b></b>「牛肉」<b>基数</b>16<b>⇒</b><b>&quot;-beef&quot;</b>基数<b>37</b>⇒<b>例外</b>範囲エラー<span class="op">RADIX</span>B変換<b>整数</b>Aからa<b>文字列</b>文字列<b>RADIX</b>16<b>⇒</b><b>&quot;BEEF&quot;</b>RADIX<span class="op">16</span>⇒<b></b>&quot;-BEEF&quot;<span class="op">RADIX</span>37<span class="op">⇒</span>例外<a class="type" href="#types_boolean">範囲エラー</a>パッド<span class="var">パッド</span>8<b>⇒</b><span class="var">&quot;123&quot;</span>パッド<b>4</b>⇒<span class="op"></span>&quot;123&quot;<span class="type">パッド</span>3<a class="type" href="#types_string">⇒</a><a class="type" href="#types_string">&quot;123&quot;</a>パッド<span class="op">2</span>⇒<b></b>&quot;123&quot;<span class="stri">パッド</span>-8<span class="op">⇒</span><b>&quot;123&quot;</b>パッド<span class="stri">4</span>⇒<span class="op"></span>&quot;-12&quot;<b>パッド</b>3<a class="exception" href="#errors_RANGE_ERROR">⇒</a><span class="op">&quot;-12&quot;</span>パッド<span class="type">2</span>⇒<a class="type" href="#types_string"></a>&quot;-12&quot;<a class="type" href="#types_string">lpad0</a>lpad0<span class="op">8</span>⇒<b></b>&quot;00000123&quot;<span class="stri">lpad0</span>4<span class="op">⇒</span><b>&quot;0123&quot;</b>lpad0<span class="stri">3</span>⇒<span class="op"></span>&quot;123&quot;<b>lpad0</b>2<a class="exception" href="#errors_RANGE_ERROR">⇒</a><span class="op">&quot;123&quot;</span>lpad0<span class="op">-8</span>⇒<b></b>&quot;123&quot;<span class="stri">lpad0</span>4<span class="op">⇒</span><b>&quot;-012&quot;</b>lpad0<span class="stri">3</span>⇒<span class="op"></span>&quot;-12&quot;<b>lpad0</b>2<span class="stri">⇒</span><span class="op">&quot;-12&quot;</span>パッド<b>パッド</b>8<span class="stri">⇒</span><span class="op">&quot;123&quot;</span>パッド<b>4</b>⇒<span class="stri"></span>&quot;123&quot;<span class="op">パッド</span>3<b>⇒</b><span class="stri">&quot;123&quot;</span>パッド<span class="op">2</span>⇒<b></b>&quot;123&quot;<span class="stri">パッド</span>-8<span class="op">⇒</span><b>&quot;123&quot;</b>パッド<span class="stri">4</span>⇒<span class="op"></span>&quot;-12&quot;<span class="op">パッド</span>3<b>⇒</b><span class="stri">&quot;-12&quot;</span>パッド<span class="op">2</span>⇒<b></b>&quot;-12&quot;<span class="stri">sci</span>への変換<span class="op">文字列</span>文字列<b>sci</b>4<span class="stri">⇒</span><span class="op">&quot;1.2345e+4&quot;</span>sci<b>3</b>⇒<span class="stri"></span>&quot;1.235e+4&quot;<span class="op">sci</span>2<b>⇒</b><span class="stri">&quot;1.23e+4&quot;</span>sci<span class="op">0</span>⇒<b></b>「3e+6」<span class="stri">sci</span>0<span class="op">⇒</span><b>「3e+7」</b>sci<span class="stri">6</span>⇒<span class="op"></span>&quot;4.611686e+18&quot;<b>sci</b>3<span class="stri">⇒</span><span class="op">&quot;-1.000e+0&quot;</span>sci<span class="op">2</span>⇒<b></b>&quot;0.00e+0&quot;<span class="stri">整数</span><span class="op">conv</span>整数<b></b>conv<span class="stri">A</span>⇒<span class="op">整数</span><b>解析する</b>A変換<span class="stri">文字列</span>へ<span class="op">整数</span>文字列<b>整数</b><span class="stri">解析する</span><span class="op">&quot;123&quot;</span><b>⇒</b>整数<span class="stri"></span>解析する<span class="op"></span>&quot;-123&quot;<b></b>⇒<span class="stri">整数</span><span class="op">解析する</span><b>「+5」</b><span class="stri">⇒</span>整数<span class="op"></span>解析する<b></b>「1」<span class="stri"></span>⇒<span class="op">例外</span>範囲エラー<a class="type" href="#types_string">整数</a><a class="type" href="#types_string">解析する</a><span class="op">&quot;10&quot;</span><b>⇒</b>例外<span class="stri">範囲エラー</span>整数<span class="op"></span>解析する<b></b>「ASDF」<span class="stri"></span>⇒<span class="op">例外</span>範囲エラー<b>=</b><span class="stri">&lt;></span><span class="op">&lt;</span><b>&lt;=</b><span class="stri">></span><span class="op">>=</span>ord<b>水</b>⇒<span class="stri">整数</span><span class="op">最後の</span>)<b>⇒</b>例外<span class="stri">OVERFLOW_ERROR</span>pred<span class="op">⇒</span>整数<b></b>1番目<span class="stri">)</span>⇒<span class="op">例外</span>OVERFLOW_ERROR<b>abs</b>⇒<span class="stri">⇒</span>整数<span class="type"></span>1番目<span class="op">)</span>⇒<span class="type">例外</span>OVERFLOW_ERROR<span class="op">変な</span>ブール<b>str</b>(A)〜への変換<span class="type">文字列</span>文字列<span class="op">⇒</span><a class="type" href="#types_string">&quot;12345&quot;</a>文字通りの<span class="type">文字列</span>⇒<a class="type" href="#types_string">整数</a>文字列<span class="type">&quot;123&quot;</span>)<span class="op">⇒</span>&quot;-123&quot;<span class="stri">)</span>⇒<b>「+5」</b>)<span class="type">⇒</span>「1」<span class="op">)</span>⇒<span class="stri">例外</span>範囲エラー<b>&quot;10&quot;</b>)<span class="type">⇒</span>例外<span class="op">範囲エラー</span>「ASDF」<span class="stri">)</span>⇒<b>例外</b>範囲エラー<span class="type">整数</span>文字列<span class="op">「牛肉」</span>,16)<span class="stri">⇒</span>&quot;-177&quot;<b>,8)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">&quot;10101010&quot;</a>,2)<span class="type">⇒</span>「カフェ」<span class="op">,16)</span>⇒<span class="stri">「0」</span>,1)<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>「qwertyuiop」<span class="type">,37)</span>⇒<span class="op">例外</span>範囲エラー<span class="stri">バイト</span>(A, S, E)整数をに変換する<b>文字列</b>署名されていること<a class="exception" href="#errors_RANGE_ERROR">エンディアンネス</a>文字列<span class="op">⇒</span>⇒<span class="op">バイト</span>(A, S, E, len)整数を<span class="op">文字列</span>署名されていること<span class="op">エンディアンネス</span>文字列<span class="op">⇒</span>⇒<span class="op">⇒</span>例外<span class="func">範囲エラー</span>bytes2Int<span class="func">(A, S, E)Convert a</span>文字列<b>文字列</b>署名されていること<span class="type">エンディアンネス</span>⇒<span class="var">sqrt</span>⇒<b>⇒</b>例外<a class="exception" href="#errors_OVERFLOW_ERROR">NUMERIC_ERROR</a>log10<span class="func">⇒</span>⇒<b>⇒</b>⇒<span class="type">例外</span>NUMERIC_ERROR<span class="var">log2</span>⇒<b>⇒</b>⇒<a class="exception" href="#errors_OVERFLOW_ERROR">⇒</a>例外<span class="func">NUMERIC_ERROR</span>bitLength<b>⇒</b>⇒<b>⇒</b>⇒<span class="type">lowestSetBit</span>⇒<span class="var">⇒</span>⇒<b>ランド</b>および<a class="exception" href="#errors_OVERFLOW_ERROR">⇒</a>⇒<span class="func">例外</span>範囲エラー<a class="type" href="#types_boolean">分</a>⇒<span class="func">最大</span>⇒<a class="type" href="#types_string">比べる</a>⇒<a class="type" href="#types_string">⇒</a>⇒<b>hashCode</b>+:=<span class="stri">⇒</span>-:=<span class="func">⇒</span>*:=<a class="type" href="#types_string">⇒</a>&lt;&lt;:=<b>⇒</b>>>:=<span class="func">⇒</span>増加<a class="type" href="#types_string">⇒</a>⇒<span class="stri">例外</span>OVERFLOW_ERROR<b>A=の場合</b>整数<span class="stri"></span>最後の<b>decr</b>⇒<span class="stri">⇒</span>例外<b>OVERFLOW_ERROR</b>A=の場合<span class="stri">整数</span><b>1番目</b>無視する<a class="exception" href="#errors_RANGE_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><a class="type" href="#types_string"></a><b></b><b></b><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><a class="type" href="#types_string"></a><b></b><b></b><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><b></b><span class="func"></span><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><b></b><b></b><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><b></b><b></b><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><b></b><b></b><b></b><b></b><span class="func"></span><b></b><b></b><b></b><span class="func"></span><span class="op"></span><b></b><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><b></b><b></b><span class="func"></span><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="func"></span><b></b><b></b><a class="exception" href="#errors_OVERFLOW_ERROR"></a><span class="type"></span><span class="var"></span><span class="func"></span><b></b><b></b><a class="exception" href="#errors_OVERFLOW_ERROR"></a><span class="type"></span><span class="var"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p><a name="types_div_rem_mdiv_mod_properties"></a>操作について<tt><span class="op">div</span></tt>および<tt><span class="op">レム</span></tt>すべてのAに当てはまる:</p><pre class="box">
(A
B&lt;>0のときB=A
-A
B)B&lt;>0のとき
-A
B)B&lt;>0のとき
A
B&lt;abs(B)(B&lt;>0かつA>=0のとき)
A
B&lt;>0かつA&lt;=0のときB>-abs(B)
<span class="op">div</span>B)*B+A<span class="op">レム</span>div<span class="op">B=-(A</span>div<span class="op">レム</span>B=-(A<span class="op">レム</span>レム<span class="op">B>=0</span>および<span class="op">A</span>レム<span class="op">レム</span>B&lt;=0<span class="op">および</span>A<span class="op">レム</span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mdiv</span></tt>および<tt><span class="op">mod</span></tt>すべてのAに当てはまる:</p><pre class="box">
(A
B&lt;>0のときB=A
-A
-B&lt;>0のときはB
-A
B)B&lt;>0のとき
A
B>0のときB&lt;B
A
B&lt;0のとき、B>B
<span class="op">mdiv</span>B)*B+A<span class="op">mod</span>mdiv<span class="op">B=A</span>mdiv<span class="op">mod</span>-B=-(A<span class="op">mod</span>mod<span class="op">B>=0</span>および<span class="op">A</span>mod<span class="op">mod</span>B&lt;=0<span class="op">および</span>A<span class="op">mod</span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mdiv</span></tt>には、次の内容</p><pre class="box">
A
AとBが異なる場合、B-1
符号とA
B&lt;>0が成立する。
A
AとBが同じである場合、B
記号またはA
B=0が成立する。
A
A>0かつB&lt;0のときはB-1
A
A&lt;0かつB>0のときはB-1
A
2**B>=0のときB=A>>B
<span class="op">mdiv</span>B=A<span class="op">div</span>レム<span class="op">mdiv</span>B=A<span class="op">div</span>レム<span class="op">mdiv</span>B=(A-1)<span class="op">div</span>mdiv<span class="op">B=(A+1)</span>div<span class="op">mdiv</span><span class="op"></span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mod</span></tt>には、次の内容</p><pre class="box">
A
AとBが異なる場合はB+B
符号とA
B&lt;>0が成立する。
A
AとBが同じである場合、B
記号またはA
B=0が成立する。
<span class="op">mod</span>B=A<span class="op">レム</span>レム<span class="op">mod</span>B=A<span class="op">レム</span>レム<span class="op"></span><span class="op"></span></pre><p><a name="types_div_rem_mdiv_mod_tables"></a>の動作の表<tt><span class="op">div</span></tt><tt><span class="op">レム</span></tt><tt><span class="op">mdiv</span></tt>および<tt><span class="op">mod</span></tt>:</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th>A</th><th>B</th><th>A<span class="op">div</span>B</th><th>A<span class="op">レム</span>B</th><th>A<span class="op">mdiv</span>B</th><th>A<span class="op">mod</span>B</th></tr>

    <tr><td align="center">5</td><td align="center">3</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">2</td></tr>
    <tr><td align="center">4</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr>
    <tr><td align="center">3</td><td align="center">3</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr>
    <tr><td align="center">2</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">0</td><td align="center">2</td></tr>
    <tr><td align="center">1</td><td align="center">3</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr>
    <tr><td align="center">0</td><td align="center">3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr>
    <tr><td align="center">-1</td><td align="center">3</td><td align="center">0</td><td align="center">-1</td><td align="center">-1</td><td align="center">2</td></tr>
    <tr><td align="center">-2</td><td align="center">3</td><td align="center">0</td><td align="center">-2</td><td align="center">-1</td><td align="center">1</td></tr>
    <tr><td align="center">-3</td><td align="center">3</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center">0</td></tr>
    <tr><td align="center">-4</td><td align="center">3</td><td align="center">-1</td><td align="center">-1</td><td align="center">-2</td><td align="center">2</td></tr>
    <tr><td align="center">-5</td><td align="center">3</td><td align="center">-1</td><td align="center">-2</td><td align="center">-2</td><td align="center">1</td></tr>

</table></dd></dl><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th>A</th><th>B</th><th>A<span class="op">div</span>B</th><th>A<span class="op">レム</span>B</th><th>A<span class="op">mdiv</span>B</th><th>A<span class="op">mod</span>B</th></tr>

    <tr><td align="center">5</td><td align="center">-3</td><td align="center">-1</td><td align="center">2</td><td align="center">-2</td><td align="center">-1</td></tr>
    <tr><td align="center">4</td><td align="center">-3</td><td align="center">-1</td><td align="center">1</td><td align="center">-2</td><td align="center">-2</td></tr>
    <tr><td align="center">3</td><td align="center">-3</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center">0</td></tr>
    <tr><td align="center">2</td><td align="center">-3</td><td align="center">0</td><td align="center">2</td><td align="center">-1</td><td align="center">-1</td></tr>
    <tr><td align="center">1</td><td align="center">-3</td><td align="center">0</td><td align="center">1</td><td align="center">-1</td><td align="center">-2</td></tr>
    <tr><td align="center">0</td><td align="center">-3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr>
    <tr><td align="center">-1</td><td align="center">-3</td><td align="center">0</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td></tr>
    <tr><td align="center">-2</td><td align="center">-3</td><td align="center">0</td><td align="center">-2</td><td align="center">0</td><td align="center">-2</td></tr>
    <tr><td align="center">-3</td><td align="center">-3</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr>
    <tr><td align="center">-4</td><td align="center">-3</td><td align="center">1</td><td align="center">-1</td><td align="center">1</td><td align="center">-1</td></tr>
    <tr><td align="center">-5</td><td align="center">-3</td><td align="center">1</td><td align="center">-2</td><td align="center">1</td><td align="center">-2</td></tr>

</table></dd></dl><p><a name="types_binomial_cofficient_table"></a>の動作の表<tt><span class="op"></span></tt>(二項係数):</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th rowspan="2" colspan="2">n!k</th><th colspan="11">k</th></tr>

    <tr><th>-5</th><th>-4</th><th>-3</th><th>-2</th><th>-1</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr>

    <tr><td rowspan="11">
          <b>n</b>
        </td><td align="center">
          <b>-5</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-5</td><td align="center">15</td><td align="center">-35</td><td align="center">70</td><td align="center">-126</td></tr>

    <tr><td align="center">
          <b>-4</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-4</td><td align="center">10</td><td align="center">-20</td><td align="center">35</td><td align="center">-56</td></tr>

    <tr><td align="center">
          <b>-3</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-3</td><td align="center">6</td><td align="center">-10</td><td align="center">15</td><td align="center">-21</td></tr>

    <tr><td align="center">
          <b>-2</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-2</td><td align="center">3</td><td align="center">-4</td><td align="center">5</td><td align="center">-6</td></tr>

    <tr><td align="center">
          <b>-1</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td></tr>

    <tr><td align="center">
          <b>0</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr>

    <tr><td align="center">
          <b>1</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr>

    <tr><td align="center">
          <b>2</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr>

    <tr><td align="center">
          <b>3</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr>

    <tr><td align="center">
          <b>4</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">4</td><td align="center">6</td><td align="center">4</td><td align="center">1</td><td align="center">0</td></tr>

    <tr><td align="center">
          <b>5</b>
        </td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">5</td><td align="center">10</td><td align="center">10</td><td align="center">5</td><td align="center">1</td></tr>

</table></dd></dl><p>For the<tt><span class="func">sqrt</span></tt>関数が成立する(A>=0の場合)。</p><pre class="box">
sqrt(A)*sqrt(A)&lt;=A

(sqrt(A)+1)*(sqrt(A)+1)>A
<span class="op">および</span></pre><p></p>
          <a name="types_bigInteger">
        <h3>5.3 bigInteger</h3>
          </a>
        <p>型式<tt><span class="type">bigInteger</span></tt>に、符号付きで大きさに制限のない整数の値を示します。 A<a class="link" href="#tokens_BigInteger_literals">bigIntegerリテラル</a>は、数字列の後にアンダースコア文字を付けたものです(例:1_)。 ベース番号は、数字列の後に#文字と拡張数字列が続く場合に指定できます。 #文字の前にある10進数は、#文字の後に続く数の基数を指定します。 基数として2から36までの数が許される。 拡張桁として、文字Aまたはaは10に使用でき、Bまたはbは11などに使用でき、Zまたはzは35に使用できます。 10進数と同様<tt><span class="type">bigInteger</span></tt>リテラル拡張数字の直後にはアンダースコア文字が必要です。 例<tt><span class="type">bigInteger</span></tt>リテラルは次のとおりです:</p><pre class="box">0_18446744073709551616_16#deadbeefcafe_
</pre><p>しかし<tt><span class="type">bigInteger</span></tt>操作がオーバーフローすることはできず<tt><span class="type">bigInteger</span></tt>value. この場合、例外は<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt>を上げます。 その<tt><span class="type">bigInteger</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">bigint.s7i</span>&quot;</span></p><pre class="tt">
定数:

(0_)
前置演算子:

アイデンティティ

符号を変える

階乗
インフィックス演算子:

追加

減算

掛け算

整数の除算をゼロ方向に切り捨てました
(A
trunc(A/B)
A
)


(A
B)B*
A
)

整数の除算を負の無限大に切り捨てました。
(A
フロア(A/B)
A
)


(A
B)B*
A
)
A
B出力
(引数Bのタイプ:

A**BはB>=0であれば有効です。
A**0
1_すべてのAに対して、A=0_であっても
1_**B
1_for B>=0
A**B
-(-A)**B(A&lt;=0_かつB>=0かつ奇数(B)の場合)
A**B
(-A)**B for A&lt;= 0_ and B >=0 and not odd(B)
A**-1
)
A
Bシフトレフト
(引数Bのタイプ:

A&lt;&lt;B
B>=0の場合、A*2_**B
A&lt;&lt;B
B&lt;0の場合、A>>-B
A&lt;&lt;0
A
0_&lt;&lt;B
0_forすべてのB)
A
B算術右シフト
(引数Bのタイプ:

A>>B
B>=0の場合、2_**B
A>>B
A&lt;&lt;-B(B&lt;0の場合)
A>>0
A
A>>B
A>=0_holdsの場合のC:C>=0_
A>>B
A&lt;0_holdsの場合のC:C&lt;0_
A>>B
0_for A>=0_and B>ord(log2(A))
A>>B
-1_for A&lt; 0_ and B >ord(log2(-A))
0_>>B
0_forすべてのB)

二項係数
(n!k
0_for k&lt;0_
n!0_
1_
n!1_
n
n!k
n>=0_かつk>nの場合、0_
n!k
(!k*!(n-k))for k>=0_and k&lt;=n
n!k
(-1)**k*(n+k-1!k)for n&lt; 0_ and k >=0_)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)
A
・変換
は、基数Bの記数法を使用します。
(結果の種類:

3735928559_

-3735928559_

123_
)
A
・変換
は、基数Bの記数法を使用します。
(結果の種類:

3735928559_

-3735928559_

123_
)

科学的表記で
(右オペランドの型:

結果のタイプ:

12345_

12345_

12345_

3141592_

27182818_

2_**62

-1_

-0_
)


(引数Aのタイプ:


1_)


(引数Aのタイプ:


123_

-123_

5_





)
リレーション:


機能:

(A)序数
(結果の種類:
)
ord(99999999999999999999_)
)

(A)序数
(結果の種類:
)
integer(99999999999999999999_)
)

(ア)承継人
(succl(A)
A+1_)

①前任者
(pred(A)
A-1_)

(A)絶対値

(A)奇数値
(結果の種類:
)


(結果の種類:

str(9876543210_)
)

(A)bigInteger数をbigIntegerリテラルに変換する。
(結果の種類:

リテラル(9876543210_)
)

bigIntegerに
(引数Aのタイプ:

bigInteger(1)
1_)

(A)数値文字列をbigIntegerに変換する
(引数Aのタイプ:

bigInteger(
123_
bigInteger(
-123_
bigInteger(
5_
bigInteger(

bigInteger(

bigInteger(
)

(A, B)指定した基数の数値列をbigIntegerに変換する
(引数Aのタイプ:

引数Bの型:

bigInteger(
3735928559_
bigInteger(
-8589934591_
bigInteger(
170_
bigInteger(
51966_
bigInteger(

bigInteger(
)

バイト数
(引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
結果のタイプ:

bytes(1413829460_,SIGNED, BE)
&quot;TEST&quot;
bytes(1497451343_,SIGNED, LE)
&quot;OK&quot;)

lenバイトの
(引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
結果のタイプ:

bytes(1413829460_,SIGNED, BE, 5)
&quot;\0;TEST&quot;
bytes(1413829460_,SIGNED, BE, 4)
&quot;試験&quot;
bytes(1413829460_,SIGNED, BE, 3)
)

のバイト数をbigInteger
(引数Aのタイプ:

引数Sのタイプ:
(署名のないもの及び署名のあるもの)
引数Eのタイプ:
(LEおよびBE)
bytes2BigInt(&quot;\210;\2;\150;I&quot;,UNSIGNED, LE)
1234567890_)

(A)整数平方根
(sqrt(A)はA>=0_で問題ありません。
sqrt(A)
trunc(sqrt(float(A)))
sqrt(-1_)
)

(A, B)AモジュロBのモジュラ乗法逆数を計算する。

(A, B, C)A**Bのモジュラー指数を計算します。

(A)10を底とする切断対数
(log10(A)はA>=0_
log10(10_**A)=A(A>=0_の場合)
log10(pred(10_**A))=pred(A)for A>=0_
log10(10_)
1_
log10(1_)
0_
log10(0_)
-1_
log10(-1_)
)

(A)切り捨てられたbase 2対数
(log2(A)は
最上位ビットセット。 これはA>=0に対して定義されています。
A>=0の場合、log2(2_**A)=A
A>=0の場合、log2(pred(2_**A))=pred(A)
log2(2_)
1_
log2(1_)
0_
log2(0_)
-1_
log2(-1_)
)

(A, B)AとBの最大公約数。
(gcd(A, B)=gcd(B, A)
gcd(A, B)=gcd(-A, B)
gcd(A, 0)=abs(A))

(A)最小の2の補数におけるビット数
符号ビットを除く。
(結果の種類:

bitLength(A)
ord(succ(log2(A)))for A>=0_
bitLength(A)
A&lt;0_の場合はbitLength(pred(-A))
bitLength(0_)
0
bitLength(-1_)
0)

(A)最下位1ビットのインデックス
A&lt;>0_の場合、これは
最下位の0ビット。
(結果の種類:

A>>B&lt;&lt;B=A for A&lt;>0_and B=lowestSetBit(A)
lowestSetBit(0_)
-1
lowestSetBit(1_)
0
lowestSetBit(2_)
1)

(A, B)[A, B]の範囲の乱数
ランダム値は一様分布です。
(rand(A, B)は
A&lt;=rand(A, B)
rand(A, B)&lt;=Bが成立する。
rand(A, A)
A
rand(1_,0_)
)

(A, B)最低2桁の数値。
(最小(1_,2_)
1_)

(A, B)最大2つの数値。
(max(1_,2_)
2_)

(A, B)比較関数
(結果の種類:

比較(1_,2_)
-1
compare(5_,5_)
0
compare(8_,7_)
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
Bシフトレフトコピー
(A&lt;&lt;:=B
A:=A&lt;&lt;B)
A
B右シフトコピー
(A>>:=B
A:=A>>B)

(A)1単位
(incr(A)
A+:=1_)

(A)1減分
(decr(A)
A-:=1_)

(A)値を無視(Ignore value)する
<span class="type">bigInteger</span><span class="var">価値</span>既定値<span class="type">bigInteger</span>+<span class="op">-</span><span class="op">+</span>-<span class="op">*</span>div<span class="op">div</span>B<span class="op">⇒</span>div<span class="op">0_</span>⇒<span class="op">例外</span>NUMERIC_ERROR<span class="op">レム</span>整数除算のリマインダー<b>div</b>レム<span class="op">B</span>⇒<b>A-(A</b>div<a class="exception" href="#errors_NUMERIC_ERROR">レム</a>0_<span class="op">⇒</span>例外<span class="op">NUMERIC_ERROR</span>mdiv<span class="op">mdiv</span>B<b>⇒</b>mdiv<span class="op">0_</span>⇒<span class="op">例外</span>NUMERIC_ERROR<b>mod</b>整数除算のリマインダー<a class="exception" href="#errors_NUMERIC_ERROR">mdiv</a>mod<span class="op">B</span>⇒<span class="op">A-(A</span>mdiv<b>mod</b>0_<span class="op">⇒</span>例外<b>NUMERIC_ERROR</b>**<a class="exception" href="#errors_NUMERIC_ERROR">整数</a>⇒<span class="op">⇒</span>⇒<span class="op">⇒</span>⇒<span class="op">例外</span>NUMERIC_ERROR<b>&lt;&lt;</b>整数<span class="op">⇒</span>⇒<span class="op">⇒</span>⇒<b>>></b>整数<a class="exception" href="#errors_NUMERIC_ERROR">⇒</a>A<span class="op">mdiv</span>⇒<a class="type" href="#types_integer">⇒</a>⇒<b>⇒</b>⇒<b>⇒</b>⇒<b></b>⇒<b>⇒</b>⇒<b>⇒</b>⇒<a class="exception" href="#errors_NUMERIC_ERROR">n</a>div<span class="op">⇒</span><a class="type" href="#types_integer">B</a>:<b>ブール</b>TRUE<b>a:b</b>⇒<b>FALSE</b>a:b<b>⇒</b>基数<span class="op">B変換</span>bigInteger<a class="type" href="#types_integer">Aからa</a>文字列<b>文字列</b>基数<span class="op">16</span>⇒<b></b>&quot;死んだ牛&quot;<b>基数</b>16)<b>⇒</b><b>&quot;-deadbeef&quot;</b>基数<b>37</b>⇒<b>例外</b>範囲エラー<b>RADIX</b>B変換<span class="op">整数</span>Aからa<b>文字列</b>文字列<b>RADIX</b>16<b>⇒</b><b>&quot;DEADBEEF&quot;</b>RADIX<b>16)</b>⇒<span class="op"></span>&quot;-DEADBEEF&quot;<b>RADIX</b>37<span class="op">⇒</span>例外<span class="op">範囲エラー</span>sci<a class="type" href="#types_boolean">への変換</a>文字列<span class="var">整数</span>文字列<b>sci</b>4<span class="var">⇒</span><b>&quot;1.2345e+4&quot;</b>sci<span class="op">3</span>⇒<span class="type"></span>&quot;1.235e+4&quot;<a class="type" href="#types_string">sci</a>2<a class="type" href="#types_string">⇒</a><span class="op">&quot;1.23e+4&quot;</span>sci<b>0</b>⇒<span class="stri"></span>「3e+6」<span class="op">sci</span>0<b>⇒</b><span class="stri">「3e+7」</span>sci<span class="op">6</span>⇒<b></b>&quot;4.611686e+18&quot;<a class="exception" href="#errors_RANGE_ERROR">sci</a>3<span class="op">⇒</span><a class="type" href="#types_integer">&quot;-1.000e+0&quot;</a>sci<a class="type" href="#types_string">2</a>⇒<a class="type" href="#types_string"></a>&quot;0.00e+0&quot;<span class="op">bigInteger</span><b>conv</b>A変換<span class="stri">整数</span>へ<span class="op">bigInteger</span>整数<b>bigInteger</b><span class="stri">conv</span>1<span class="op">⇒</span>bigInteger<b></b>解析する<a class="exception" href="#errors_RANGE_ERROR">A変換</a>文字列<span class="op">へ</span>整数<a class="type" href="#types_string">文字列</a>bigInteger<a class="type" href="#types_integer"></a>解析する<a class="type" href="#types_string"></a>&quot;123&quot;<span class="op"></span>⇒<b>bigInteger</b><span class="stri">解析する</span><span class="op">&quot;-123&quot;</span><b>⇒</b>bigInteger<span class="stri"></span>解析する<span class="op"></span>「+5」<b></b>⇒<span class="stri">bigInteger</span><span class="op">解析する</span><b>「1」</b><span class="stri">⇒</span>例外<span class="op">範囲エラー</span>bigInteger<b></b>解析する<span class="stri"></span>&quot;10&quot;<span class="op"></span>⇒<b>例外</b>範囲エラー<span class="stri">bigInteger</span><span class="op">解析する</span><b>「ASDF」</b><span class="stri">⇒</span>例外<span class="op">範囲エラー</span>=<b></b>&lt;><span class="stri"></span>&lt;<span class="type"></span>&lt;=<span class="op"></span>><a class="type" href="#types_integer"></a>>=<span class="type">ord</span>整数<a class="type" href="#types_integer">⇒</a>例外<span class="type">範囲エラー</span>整数<span class="op">整数</span>⇒<b>例外</b>範囲エラー<span class="type">水</span>⇒<span class="op">pred</span>⇒<a class="type" href="#types_string">abs</a>変な<a class="type" href="#types_integer">ブール</a>str<a class="type" href="#types_string">(A)〜への変換</a>文字列<span class="type">文字列</span>⇒<span class="op"></span>&quot;9876543210&quot;<span class="stri">文字通りの</span>文字列<b>⇒</b><span class="type">&quot;9876543210_&quot;</span>bigInteger<span class="op">(A)翻訳</span>整数<span class="stri">整数</span>⇒<b>bigInteger</b>文字列<span class="type">&quot;123&quot;</span>)<span class="op">⇒</span>&quot;-123&quot;<span class="stri">)</span>⇒<b>「+5」</b>)<span class="type">⇒</span>「1」<span class="op">)</span>⇒<span class="stri">例外</span>範囲エラー<b>&quot;10&quot;</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<span class="type">範囲エラー</span>「ASDF」<span class="op">)</span>⇒<span class="stri">例外</span>範囲エラー<b>bigInteger</b>文字列<a class="exception" href="#errors_RANGE_ERROR">整数</a>&quot;死んだ牛&quot;<span class="type">,16)</span>⇒<span class="op">&quot;-77777777777&quot;</span>,8)<span class="stri">⇒</span>&quot;10101010&quot;<b>,2)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">「カフェ」</a>,16)<span class="op">⇒</span>「0」<span class="op">,1)</span>⇒<span class="op">例外</span>範囲エラー<span class="op">「qwertyuiop」</span>,37)<span class="op">⇒</span>例外<span class="op">範囲エラー</span>バイト<span class="func">(A, S, E)bigIntegerを</span>文字列<a class="type" href="#types_integer">署名されていること</a>エンディアンネス<b>文字列</b>⇒<a class="exception" href="#errors_RANGE_ERROR">⇒</a>バイト<span class="func">(A, S, E, len)bigIntegerを</span>文字列<a class="type" href="#types_integer">署名されていること</a>エンディアンネス<b>文字列</b>⇒<a class="exception" href="#errors_RANGE_ERROR">⇒</a>⇒<span class="func">例外</span>範囲エラー<b>bytes2BigInt</b>(A, S, E)Convert a<span class="func">文字列</span>文字列<b>署名されていること</b>エンディアンネス<span class="func">⇒</span>sqrt<span class="func">⇒</span>⇒<a class="type" href="#types_boolean">例外</a>NUMERIC_ERROR<span class="func">modInverse</span>modPow<a class="type" href="#types_string">log10</a>⇒<a class="type" href="#types_string">⇒</a>⇒<b>⇒</b>例外<span class="stri">NUMERIC_ERROR</span>log2<span class="func">⇒</span>⇒<a class="type" href="#types_string">⇒</a>⇒<b>例外</b>NUMERIC_ERROR<span class="stri">gcd</span>bitLength<span class="func">整数</span>⇒<a class="type" href="#types_integer">⇒</a>⇒<a class="type" href="#types_integer">⇒</a>lowestSetBit<b>整数</b>⇒<span class="func">⇒</span>⇒<a class="type" href="#types_string">ランド</a>および<span class="stri">⇒</span>⇒<b>例外</b>範囲エラー<span class="stri">分</span>⇒<b>最大</b>⇒<span class="stri">比べる</span>整数<b>⇒</b>⇒<span class="stri">⇒</span>hashCode<b>整数</b>+:=<a class="exception" href="#errors_RANGE_ERROR">⇒</a>-:=<span class="stri">⇒</span>*:=<b>⇒</b>&lt;&lt;:=<a class="exception" href="#errors_RANGE_ERROR">⇒</a>>>:=<span class="stri">⇒</span>増加<b>⇒</b>decr<a class="exception" href="#errors_RANGE_ERROR">⇒</a>無視する<span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_integer"></a><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><a class="type" href="#types_string"></a><b></b><b></b><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><a class="type" href="#types_string"></a><b></b><b></b><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="type"></span><span class="type"></span><b></b><span class="func"></span><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><span class="func"></span><span class="func"></span><b></b><b></b><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><b></b><b></b><b></b><b></b><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><span class="func"></span><span class="op"></span><b></b><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p>操作について<tt><span class="op">div</span></tt>および<tt><span class="op">レム</span></tt>すべてのAに当てはまる:</p><pre class="box">
(A
B&lt;>0_のときB=A
-A
B)B&lt;>0_のとき
-A
B)B&lt;>0_のとき
A
B&lt;abs(B)、B&lt;>0_かつA>=0_のとき
A
B&lt;>0_かつA&lt;=0_のとき、B>-abs(B)
<span class="op">div</span>B)*B+A<span class="op">レム</span>div<span class="op">B=-(A</span>div<span class="op">レム</span>B=-(A<span class="op">レム</span>レム<span class="op">B>=0_</span>および<span class="op">A</span>レム<span class="op">レム</span>B&lt;=0_<span class="op">および</span>A<span class="op">レム</span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mdiv</span></tt>および<tt><span class="op">mod</span></tt>すべてのAに当てはまる:</p><pre class="box">
(A
B&lt;>0_のときB=A
-A
-B&lt;>0_のときはB
-A
B)B&lt;>0_のとき
A
B>0_のときB&lt;B
A
B&lt;0_のとき、B>B
<span class="op">mdiv</span>B)*B+A<span class="op">mod</span>mdiv<span class="op">B=A</span>mdiv<span class="op">mod</span>-B=-(A<span class="op">mod</span>mod<span class="op">B>=0_</span>および<span class="op">A</span>mod<span class="op">mod</span>B&lt;=0_<span class="op">および</span>A<span class="op">mod</span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mdiv</span></tt>には、次の内容</p><pre class="box">
A
B-1_AとBが異なる場合
符号とA
B&lt;>0_が成立する。
A
AとBが同じである場合、B
記号またはA
B=0が成立する。
A
A>0_かつB&lt;0_が成立するときB-1_。
A
A&lt;0_かつB>0_が成立するときB-1_。
A
2_**B>=0の場合、B=A>>B
<span class="op">mdiv</span>B=A<span class="op">div</span>レム<span class="op">mdiv</span>B=A<span class="op">div</span>レム<span class="op">mdiv</span>B=(A-1_)<span class="op">div</span>mdiv<span class="op">B=(A+1_)</span>div<span class="op">mdiv</span><span class="op"></span><span class="op"></span><span class="op"></span></pre><p>操作について<tt><span class="op">mod</span></tt>には、次の内容</p><pre class="box">
A
AとBが異なる場合はB+B
符号とA
B&lt;>0_が成立する。
A
AとBが同じである場合、B
記号またはA
B=0が成立する。
<span class="op">mod</span>B=A<span class="op">レム</span>レム<span class="op">mod</span>B=A<span class="op">レム</span>レム<span class="op"></span><span class="op"></span></pre><p>の動作の表<tt><span class="op">div</span></tt><tt><span class="op">レム</span></tt><tt><span class="op">mdiv</span></tt>および<tt><span class="op">mod</span></tt>:</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th>A</th><th>B</th><th>A<span class="op">div</span>B</th><th>A<span class="op">レム</span>B</th><th>A<span class="op">mdiv</span>B</th><th>A<span class="op">mod</span>B</th></tr>

    <tr><td align="center">5_</td><td align="center">3_</td><td align="center">1_</td><td align="center">2_</td><td align="center">1_</td><td align="center">2_</td></tr>
    <tr><td align="center">4_</td><td align="center">3_</td><td align="center">1_</td><td align="center">1_</td><td align="center">1_</td><td align="center">1_</td></tr>
    <tr><td align="center">3_</td><td align="center">3_</td><td align="center">1_</td><td align="center">0_</td><td align="center">1_</td><td align="center">0_</td></tr>
    <tr><td align="center">2_</td><td align="center">3_</td><td align="center">0_</td><td align="center">2_</td><td align="center">0_</td><td align="center">2_</td></tr>
    <tr><td align="center">1_</td><td align="center">3_</td><td align="center">0_</td><td align="center">1_</td><td align="center">0_</td><td align="center">1_</td></tr>
    <tr><td align="center">0_</td><td align="center">3_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td></tr>
    <tr><td align="center">-1_</td><td align="center">3_</td><td align="center">0_</td><td align="center">-1_</td><td align="center">-1_</td><td align="center">2_</td></tr>
    <tr><td align="center">-2_</td><td align="center">3_</td><td align="center">0_</td><td align="center">-2_</td><td align="center">-1_</td><td align="center">1_</td></tr>
    <tr><td align="center">-3_</td><td align="center">3_</td><td align="center">-1_</td><td align="center">0_</td><td align="center">-1_</td><td align="center">0_</td></tr>
    <tr><td align="center">-4_</td><td align="center">3_</td><td align="center">-1_</td><td align="center">-1_</td><td align="center">-2_</td><td align="center">2_</td></tr>
    <tr><td align="center">-5_</td><td align="center">3_</td><td align="center">-1_</td><td align="center">-2_</td><td align="center">-2_</td><td align="center">1_</td></tr>

</table></dd></dl><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th>A</th><th>B</th><th>A<span class="op">div</span>B</th><th>A<span class="op">レム</span>B</th><th>A<span class="op">mdiv</span>B</th><th>A<span class="op">mod</span>B</th></tr>

    <tr><td align="center">5_</td><td align="center">-3_</td><td align="center">-1_</td><td align="center">2_</td><td align="center">-2_</td><td align="center">-1_</td></tr>
    <tr><td align="center">4_</td><td align="center">-3_</td><td align="center">-1_</td><td align="center">1_</td><td align="center">-2_</td><td align="center">-2_</td></tr>
    <tr><td align="center">3_</td><td align="center">-3_</td><td align="center">-1_</td><td align="center">0_</td><td align="center">-1_</td><td align="center">0_</td></tr>
    <tr><td align="center">2_</td><td align="center">-3_</td><td align="center">0_</td><td align="center">2_</td><td align="center">-1_</td><td align="center">-1_</td></tr>
    <tr><td align="center">1_</td><td align="center">-3_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-1_</td><td align="center">-2_</td></tr>
    <tr><td align="center">0_</td><td align="center">-3_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td></tr>
    <tr><td align="center">-1_</td><td align="center">-3_</td><td align="center">0_</td><td align="center">-1_</td><td align="center">0_</td><td align="center">-1_</td></tr>
    <tr><td align="center">-2_</td><td align="center">-3_</td><td align="center">0_</td><td align="center">-2_</td><td align="center">0_</td><td align="center">-2_</td></tr>
    <tr><td align="center">-3_</td><td align="center">-3_</td><td align="center">1_</td><td align="center">0_</td><td align="center">1_</td><td align="center">0_</td></tr>
    <tr><td align="center">-4_</td><td align="center">-3_</td><td align="center">1_</td><td align="center">-1_</td><td align="center">1_</td><td align="center">-1_</td></tr>
    <tr><td align="center">-5_</td><td align="center">-3_</td><td align="center">1_</td><td align="center">-2_</td><td align="center">1_</td><td align="center">-2_</td></tr>

</table></dd></dl><p><a name="types_binomial_cofficient_table"></a>の動作の表<tt><span class="op"></span></tt>(二項係数):</p><dl><dd><table class="tt" border="1" cellspacing="0" cellpadding="3">

    <tr><th rowspan="2" colspan="2">n!k</th><th colspan="11">k</th></tr>

    <tr><th>-5_</th><th>-4_</th><th>-3_</th><th>-2_</th><th>-1_</th><th>0_</th><th>1_</th><th>2_</th><th>3_</th><th>4_</th><th>5_</th></tr>

    <tr><td rowspan="11">
          <b>n</b>
        </td><td align="center">
          <b>-5_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-5_</td><td align="center">15_</td><td align="center">-35_</td><td align="center">70_</td><td align="center">-126_</td></tr>

    <tr><td align="center">
          <b>-4_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-4_</td><td align="center">10_</td><td align="center">-20_</td><td align="center">35_</td><td align="center">-56_</td></tr>

    <tr><td align="center">
          <b>-3_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-3_</td><td align="center">6_</td><td align="center">-10_</td><td align="center">15_</td><td align="center">-21_</td></tr>

    <tr><td align="center">
          <b>-2_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-2_</td><td align="center">3_</td><td align="center">-4_</td><td align="center">5_</td><td align="center">-6_</td></tr>

    <tr><td align="center">
          <b>-1_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">-1_</td><td align="center">-1_</td><td align="center">-1_</td><td align="center">-1_</td><td align="center">-1_</td></tr>

    <tr><td align="center">
          <b>0_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td></tr>

    <tr><td align="center">
          <b>1_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">1_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td></tr>

    <tr><td align="center">
          <b>2_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">2_</td><td align="center">1_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td></tr>

    <tr><td align="center">
          <b>3_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">3_</td><td align="center">3_</td><td align="center">1_</td><td align="center">0_</td><td align="center">0_</td></tr>

    <tr><td align="center">
          <b>4_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">4_</td><td align="center">6_</td><td align="center">4_</td><td align="center">1_</td><td align="center">0_</td></tr>

    <tr><td align="center">
          <b>5_</b>
        </td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">0_</td><td align="center">1_</td><td align="center">5_</td><td align="center">10_</td><td align="center">10_</td><td align="center">5_</td><td align="center">1_</td></tr>

</table></dd></dl><p>For the<tt><span class="func">sqrt</span></tt>関数が成立する(A>=0_の場合):</p><pre class="box">
sqrt(A)*sqrt(A)&lt;=A

(sqrt(A)+1_)*(sqrt(A)+1_)>A
<span class="op">および</span></pre><p></p>
          <a name="types_rational">
        <h3>5.4合理的な</h3>
          </a>
        <p>型式<tt><span class="type">合理的な</span></tt>で表される有理数からなる<tt><a class="type" href="#types_integer">整数</a></tt>と<tt><a class="type" href="#types_integer">整数</a></tt>分母。 タイプの値<tt><span class="type">合理的な</span></tt>は有限で周期的な10進数である。 有理リテラルは存在しません。 もし<tt><span class="type">合理的な</span></tt>操作<a class="link" href="#errors_OVERFLOW_ERROR">あふれる</a>それは例外を持ち出す<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt>In<tt><a class="type" href="#types_integer">整数</a></tt>の計算では、オーバーフローは非常に大きな正または負の数でしか発生しない。 場所<tt><span class="type">合理的な</span></tt>計算小さな数でオーバーフローが起こる可能性がある。 広がるので大きな分母は簡単につくれる 例:<tt>1/1777+1/1999=3776/3552223</tt>その<tt><span class="type">合理的な</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">rational.s7i</span>&quot;</span></p><pre class="tt">
要素:

0;

1;
定数:

(0/1)
前置演算子:

アイデンティティ

符号を変える
インフィックス演算子:

追加

減算

掛け算

部門

分子と分母から
(左オペランドのタイプ:

右オペランドのタイプ:
)

電力
(
)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


1/1)

指定された精度で
(右オペランドの型:

結果のタイプ:

1/64

1/64

1/64

355/113

27/22

-1/2玉

1/0

-1/0

0/0

-1/2048
)

科学的表記で
(右オペランドの型:

結果のタイプ:

1/64

1/64

1/64

355/113

27/22

-1/2玉

1/0

-1/0

0/0

-1/2048

-0/1
)


(引数Aのタイプ:


3/5

5/4

1/3玉

679/550

22/7

11/13)
リレーション:


機能:

(A)絶対値


(引数Aのタイプ:

ラット(1)
1/1)


(引数Aのタイプ:

合理性(1)
1/1)


(引数Aのタイプ:

合理的(
3/5
合理的(
5/4
合理的(
1/3玉
合理的(
679/550
合理的(
22/7
合理的(
11/13)

(A)負の無限大への打切り
(結果の種類:

床(9/5)
1
floor(-1/1)
-2)

(A)正の無限大への切り上げ
(結果の種類:

ceil(6/5)
1
ceil(-1/1)
-1)

(A)ゼロ方向への打切り
(結果の種類:

trunc(9/5)
1
trunc(-1/1)
-1)

(A)ゼロに丸める
(結果の種類:

丸(1/2)
-1
丸(2/5)
0)

(A, B)ゼロに向けて小数精度で丸め
(Bの種類:

round10(1/4, 1)
-3/10
ラウンド10(2/5、0)
0/1)

10進法の表現で
(結果の種類:

str(1/3)
「0.(3)」)

分数で
(結果の種類:

fraction(rational(&quot;0.(3)&quot;))
&quot;1/3&quot;)

(A, B)最低2桁の数値。
(min(2/5, 1/2)
2/5)

(A, B)最大2つの数値。
(max(2/5, 1/2)
1/2)

(A, B)比較関数
(結果の種類:

比較(19/10、2/1)
-1
比較(26/5、26/5)
0
比較(8/1、79/10)
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
B分割コピー
(A/:=B
A:=A/B)

(A)値を無視(Ignore value)する
<span class="keywd">var</span><a class="type" href="#types_integer">整数</a>:numerator<span class="keywd">は</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:分母</a>は<span class="keywd">合理的な</span><span class="type">価値</span>既定値<span class="var">合理的な</span>+<span class="type">-</span>+<span class="op">-</span>*<span class="op">/</span>/<span class="op">作成</span>合理的な<span class="op">整数</span>整数<span class="op">**</span>合理的な<span class="op">**</span>整数<span class="op"></span>B<span class="type">:</span>ブール<a class="type" href="#types_integer">TRUE</a>a:b<a class="type" href="#types_integer">⇒</a>FALSE<span class="op">a:b</span>⇒<span class="type">合理的な</span><a class="type" href="#types_integer">conv</a>A変換<span class="op">整数</span>へ<span class="op">合理的な</span>整数<a class="type" href="#types_boolean">合理的な</a><span class="var">conv</span>1<b>⇒</b>指<span class="var">への変換</span>文字列<b>整数</b>文字列<span class="type">指</span>7<span class="op">⇒</span><a class="type" href="#types_integer">&quot;0.0156250&quot;</a>指<span class="type">4</span>⇒<a class="type" href="#types_integer"></a>&quot;0.0156&quot;<span class="type">指</span>2<span class="op">⇒</span><b>&quot;0.02&quot;</b>指<span class="op">6</span>⇒<a class="type" href="#types_string"></a>&quot;3.141593&quot;<a class="type" href="#types_integer">指</a>0<a class="type" href="#types_string">⇒</a><span class="op">「3」</span>指<b>1</b>⇒<span class="stri"></span>&quot;-1&quot;<span class="op">指</span>5<b>⇒</b><span class="stri">「インフィニティ」</span>指<span class="op">6</span>⇒<b></b>&quot;-インフィニティ&quot;<span class="stri">指</span>7<span class="op">⇒</span><b>「NaN」</b>指<span class="stri">3</span>⇒<span class="op"></span>&quot;0.000&quot;<b>sci</b>への変換<span class="stri">文字列</span>整数<span class="op">文字列</span>sci<b>4</b>⇒<span class="stri"></span>「1.5625e-2」<span class="op">sci</span>3<b>⇒</b><span class="stri">「1.563e-2」</span>sci<span class="op">2</span>⇒<b></b>「1.56e-2」<span class="stri">sci</span>6<span class="op">⇒</span><b>&quot;3.141593e+0&quot;</b>sci<span class="stri">0</span>⇒<span class="op"></span>&quot;3e+0&quot;<b>sci</b>1<span class="stri">⇒</span><span class="op">「-5.0e-1」</span>sci<a class="type" href="#types_string">5</a>⇒<a class="type" href="#types_integer"></a>「インフィニティ」<a class="type" href="#types_string">sci</a>6<span class="op">⇒</span><b>&quot;-インフィニティ&quot;</b>sci<span class="stri">7</span>⇒<span class="op"></span>「NaN」<b>sci</b>3<span class="stri">⇒</span><span class="op">「-4.883e-4」</span>sci<b>2</b>⇒<span class="stri"></span>&quot;0.00e+0&quot;<span class="op">合理的な</span><b>解析する</b>A変換<span class="stri">文字列</span>へ<span class="op">合理的な</span>文字列<b>合理的な</b><span class="stri">解析する</span><span class="op">&quot;3/5&quot;</span><b>⇒</b>合理的な<span class="stri"></span>解析する<span class="op"></span>&quot;1.25&quot;<b></b>⇒<span class="stri">合理的な</span><span class="op">解析する</span><b>「0.(3)」</b><span class="stri">⇒</span>合理的な<span class="op"></span>解析する<b></b>「1.23(45)」<span class="stri"></span>⇒<span class="op">合理的な</span><b>解析する</b><span class="stri">「3.(142857)」</span><span class="op">⇒</span>合理的な<b></b>解析する<span class="stri"></span>&quot;0.(846153)&quot;<span class="type"></span>⇒<span class="op">=</span><a class="type" href="#types_string">&lt;></a><span class="type">&lt;</span><a class="type" href="#types_string">&lt;=</a><span class="type">></span><span class="op">>=</span>abs<span class="stri">ネズミ</span>(ア)Conversion of<b>整数</b>へ<span class="type">合理的な</span>整数<span class="op">⇒</span>合理的な<span class="stri">(ア)Conversion of</span>整数<b>へ</b>合理的な<span class="type">整数</span>⇒<span class="op">合理的な</span>(ア)Conversion of<span class="stri">文字列</span>へ<b>合理的な</b>文字列<span class="type">&quot;3/5&quot;</span>)<span class="op">⇒</span>&quot;1.25&quot;<span class="stri">)</span>⇒<b>「0.(3)」</b>)<span class="type">⇒</span>「1.23(45)」<span class="op">)</span>⇒<span class="stri">「3.(142857)」</span>)<b>⇒</b>&quot;0.(846153)&quot;<span class="type">)</span>⇒<span class="op">床</span>整数<span class="stri">⇒</span>1, floor(1/1)<b>⇒</b>⇒<span class="op">-1、床(-9/5)</span>⇒<span class="op">天井</span>整数<span class="op">⇒</span>2, ceil(1/1)<span class="op">⇒</span>⇒<span class="op">-1, ceil(-6/5)</span>⇒<span class="op">切断する</span>整数<span class="func">⇒</span>1、trunc(1/1)<span class="func">⇒</span>⇒<a class="type" href="#types_integer">-1、trunc(-9/5)</a>⇒<span class="type">丸い</span>整数<a class="type" href="#types_integer">⇒</a>1、丸(-1/2)<b>⇒</b>⇒<span class="func">0、円形(-2/5)</span>⇒<a class="type" href="#types_integer">第10ラウンド</a>整数<span class="type">⇒</span>3/10、round10(-1/4, 1)<a class="type" href="#types_integer">⇒</a>⇒<b>0/1、丸(-2/5、0)</b>⇒<span class="func">str</span>(A)Convert to a<a class="type" href="#types_string">文字列</a>文字列<span class="type">⇒</span>端数<a class="type" href="#types_string">(A)Convert to a</a>文字列<span class="stri">文字列</span>⇒<b>分</b>⇒<span class="stri">最大</span>⇒<b>比べる</b>整数<span class="stri">⇒</span>⇒<b>⇒</b>hashCode<span class="stri">整数</span>+:=<b>⇒</b>-:=<span class="stri">⇒</span>*:=<b>⇒</b>/:=<span class="stri">⇒</span>無視する<b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p>すべての計算<tt><span class="type">合理的な</span></tt>数字は正確に計算されます。 (四捨五入なし)</p><p></p>
          <a name="types_bigRational">
        <h3>5.5 bigRational</h3>
          </a>
        <p>型式<tt><span class="type">bigRational</span></tt>で表される有理数からなる<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>と<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>分母。 タイプの値<tt><span class="type">bigRational</span></tt>は有限で周期的な10進数である。 BigRationalリテラルは存在しません。 しかし<tt><span class="type">bigRational</span></tt>操作がオーバーフローすることはできず<tt><span class="type">bigRational</span></tt>value. この場合、例外は<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt>を上げます。 その<tt><span class="type">bigRational</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">bigrat.s7i</span>&quot;</span></p><pre class="tt">
要素:

0_;

1_;
定数:

(0_/1_)
前置演算子:

アイデンティティ

符号を変える
インフィックス演算子:

追加

減算

掛け算

部門

分子と分母から
(左引数のタイプ:

右引数のタイプ:
)

電力
(
)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


1_/1_)


(引数Aのタイプ:


1_/1_)

指定された精度で
(右オペランドの型:

結果のタイプ:

1_/64_

1_/64_

1_/64_

355_/113_

22_/7_

-1_/2_

1_/0_

-1_/0_

0_/0_

-1_/2048_
)

科学的表記で
(右オペランドの型:

結果のタイプ:

1_/64_

1_/64_

1_/64_

355_/113_

22_/7_

-1_/2_

1_/0_

-1_/0_

0_/0_

-1_/2048_

-0_/1_
)


(引数Aのタイプ:


3_/5_

5_/4_

1_/3_

679_/550_

22_/7_

11_/13_)
リレーション:


機能:

(A)絶対値


(引数Aのタイプ:

ラット(1_)
1_/1_)


(引数Aのタイプ:

bigRational(1)
1_/1_)


(引数Aのタイプ:

bigRational(1_)
1_/1_)


(引数Aのタイプ:

bigRational(
3_/5_
bigRational(
5_/4_
bigRational(
1_/3_
bigRational(
679_/550_
bigRational(
22_/7_
bigRational(
11_/13_)

(A)負の無限大への打切り
(結果の種類:

床(9_/5_)
1_
床(-1_/1_)
-2_)

(A)正の無限大への切り上げ
(結果の種類:

ceil(6_/5_)
1_
ceil(-1_/1_)
-1_)

(A)ゼロ方向への打切り
(結果の種類:

trunc(9_/5_)
1_
trunc(-1_/1_)
-1_)

(A)ゼロに丸める
(結果の種類:

丸(1_/2_)
-1_
丸(2_/5_)
0_)

(A, B)ゼロに向けて小数精度で丸め
(Bの種類:

round10(1_/4_,1)
-3/10
round10(2_/5_,0)
0_/1_)

10進法の表現で
(結果の種類:

str(1_/3_)
「0.(3)」)

分数で
(結果の種類:

fraction(bigRational(&quot;0.(3)&quot;))
&quot;1/3&quot;)

(A, B)最低2桁の数値。
(最小(2/5、1/2)
2_/5_)

(A, B)最大2つの数値。
(max(2_/5_,1_/2_)
1_/2_)

(A, B)比較関数
(結果の種類:

比較(19_/10_、2_/1_)
-1
compare(26_/5_,26_/5_)
0
compare(8_/1_,79_/10_)
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
B分割コピー
(A/:=B
A:=A/B)

(A)値を無視(Ignore value)する
<span class="keywd">var</span><a class="type" href="#types_bigInteger">bigInteger</a>:numerator<span class="keywd">は</span>var<span class="keywd"></span>bigInteger<a class="type" href="#types_bigInteger">:分母</a>は<span class="keywd">bigRational</span><span class="type">価値</span>既定値<span class="var">bigRational</span>+<span class="type">-</span>+<span class="op">-</span>*<span class="op">/</span>/<span class="op">作成</span>bigRational<span class="op">bigInteger</span>bigInteger<span class="op">**</span>bigRational<span class="op">**</span>整数<span class="op"></span>B<span class="type">:</span>ブール<a class="type" href="#types_bigInteger">TRUE</a>a:b<a class="type" href="#types_bigInteger">⇒</a>FALSE<span class="op">a:b</span>⇒<span class="type">bigRational</span><a class="type" href="#types_integer">conv</a>A変換<span class="op">整数</span>へ<span class="op">bigRational</span>整数<a class="type" href="#types_boolean">bigRational</a><span class="var">conv</span>1<b>⇒</b>bigRational<span class="var"></span>conv<b>A変換</b>bigInteger<span class="type">へ</span>bigRational<span class="op">bigInteger</span>bigRational<a class="type" href="#types_integer"></a>conv<span class="type">1_</span>⇒<a class="type" href="#types_integer">指</a>への変換<span class="type">文字列</span>整数<span class="op">文字列</span>指<b>7</b>⇒<span class="type"></span>&quot;0.0156250&quot;<span class="op">指</span>4<a class="type" href="#types_bigInteger">⇒</a><span class="type">&quot;0.0156&quot;</span>指<a class="type" href="#types_bigInteger">2</a>⇒<span class="type"></span>&quot;0.02&quot;<span class="op">指</span>6<b>⇒</b><span class="op">&quot;3.141593&quot;</span>指<a class="type" href="#types_string">0</a>⇒<a class="type" href="#types_integer"></a>「3」<a class="type" href="#types_string">指</a>1<span class="op">⇒</span><b>&quot;-1&quot;</b>指<span class="stri">5</span>⇒<span class="op"></span>「インフィニティ」<b>指</b>6<span class="stri">⇒</span><span class="op">&quot;-インフィニティ&quot;</span>指<b>7</b>⇒<span class="stri"></span>「NaN」<span class="op">指</span>3<b>⇒</b><span class="stri">&quot;0.000&quot;</span>sci<span class="op">への変換</span>文字列<b>整数</b>文字列<span class="stri">sci</span>4<span class="op">⇒</span><b>「1.5625e-2」</b>sci<span class="stri">3</span>⇒<span class="op"></span>「1.563e-2」<b>sci</b>2<span class="stri">⇒</span><span class="op">「1.56e-2」</span>sci<b>6</b>⇒<span class="stri"></span>&quot;3.141593e+0&quot;<span class="op">sci</span>0<b>⇒</b><span class="stri">&quot;3e+0&quot;</span>sci<span class="op">1</span>⇒<b></b>「-5.0e-1」<span class="stri">sci</span>5<span class="op">⇒</span><a class="type" href="#types_string">「インフィニティ」</a>sci<a class="type" href="#types_integer">6</a>⇒<a class="type" href="#types_string"></a>&quot;-インフィニティ&quot;<span class="op">sci</span>7<b>⇒</b><span class="stri">「NaN」</span>sci<span class="op">3</span>⇒<b></b>「-4.883e-4」<span class="stri">sci</span>2<span class="op">⇒</span><b>&quot;0.00e+0&quot;</b>bigRational<span class="stri"></span>解析する<span class="op">A変換</span>文字列<b>へ</b>bigRational<span class="stri">文字列</span>bigRational<span class="op"></span>解析する<b></b><span class="stri">&quot;3/5&quot;&lt;/span</span>⇒<span class="op">bigRational</span><b>解析する</b><span class="stri">&quot;1.25&quot;</span><span class="op">⇒</span>bigRational<b></b>解析する<span class="stri"></span>「0.(3)」<span class="op"></span>⇒<b>bigRational</b><span class="stri">解析する</span><span class="op">「1.23(45)」</span><b>⇒</b>bigRational<span class="stri"></span>解析する<span class="op"></span>「3.(142857)」<b></b>⇒<span class="stri">bigRational</span><span class="op">解析する</span><b>&quot;0.(846153)&quot;</b><span class="stri">⇒</span>=<span class="type"></span>&lt;><span class="op"></span>&lt;<a class="type" href="#types_string"></a>&lt;=<span class="type"></span>><a class="type" href="#types_string"></a>>=<span class="type">abs</span>ネズミ<span class="op">(ア)Conversion of</span>bigInteger<span class="stri">bigRational<b>bigInteger</b>⇒<span class="type">bigRational</span>(ア)Conversion of<span class="op">整数</span>へ<span class="stri">bigRational</span>整数<b>⇒</b>bigRational<span class="type">(ア)Conversion of</span>bigInteger<span class="op">へ</span>bigRational<span class="stri">bigInteger</span>⇒<b>bigRational</b>(ア)Conversion of<span class="type">文字列</span>へ<span class="op">bigRational</span>文字列<span class="stri">&quot;3/5&quot;</span>)<b>⇒</b>&quot;1.25&quot;<span class="type">)</span>⇒<span class="op">「0.(3)」</span>)<span class="stri">⇒</span>「1.23(45)」<b>)</b>⇒<span class="type">「3.(142857)」</span>)<span class="op">⇒</span>&quot;0.(846153)&quot;<span class="stri">)</span>⇒<b>床</b>bigInteger<span class="op">⇒</span>1_,floor(1_/1_)<span class="op">⇒</span>⇒<span class="op">-1_,floor(-9_/5_)</span>⇒<span class="op">天井</span>bigInteger<span class="op">⇒</span>2_,ceil(1_/1_)<span class="op">⇒</span>⇒<span class="func">-1_,ceil(-6_/5_)</span>⇒<span class="func">切断する</span>bigInteger<a class="type" href="#types_bigInteger">⇒</a>1_,trunc(1_/1_)<span class="type">⇒</span>⇒<a class="type" href="#types_bigInteger">-1_,trunc(-9_/5_)</a>⇒<b>丸い</b>bigInteger<span class="func">⇒</span>1_、円形(-1_/2_)<a class="type" href="#types_integer">⇒</a>⇒<span class="type">0_,round(-2_/5_)</span>⇒<a class="type" href="#types_integer">第10ラウンド</a>整数<b>⇒</b>3_/10_,round10(-1_/4_,1)<span class="func">⇒</span>⇒<a class="type" href="#types_bigInteger">0_/1_,round(-2_/5_,0)</a>⇒<span class="type">str</span>(A)Convert to a<a class="type" href="#types_bigInteger">文字列</a>文字列<b>⇒</b>端数<span class="func">(A)Convert to a</span>文字列<a class="type" href="#types_string">文字列</a>⇒<span class="type">分</span>⇒<a class="type" href="#types_string">最大</a>⇒<span class="stri">比べる</span>整数<b>⇒</b>⇒<span class="stri">⇒</span>hashCode<b>整数</b>+:=<span class="stri">⇒</span>-:=<b>⇒</b>*:=<span class="stri">⇒</span>/:=<b>⇒</b>無視する<span class="stri"></span><b></b><span class="stri"></span><b></b><span class="func"></span><a class="type" href="#types_bigInteger"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_bigInteger"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_bigInteger"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_bigInteger"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p>すべての計算<tt><span class="type">bigRational</span></tt>数字は正確に計算されます。 (四捨五入なし)</p>
          <a name="types_float">
        <h3>5.6 float</h3>
          </a>
        <p>型式<tt><span class="type">浮かぶ</span></tt>倍精度浮動小数点数で構成される。<a class="link" href="#tokens_Float_literals">Floatリテラル</a>base 10を使用し、小数点を含みます。 小数点の前後には1桁以上必要です。 Eまたはeで導入される指数部は、オプションです。 指数は符号付きにできますが、仮数は符号なしにできません。 リテラルには符号がなく、+または-は単項演算子です。 例<tt><span class="type">浮かぶ</span></tt>リテラルは次のとおりです:</p><pre class="box">3.14159265358979
1.0E-12
0.1234
</pre><p>機能<tt><span class="func">str</span></tt>そしてオペレータ<tt><span class="op">指</span></tt>および<tt><span class="op">解析する</span></tt>符号付きの浮動小数点リテラルを作成して受け入れます。 基本<tt><span class="type">浮かぶ</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">float.s7i</span>&quot;</span>三角関数、その他の数学関数はLibraryで定義されています。<span class="stri">&quot;<span class="lib">math.s7i</span>&quot;</span></p><pre class="tt">
定数:

(0.0)

正の無限大

非数

数学定数π

オイラー数
前置演算子:

アイデンティティ

符号を変える
インフィックス演算子:

追加

減算

掛け算

部門
(A/0.0
A>0.0のインフィニティ
A/0.0
-A&lt;0.0の場合、無限
0.0/0.0
NaN)

電力
(A**BはA>0.0
A**BはA&lt;0.0で、Bが整数の場合に使用できます。
A**B
A&lt;0.0かつBが整数でない場合のNaN。
A**0.0
1.0
NaN**0.0
1.0
NaN**B
B&lt;>0.0の場合のNaN
0.0**B
B>0.0の場合、0.0
0.0**0.0
1.0
0.0**B
B&lt;0.0の無限大
(-0.0)**B
-B&lt;0.0および奇数(B)の場合は無限大
1.0**B
1.0
1.0**NaN
1.0
A**NaN
A&lt;>1.0の場合のNaN)

電力
(右オペランドの型:

A**BはA>0.0でOKです。
A**BはA&lt;0.0でOKです。
A**0
1.0
NaN**0
1.0
NaN**B
B&lt;>0の場合のNaN
0.0**B
B>0の場合、0.0
0.0**0
1.0
0.0**B
B&lt;0の場合は無限大
(-0.0)**B
-B&lt;0と奇数(B)の無限大
A**B
B&lt;0の場合、1.0/A**(-B)
A
Bシフトレフト
(引数Bのタイプ:

A&lt;&lt;B
A*2.0**B
A&lt;&lt;0
A
0.0≦B
0.0)
A
B算術右シフト
(引数Bのタイプ:

A>>B
A/2.0**B
A>>0
A
0.0>>B
0.0)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


1.0)

指定された精度で
(右オペランドの型:

結果のタイプ:

0.012345

1.2468

0.125

0.375

インフィニティ

-インフィニティ

NaN
)

科学的表記で
(右オペランドの型:

結果のタイプ:

0.012345

1.2468

3.1415

0.125

0.375

インフィニティ

-インフィニティ

NaN

-0.004
)

科学浮動小数点の指数部の桁数を設定します。
(左オペランドのタイプ:

右オペランドのタイプ:

結果のタイプ:

0.012345

1.2468e15

3.1415

0.125

0.375

インフィニティ

-インフィニティ

NaN

-0.004
)


(引数Aのタイプ:


1.2345

1234500.0

-1.0e-308

1.0

2.0

0.5項

-0.25

インフィニティ

-インフィニティ

NaN

)
リレーション:


機能:

(A)絶対値


(引数Aのタイプ:

flt(1)
1.0)


(引数Aのタイプ:

float(1)
1.0)


(引数Aのタイプ:

float(
1.2345
float(
1234500.0
float(
-1.0e-308
float(
1.0
float(
2.0
float(
0.5項
float(
-0.25
float(
インフィニティ
float(
-インフィニティ
float(
NaN
float(
)

(A)負の無限大への打切り
(floor(1.8)
1.0
床(-1.0)
-2.0
床(0.9)
-1.0)

(A)正の無限大への切り上げ
(ceil(1.2)
1.0
ceil(-1.8)
-1.0
ceil(0.1)
0.0)

(A)ゼロ方向への打切り
(結果の種類:

trunc(1.8)
1
trunc(-1.8)
-1
trunc(0.9)
0)

(A)ゼロに丸める
(結果の種類:

丸(1.5)
-2
round(0.5)
-1
丸(0.4)
0)


(結果の種類:

str(インフィニティ)

str(-Infinity)

str(NaN)
)

(A)Aが非数かどうかを調べる

(A)Aが負のゼロ(-0.0)かどうかを調べる

(A)Aが+0.0か確認

(A)サイン(Sine)

(A)コサイン(Cosine)

(A)接線

(A)指数関数

(x)-1.0

(A)自然対数
(log(A)はA>0.0の場合はOKです。
log(1.0)
0.0
log(0.0)
-インフィニティ
log(-1.0)
NaN)

(1.0+x)
(log1p(A)はA>-1.0であれば問題ありません。
log1p(0.0)
0.0
log1p(-1.0)
-インフィニティ
log1p(-2.0)
NaN)

(A)底が10の対数
(log10(A)はA>0.0の場合はOKです。
log10(1.0)
0.0
log10(0.0)
-インフィニティ
log10(-1.0)
NaN)

(A)2を底とする対数
(log2(A)はA>0.0であれば問題ありません。
log2(1.0)
0.0
log2(0.0)
-インフィニティ
log2(-1.0)
NaN)

(A)平方根
(sqrt(A)はA>=0.0の場合は有効です。
sqrt(-1.0)
NaN)

(A)逆正弦
(asin(A)はA>=-1.0およびA&lt;=1.0で使用できます。
asin(2.0)
NaN)

(A)逆余弦
(acos(A)はA>-1.0およびA&lt;=1.0で使用できます。
acos(2.0)
NaN)

(A)逆タンジェント

(A, B)A/Bの逆タンジェント

(A)双曲線正弦(ハイパボリックサイン)

(A)双曲線コサイン(Hyperbolic cosine)

(A)双曲線正接(Hyperbolic tangent)

(A, B)[A, B]の範囲の乱数
ランダム値は一様分布です。
(rand(A, B)は
A&lt;=rand(A, B)
rand(A, B)&lt;Bが成立する。
rand(A, A)

rand(1.0, 0.0)
)

(A, B)最低2桁の数値。
(min(2.5, 4.5)
2.5)

(A, B)最大2つの数値。
(max(2.5, 4.5)
4.5)

(A, B)比較関数
(結果の種類:

compare(1.9, 2.1)
-1
compare(5.3, 5.3)
0
compare(7.8, 7.7)
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
B分割コピー
(A/:=B
A:=A/B)

(A)値を無視(Ignore value)する
<span class="type">浮かぶ</span><span class="var">価値</span>既定値<span class="type">浮かぶ</span>インフィニティ<span class="var">NaN</span>PI<span class="var">電</span>+<span class="var">-</span>+<span class="var">-</span>*<span class="op">/</span>⇒<span class="op">⇒</span>⇒<span class="op">**</span>⇒<span class="op">⇒</span>⇒<span class="op">⇒</span>⇒<span class="op">⇒</span>⇒<b>⇒</b>⇒<b>⇒</b>⇒<b>**</b>整数<span class="op">⇒</span>⇒<b>⇒</b>⇒<b>⇒</b>⇒<b>⇒</b>⇒<b>&lt;&lt;</b>整数<b>⇒</b>⇒<b>⇒</b>>><b>整数</b>⇒<b>⇒</b>⇒<b></b>B<b>:</b>ブール<b>TRUE</b>a:b<span class="op">⇒</span>FALSE<a class="type" href="#types_integer">a:b</a>⇒<b>浮かぶ</b><b>conv</b>A変換<b>整数</b>へ<b>浮かぶ</b>整数<b>浮かぶ</b><b>conv</b>1<b>⇒</b>指<b>への変換</b>文字列<span class="op">整数</span>文字列<a class="type" href="#types_integer">指</a>4<b>⇒</b><b>&quot;0.0123&quot;</b>指<b>2</b>⇒<span class="op"></span>&quot;1.25&quot;<a class="type" href="#types_integer">指</a>2<b>⇒</b><b>&quot;0.12&quot;</b>指<b>2</b>⇒<span class="op"></span>&quot;0.38&quot;<span class="op">指</span>A<a class="type" href="#types_boolean">⇒</a><span class="var">「インフィニティ」</span>指<b>A</b>⇒<span class="var"></span>&quot;-インフィニティ&quot;<b>指</b>A<span class="type">⇒</span><span class="op">「NaN」</span>sci<a class="type" href="#types_integer">への変換</a>文字列<span class="type">整数</span>文字列<a class="type" href="#types_integer">sci</a>4<span class="type">⇒</span><span class="op">「1.2345e-2」</span>sci<b>2</b>⇒<span class="op"></span>&quot;1.25e+0&quot;<a class="type" href="#types_string">sci</a>0<a class="type" href="#types_integer">⇒</a><a class="type" href="#types_string">&quot;3e+0&quot;</a>sci<span class="op">1</span>⇒<b></b>「1.2e-1」<span class="stri">sci</span>1<span class="op">⇒</span><b>「3.8e-1」</b>sci<span class="stri">5</span>⇒<span class="op"></span>「インフィニティ」<b>sci</b>6<span class="stri">⇒</span><span class="op">&quot;-インフィニティ&quot;</span>sci<b>7</b>⇒<span class="stri"></span>「NaN」<span class="op">sci</span>2<b>⇒</b><span class="stri">「-4.00e-3」</span>exp<span class="op">文字列</span>整数<b>文字列</b>sci<span class="stri">4</span>exp<span class="op">2</span>⇒<b></b>「1.2345e-02」<span class="stri">sci</span>2<span class="op">exp</span>1<a class="type" href="#types_string">⇒</a><a class="type" href="#types_integer">&quot;1.25e+15&quot;</a>sci<a class="type" href="#types_string">0</a>exp<span class="op">3</span>⇒<b></b>「3e+000」<span class="stri">sci</span>1<span class="op">exp</span>2<b>⇒</b><span class="stri">「1.2e-01」</span>sci<span class="op">1</span>exp<b>2</b>⇒<span class="stri"></span>「3.8e-01」<span class="op">sci</span>5<b>exp</b>2<span class="stri">⇒</span><span class="op">「インフィニティ」</span>sci<b>6</b>exp<span class="stri">2</span>⇒<span class="op"></span>&quot;-インフィニティ&quot;<b>sci</b>7<span class="stri">exp</span>2<span class="op">⇒</span><b>「NaN」</b>sci<span class="stri">2</span>exp<span class="op">2</span>⇒<b></b>&quot;-4.00e-03&quot;<span class="stri">浮かぶ</span><span class="op">解析する</span>A変換<b>文字列</b>へ<span class="stri">浮かぶ</span>文字列<span class="op">浮かぶ</span><a class="type" href="#types_string">解析する</a><a class="type" href="#types_integer">&quot;1.2345&quot;</a><a class="type" href="#types_string">⇒</a>浮かぶ<span class="op"></span>解析する<span class="op"></span>&quot;1.2345e6&quot;<b></b>⇒<span class="stri">浮かぶ</span><span class="op">解析する</span><span class="op">&quot;-1.0e-308&quot;</span><b>⇒</b>浮かぶ<span class="stri"></span>解析する<span class="op"></span>「1」<span class="op"></span>⇒<b>浮かぶ</b><span class="stri">解析する</span><span class="op">「2.」</span><span class="op">⇒</span>浮かぶ<b></b>解析する<span class="stri"></span>5<span class="op"></span>⇒<span class="op">浮かぶ</span><b>解析する</b><span class="stri">&quot;-.25&quot;</span><span class="op">⇒</span>浮かぶ<span class="op"></span>解析する<b></b>「インフィニティ」<span class="stri"></span>⇒<span class="op">浮かぶ</span><span class="op">解析する</span><b>&quot;-インフィニティ&quot;</b><span class="stri">⇒</span>浮かぶ<span class="op"></span>解析する<span class="op"></span>「NaN」<b></b>⇒<span class="stri">浮かぶ</span><span class="op">解析する</span><span class="op">「3.14 PI」</span><b>⇒</b>例外<span class="stri">範囲エラー</span>=<span class="type"></span>&lt;><span class="op"></span>&lt;<a class="type" href="#types_string"></a>&lt;=<span class="type"></span>><a class="type" href="#types_string"></a>>=<span class="type">abs</span>flt<span class="op">(ア)Conversion of</span>整数<span class="stri">へ</span>浮かぶ<b>整数</b>⇒<span class="type">浮かぶ</span>(ア)Conversion of<span class="op">整数</span>へ<span class="stri">浮かぶ</span>整数<b>⇒</b>浮かぶ<span class="type">(ア)Conversion of</span>文字列<span class="op">へ</span>浮かぶ<span class="stri">文字列</span>&quot;1.2345&quot;<b>)</b>⇒<span class="type">&quot;1.2345e6&quot;</span>)<span class="op">⇒</span>&quot;-1.0e-308&quot;<span class="stri">)</span>⇒<b>「1」</b>)<span class="type">⇒</span>「2.」<span class="op">)</span>⇒<span class="stri">5</span>)<b>⇒</b>&quot;-.25&quot;<span class="type">)</span>⇒<span class="op">「インフィニティ」</span>)<span class="stri">⇒</span>&quot;-インフィニティ&quot;<b>)</b>⇒<span class="type">「NaN」</span>)<span class="op">⇒</span>「3.14 PI」<span class="stri">)</span>⇒<b>例外</b>範囲エラー<span class="type">床</span>⇒<span class="op">1.0, floor(1.0)</span>⇒<span class="stri">⇒</span>-1.0、床(-1.2)<b>⇒</b>⇒<span class="type">0.0, floor(-0.1)</span>⇒<span class="op">天井</span>⇒<span class="stri">2.0, ceil(1.0)</span>⇒<b>⇒</b>-1.0, ceil(-1.0)<span class="type">⇒</span>⇒<span class="op">1.0, ceil(-0.9)</span>⇒<span class="stri">切断する</span>整数<b>⇒</b>1, trunc(1.0)<span class="type">⇒</span>⇒<span class="op">-1, trunc(-1.0)</span>⇒<span class="stri">⇒</span>0, trunc(-0.9)<b>⇒</b>丸い<a class="exception" href="#errors_RANGE_ERROR">整数</a>⇒<span class="op">2、円形(-1.5)</span>⇒<span class="op">⇒</span>1、丸め(-0.5)<span class="op">⇒</span>⇒<span class="op">0、丸め(-0.4)</span>⇒<span class="op">str</span>(A)〜への変換<span class="op">文字列</span>文字列<span class="func">⇒</span><span class="func">「インフィニティ」</span>⇒<a class="type" href="#types_integer"></a>&quot;-インフィニティ&quot;<span class="type">⇒</span><a class="type" href="#types_integer">「NaN」</a>isNaN<b>isNegativeZero</b>isPositiveZero<span class="func">罪</span>cos<a class="type" href="#types_integer">日焼けする</a>exp<span class="type">expm1</span>(A)計算<a class="type" href="#types_integer">exp</a>丸太<b>⇒</b>⇒<span class="func">⇒</span>log1p<a class="type" href="#types_string">(A)計算</a>丸太<span class="type">⇒</span>⇒<a class="type" href="#types_string">⇒</a>log10<span class="stri">⇒</span>⇒<b>⇒</b>log2<span class="stri">⇒</span>⇒<b>⇒</b>sqrt<span class="stri">⇒</span>asin<b>⇒</b>acos<span class="stri">⇒</span>アタン<b>atan2</b>シン<span class="stri">cosh</span>タン<b>ランド</b>および<span class="stri">⇒</span>例外<b>範囲エラー</b>⇒<span class="stri">例外</span>範囲エラー<b>分</b>⇒<span class="stri">最大</span>⇒<b>比べる</b>整数<span class="stri">⇒</span>⇒<b>⇒</b>hashCode<span class="stri">整数</span>+:=<b>⇒</b>-:=<span class="stri">⇒</span>*:=<b>⇒</b>/:=<a class="exception" href="#errors_RANGE_ERROR">⇒</a>無視する<span class="func"></span><b></b><b></b><b></b><b></b><b></b><b></b><span class="func"></span><b></b><b></b><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><b></b><b></b><b></b><span class="func"></span><span class="func"></span><b></b><b></b><b></b><span class="func"></span><b></b><b></b><b></b><span class="func"></span><b></b><b></b><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="op"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><b></b><b></b><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_complex">
        <h3>5.7複合体</h3>
          </a>
        <p>型式<tt><span class="type">複雑なさま</span></tt>で表される複素数からなる<tt><a class="type" href="#types_float">浮かぶ</a></tt>実数部と<tt><a class="type" href="#types_float">浮かぶ</a></tt>虚数部分 複合リテラルは存在しません。 その<tt><span class="type">複雑なさま</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">complex.s7i</span>&quot;</span></p><pre class="tt">
要素:

0.0;

0.0;
定数:

(complex(0.0))
前置演算子:

アイデンティティ

符号を変える

複素共役
インフィックス演算子:

追加

減算

掛け算

部門
(A/複合体(0.0)
complex(NaN, NaN))

電力
(右オペランドの型:

A**BはA>complex(0.0)で使用できます。
A**BはA&lt;complex(0.0)でOKです。
A**0
complex(1.0)
複合体(0.0)**B
B>0の場合は複素数(0.0)
complex(0.0)**0
complex(1.0)
複合体(0.0)**B
complex(Infinity, NaN)(B&lt;0の場合)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


complex(float(A)))


(引数Aのタイプ:


複合(A))

指定された精度で
(右オペランドの型:

結果のタイプ:

複雑な(3.1415)
)

科学的表記で
(右オペランドの型:

結果のタイプ:

複雑な(3.1415)
)


(引数Aのタイプ:
)
リレーション:


機能:

(A)絶対値
(結果の種類:
)

(A)絶対値の2乗
(結果の種類:
)

(A)引数(=Aの極形の角度)
(結果の種類:
)

数の実部と虚部
(引数Aのタイプ:

引数Bの型:
)

実数部分からの数
(引数Aのタイプ:
)

実数部分からの数
(引数Aのタイプ:
)

極座標からの数
(引数Aのタイプ:

引数Bの型:
)


(結果の種類:

str(complex(1.125))
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A+:=B
A:=A+B)
A
B減分AをBで
(A-:=B
A:=A-B)
A
B増数コピー
(A*:=B
A:=A×B)
A
B分割コピー
(A/:=B
A:=A/B)

(A)値を無視(Ignore value)する
<span class="keywd">var</span><a class="type" href="#types_float">浮かぶ</a>:re<span class="keywd">は</span>var<span class="keywd"></span>浮かぶ<a class="type" href="#types_float">:im</a>は<span class="keywd">複雑なさま</span><span class="type">価値</span>既定値<span class="var">複雑なさま</span>+<span class="type">-</span>コージ<span class="op">+</span>-<span class="op">*</span>/<span class="op">⇒</span>**<span class="op">整数</span>⇒<span class="op">⇒</span>⇒<span class="op">⇒</span><span class="op">B</span>:<b>ブール</b>TRUE<span class="op">a:b</span>⇒<a class="type" href="#types_integer">FALSE</a>a:b<b>⇒</b>複雑なさま<b></b>conv<b>A変換</b>整数<b>へ</b>複雑なさま<span class="op">整数</span>複雑なさま<span class="op"></span>conv<a class="type" href="#types_boolean">A</a>⇒<span class="var">複雑なさま</span><b>conv</b>A変換<span class="var">浮かぶ</span>へ<b>複雑なさま</b>浮かぶ<span class="type">複雑なさま</span><span class="op">conv</span>A<a class="type" href="#types_integer">⇒</a>指<span class="type">への変換</span>文字列<a class="type" href="#types_integer">整数</a>文字列<span class="type">指</span>2<span class="op">⇒</span><b>&quot;3.14+0.00i&quot;</b>sci<span class="type">への変換</span>文字列<span class="op">整数</span>文字列<a class="type" href="#types_float">sci</a>2<span class="type">⇒</span><a class="type" href="#types_float">&quot;3.14e+0+0.00e+0i&quot;</a>複雑なさま<span class="type"></span>解析する<span class="op">A変換</span>文字列<b>へ</b>複雑なさま<span class="op">文字列</span>=<a class="type" href="#types_string"></a>&lt;><a class="type" href="#types_integer">abs</a>浮かぶ<a class="type" href="#types_string">sqrAbs</a>浮かぶ<span class="op">arg</span>浮かぶ<b>複雑なさま</b>(A, B)Return a<span class="stri">複雑なさま</span>浮かぶ<span class="op">浮かぶ</span>複雑なさま<a class="type" href="#types_string">(A)aを返す</a>複雑なさま<a class="type" href="#types_integer">浮かぶ</a>複雑なさま<a class="type" href="#types_string">(A)aを返す</a>複雑なさま<span class="op">整数</span>極の<b>(A, B)Return a</b>複雑なさま<span class="stri">浮かぶ</span>浮かぶ<span class="type">str</span>(A)〜への変換<span class="op">文字列</span>文字列<a class="type" href="#types_string">⇒</a><span class="type">&quot;1.125+0.0i&quot;</span>比べる<a class="type" href="#types_string">整数</a>hashCode<span class="op">整数</span>+:=<span class="op">⇒</span>-:=<span class="func">⇒</span>*:=<a class="type" href="#types_float">⇒</a>/:=<span class="func">⇒</span>無視する<a class="type" href="#types_float"></a><span class="func"></span><a class="type" href="#types_float"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_float"></a><a class="type" href="#types_float"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_float"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_float"></a><a class="type" href="#types_float"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><b></b><span class="stri"></span><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><span class="op"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_char">
        <h3>5.8文字</h3>
          </a>
        <p>型式<tt><span class="type">char</span></tt>に、UTF-32でエンコードされたUnicode文字を示します。 ソースファイルa<a class="link" href="#tokens_Character_literals">文字直定数</a>は、UTF-8エンコードのUnicode文字で、一重引用符で囲んで記述します。<a name="types_escape_sequences"></a>印刷できない文字や特定の印刷可能な文字を表すために、次のエスケープシーケンスを使用できます。</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>警告音</td> <td width="20"></td><td>BEL</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\a</span>
          </tt>
        </td></tr>
    <tr><td>バックスペース</td> <td width="20"></td><td>BS</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\b</span>
          </tt>
        </td></tr>
    <tr><td>逃げる</td> <td width="20"></td><td>ESC</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\e</span>
          </tt>
        </td></tr>
    <tr><td>フォームフィード</td> <td width="20"></td><td>FF</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\f</span>
          </tt>
        </td></tr>
    <tr><td>改行</td> <td width="20"></td><td>NL(LF)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\n</span>
          </tt>
        </td></tr>
    <tr><td>復帰</td> <td width="20"></td><td>CR</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\r</span>
          </tt>
        </td></tr>
    <tr><td>水平タブ</td> <td width="20"></td><td>HT</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\t</span>
          </tt>
        </td></tr>
    <tr><td>垂直タブ</td> <td width="20"></td><td>心室頻拍</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\v</span>
          </tt>
        </td></tr>
    <tr><td>バックスラッシュ</td> <td width="20"></td><td>(\)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\\</span>
          </tt>
        </td></tr>
    <tr><td>アポストロフィ</td> <td width="20"></td><td>(&#39;)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\&#39;</span>
          </tt>
        </td></tr>
    <tr><td>ダブルクオート</td> <td width="20"></td><td>(&quot;)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\&quot;</span>
          </tt>
        </td></tr>
    <tr><td>A制御</td> <td width="20"></td><td></td> <td width="20"></td><td>
          <tt>
            <span class="stri">\A</span>
          </tt>
        </td></tr>
    <tr><td> </td></tr>
    <tr><td>Ctrl+Z</td> <td width="20"></td><td></td> <td width="20"></td><td>
          <tt>
            <span class="stri">\Z</span>
          </tt>
        </td></tr>
</table></dd></dl><p>さらに、次のエスケープシーケンスを使用することもできます。</p><ul>
    <li>整数リテラルとセミコロンが後に続くバックスラッシュは、指定した序数を持つ文字として解釈されます。 以下のように書かれていない限り、整数リテラルは10進数として解釈されることに注意してください。<a class="link" href="#types_based_integer">基底付き整数</a></li>
</ul><p>文字リテラルの例を以下に示します。</p><pre class="box">


<span class="stri">&#39;a&#39;</span><span class="stri">「」</span><span class="stri">&#39;\n&#39;</span><span class="stri">&#39;!&#39;</span><span class="stri">&#39;\\&#39;</span><span class="stri">&#39;2&#39;</span><span class="stri">&quot;&quot;&quot;</span><span class="stri">&#39;\&quot;&#39;</span><span class="stri">「」</span><span class="stri">&#39;\8;&#39;</span></pre><p>ソースファイルでASCII(Unicodeのサブセット)を超える文字を使用するには、エディタがUTF-8エンコード文字を使用していることを確認してください。 その<tt><span class="type">char</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">char.s7i</span>&quot;</span></p><pre class="tt">
定数:

)
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


&#39;A&#39;)


(引数Aのタイプ:
)
リレーション:


機能:

(A)序数
(結果の種類:
)

(A)序数
(結果の種類:
)


(引数のタイプ:
)


(引数のタイプ:
)


(引数Aのタイプ:
)

(ア)承継人
(succl(A)
chr(succc(ord(A))))

①前任者
(pred(A)
chr(pred(ord(A))))


(結果の種類:

str(
)

(A)直定数化
(結果の種類:

リテラル(
)

(A)大文字への変換
(upper(

上部(
)

(A)小文字変換
(lower(

下(
)

アルファベットのUnicode文字か
(isLetter(

isLetter(

isLetter(

isLetter(

isLetter(

isLetter(KEY_LEFT)

isLetter(
)

Unicode文字が占める画面列数。
(幅(
0
幅(
0
幅(KEY_LEFT)
0
幅(
0)
幅(
1
幅(
2)

(A, B)[A, B]の範囲のランダム文字
ランダム値は一様分布です。
(rand(A, B)は、次のようなランダムな文字を返します。
A&lt;=rand(A, B)
rand(A, B)&lt;=Bが成立する。
rand(A, A)
A
ランド(
)

(A, B)比較関数
(結果の種類:

比較(
-1
比較(
0
比較(
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)インクリメント
(incr(A)
A:=succ(A))

(A)減分
(decr(A)
A:=pred(A))

(A)値を無視(Ignore value)する
<span class="type">char</span><span class="var">価値</span>既定値<span class="type">char</span>(<span class="stri">「」</span><span class="op">B</span>:<span class="op">ブール</span>TRUE<a class="type" href="#types_boolean">a:b</a>⇒<span class="var">FALSE</span>a:b<b>⇒</b>char<span class="var"></span>conv<b>A変換</b>整数<span class="type">へ</span>char<span class="op">整数</span>char<a class="type" href="#types_integer"></a>conv<span class="type">65</span>⇒<a class="type" href="#types_integer">char</a><span class="type">解析する</span>A変換<span class="op">文字列</span>へ<b>char</b>文字列<span class="type">=</span><span class="op">&lt;></span><a class="type" href="#types_string">&lt;</a><span class="type">&lt;=</span><a class="type" href="#types_string">></a><span class="op">>=</span>ord<span class="op">整数</span>整数<span class="op">整数</span>chr<span class="op">(ア)Conversion of</span>整数<span class="op">へ</span>char<span class="op">整数</span>char<span class="func">(ア)Conversion of</span>整数<a class="type" href="#types_integer">へ</a>char<span class="func">整数</span>char<a class="type" href="#types_integer">(ア)Conversion of</a>文字列<span class="func">へ</span>char<a class="type" href="#types_integer">文字列</a>水<span class="type">⇒</span>pred<a class="type" href="#types_integer">⇒</a>str<span class="func">(A)〜への変換</span>文字列<a class="type" href="#types_integer">文字列</a>「A」<span class="type">)</span>⇒<a class="type" href="#types_integer"></a>「A」<span class="func">文字通りの</span>文字列<a class="type" href="#types_string">「A」</a>)<span class="type">⇒</span><a class="type" href="#types_string">「A」</a>上<span class="func">「A」</span>)<b>⇒</b><span class="func">「A」</span>&#39;z&#39;<b>)</b>⇒<span class="func"></span>「Z」<a class="type" href="#types_string">下げる</a>「A」<a class="type" href="#types_string">)</a>⇒<span class="stri"></span>&#39;a&#39;<b>&#39;z&#39;</b>)<span class="stri">⇒</span><span class="func">&#39;z&#39;</span>isLetter<a class="type" href="#types_string">「A」</a>)<span class="stri">⇒</span><b>TRUE</b>&#39;\16#4e2d;&#39;<span class="stri">)</span>⇒<span class="func"></span>TRUE<span class="stri">&#39;4&#39;</span>)<b>⇒</b><span class="stri">FALSE</span>&#39;+&#39;<span class="stri">)</span>⇒<b></b>FALSE<span class="stri">&#39;\t&#39;</span>)<span class="func">⇒</span><span class="stri">FALSE</span>⇒<b></b>FALSE<span class="stri">ファイルの終り</span>)<span class="stri">⇒</span><b>FALSE</b>横<span class="stri">&#39;\n&#39;</span>)<span class="func">⇒</span>&#39;\t&#39;<span class="stri">)</span>⇒<b>⇒</b>ファイルの終り<span class="var">)</span>⇒<span class="stri">「A」</span>)<b>⇒</b>&#39;\16#4e2d;&#39;<span class="var">)</span>⇒<span class="stri">ランド</span>および<b>⇒</b>「B」<span class="var"></span>「A」<span class="stri">)</span>⇒<b>例外</b>範囲エラー<span class="var">比べる</span>整数<span class="stri">「A」</span><b>「B」</b>)<span class="var">⇒</span>「A」<b></b>「A」<span class="var">)</span>⇒<span class="var">「B」</span><b>「A」</b>)<span class="var">⇒</span>hashCode<span class="func">整数</span>増加<span class="stri">⇒</span>decr<b>⇒</b>無視する<span class="stri"></span><b></b><b></b><span class="var"></span><b></b><span class="stri"></span><b></b><span class="stri"></span><b></b><span class="func"></span><span class="op"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="stri"></span><span class="stri"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><b></b><span class="func"></span><b></b><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_string">
        <h3>5.9弦</h3>
          </a>
        <p>型式<tt><span class="type">文字列</span></tt>はUnicode文字(空文字列も含む)の並びを記述する。 ファイル1の<tt><span class="type">文字列</span></tt>UTF-32エンコーディングを使用してください。 文字列は<tt><span class="stri">&#39;\0;&#39;</span></tt>終了しました。 したがって、バイナリ・データを含めることもできます。 しかし<tt><span class="type">文字列</span></tt>は非常に大きくなることが許されているため、を表現するのに十分なメモリがない場合があります。<tt><span class="type">文字列</span></tt>value. この場合、例外は<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt>を上げます。 ソースファイルa<a class="link" href="#tokens_String_literals">文字列直定数</a>は、二重引用符で囲まれたUTF-8エンコードのUnicode文字の並びです。</p><p>文字列内の制御文字と特定の文字を同等に表すには、次のようにします。<a class="link" href="#types_escape_sequences">エスケープシーケンス</a>文字リテラルと同様に使用できます。 例:文字列内の引用符文字(&quot;)は、その前にバックスラッシュ(\&quot;)を付けることで表すことができます。 さらに、以下の可能性がある。</p><ul>
    <li><a name="types_string_continuation">2つのバックスラッシュとそれに続く空白、水平タブ、復帰、改行<a class="link" href="#tokens_Line_comments">行コメント</a>完全に無視されます。 無視された文字は、文字列の一部にはなりません。 次の行に続く文字列を続けるときに使用できます。 この場合、新しい行の先頭のスペースは文字列の一部ではないことに注意してください。 それは<a class="link" href="#errors_WRONG_STRING_CONTINUATION">間違い</a>バックスラッシュの後に空白文字の並びがあり、その並びの最後に2つ目のバックスラッシュがない場合。 この可能性は文字リテラルにも存在しますが、文字列リテラルと一緒に使用する方が意味があるので、ここで説明します。</li>
</ul><p>文字列リテラルの例を以下に示します。</p><pre class="box">


<span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;\&quot;&quot;&quot;</span><span class="stri">&quot;&quot;&quot;</span><span class="stri">「ゴールド」</span><span class="stri">&quot;A\&quot;B!&quot;</span><span class="stri">&quot;Euro:\8364;&quot;</span><span class="stri">&quot;CRLF\r\n&quot;</span></pre><p>ソースファイルでASCII(Unicodeのサブセット)を超える文字を使用するには、エディタがUTF-8エンコード文字を使用していることを確認してください。 その<tt><span class="type">文字列</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">string.s7i</span>&quot;</span></p><pre class="tt">
定数:

)
インフィックス演算子:

文字列連結
(
)

弱優先文字列連結
様々なタイプに対してオーバーロードされています。

(write(
);)

文字列乗算
(右オペランドの型:






)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)

スペースによる左パディング
(右オペランドの型:












)

ゼロによる左パディング
(右オペランドの型:












)

右パディング(スペース)
(右オペランドの型:












)

アイデンティティ
指標:

1文字にアクセスする
(引数Aのタイプ:

結果のタイプ:








)

AからBまでの部分文字列にアクセスする
(引数A、Bの型:

S
は、A>=1およびB>=pred(A)では有効です。

















)

位置Aから長さBの部分文字列にアクセスする
(引数A、Bの型:

S
A>=1かつB>=0の場合はOKです。













)

位置Aから保証された長さBの部分文字列にアクセスする
(引数A、Bの型:

S
A≧1かつA&lt;=length(S)の場合はokです。
B>=0かつpred(A+B)&lt;=length(S)













)

位置Aから始まる部分文字列にアクセスする
(引数Aのタイプ:

S
A>=1ではOKです。









)

Aで終わる部分文字列にアクセスする
(引数Aのタイプ:

S
A>=0であればOKです。









)
リレーション:


機能:


(結果の種類:

長さ(
0)

A
(引数Bのタイプ:

結果のタイプ:

pos(
2
pos(
0)

A
(結果の種類:

pos(
2
pos(
0
pos(
0)

A
検索は位置Cから開始されます。
A
(引数Bのタイプ:

引数Cの型:

結果のタイプ:

pos(
5
pos(
0
pos(
0)

A
検索は位置Cから開始されます。
A
(引数Cのタイプ:

結果のタイプ:

pos(
8
pos(
0
pos(
0)
pos(
0)

A
(引数Bのタイプ:

結果のタイプ:

rpos(
5
rpos(
0)

A
(結果の種類:

rpos(
8
rpos(
0
rpos(
0)

A
検索は位置Cから開始されます。
A
(引数Bのタイプ:

引数Cの型:

結果のタイプ:

rpos(
2
rpos(
0
rpos(
3)

A
検索は位置Cから開始されます。
A
(引数Cのタイプ:

結果のタイプ:

rpos(
2
rpos(
0
rpos(
3)

(A、B) 文字列がプレフィックスで始まるかどうかを調べます。
(結果の種類:

startsWith(

startsWith(
)

(A、B) 文字列が接尾語で終わるかどうかを決定する。
(結果の種類:

endsWith(

endsWith(
)

(A、B、C) AにCから始まるBという文字が検索されているかを確認します。
(結果の種類:

equalAtIndex(

equalAtIndex(
)

(A、B、C) Aを検索してBをCで置換する
(replace(
)

(A、B、C、D) Bの後にCが続くものをAで検索します。
それらをDに置き換える。
(replace2(
)

(A,B)AをBで区切られた文字列に分割
(引数Bのタイプ:

結果のタイプ:

分裂(
)
分裂(
)
分裂(
))

(A,B)AをBで区切られた文字列に分割
(結果の種類:

分裂(
)
分裂(
)
分裂(
)
分裂(
))

(A、B) 間にあるBと共にAの要素を接合する
(引数Aのタイプ:

引数Bの型:

join([](
)

(A、B) 間にあるBと共にAの要素を接合する
(引数Aのタイプ:

引数Bの型:

join([](
)

(A)前後の空白と制御文字を削除する
(trim(
)

(A)先頭のスペースや制御文字を削除する
(ltrim(
)

(A)後に続くスペースや制御文字を削除する
(rtrim(
)


(str(A)
A)

(A)直定数化
(リテラル(

リテラル(
)

(A)大文字への変換
(upper(
)

(A)小文字変換
(lower(
)

(A, B)比較関数
(結果の種類:

比較(
-1
比較(
0
比較(
1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B:AにBを追加する
(A&amp;:=B
A:=AとB)
A
B:AにBを追加する
(引数Bのタイプ:

A&amp;:=B
A:=A&amp;str(B))
A
A
(引数Bのタイプ:

引数Cの型:

A@:=[B]C

A:=A[.pred(B)]&amp;str(C)&amp;A[succc(B).]
A@:=[0]

A@:=[tucc(length(A))]
)
A
A
(引数Bのタイプ:

A@:=[B]C

A:=A[.pred(B)]&amp;C&amp;A[B+長さ(C).]
A@:=[0]

A@:=[pred(length(A))]
)

(A)値を無視(Ignore value)する


声明

文字列のすべての要素をループする
(forVarの引数の型:

引数文のタイプ:
)


声明

文字列のすべてのインデックスをループ処理する
(引数keyVarの型:

引数文のタイプ:
)


声明

文字列のすべての要素とインデックスをループ処理する
(forVarの引数の型:

引数keyVarの型:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(forVarの引数の型:

引数条件のタイプ:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(引数keyVarの型:

引数条件のタイプ:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(forVarの引数の型:

引数keyVarの型:

引数条件のタイプ:

引数文のタイプ:
)
<span class="type">文字列</span><span class="var">価値</span>既定値<span class="type">文字列</span>(<span class="stri">&quot;&quot;</span>&amp;<span class="op">「すべて」</span>&amp;<span class="stri">&quot;OK&quot;</span><span class="stri">⇒</span><b>「すべてOK」</b>&lt;&amp;<span class="stri">出力有効化</span>または<span class="op">enable_io</span>&quot;i=&quot;<span class="func">&lt;&amp;i</span>指<span class="func">2</span>パッド<span class="stri">6&lt;&amp;</span>&quot;$&quot;<span class="op">mult</span>整数<span class="op">「LA」</span><span class="stri">mult</span>3<span class="op">⇒</span><a class="type" href="#types_integer">「ラララ」</a>&quot;WORD&quot;<span class="stri"></span>mult<span class="op">0</span>⇒<b></b>&quot;&quot;<span class="stri">「すべて」</span><span class="stri">mult</span>-1<span class="op">⇒</span>例外<b>範囲エラー</b><span class="stri">B</span>:<span class="stri">ブール</span>TRUE<span class="op">a:b</span>⇒<b>FALSE</b>a:b<a class="exception" href="#errors_RANGE_ERROR">⇒</a>パッド<span class="op">整数</span>「HELLO」<span class="op"></span>パッド<a class="type" href="#types_boolean">8</a>⇒<span class="var"></span>「HELLO」<b>「HELLO」</b><span class="var">パッド</span>6<b>⇒</b><span class="op">「HELLO」</span>「HELLO」<a class="type" href="#types_integer"></a>パッド<span class="stri">5</span>⇒<span class="op"></span>「HELLO」<b>「HELLO」</b><span class="stri">パッド</span>4<span class="stri">⇒</span><span class="op">「HELLO」</span>「HELLO」<b></b>パッド<span class="stri">0</span>⇒<span class="stri"></span>「HELLO」<span class="op">「HELLO」</span><b>パッド</b>-8<span class="stri">⇒</span><span class="stri">「HELLO」</span>lpad0<span class="op">整数</span>&quot;12&quot;<b></b>lpad0<span class="stri">5</span>⇒<span class="stri"></span>&quot;00012&quot;<span class="op">&quot;12&quot;</span><b>lpad0</b>3<span class="stri">⇒</span><span class="stri">&quot;012&quot;</span>&quot;12&quot;<span class="op"></span>lpad0<b>2</b>⇒<span class="stri"></span>&quot;12&quot;<span class="op">&quot;12&quot;</span><a class="type" href="#types_integer">lpad0</a>1<span class="stri">⇒</span><span class="op">&quot;12&quot;</span>&quot;12&quot;<b></b>lpad0<span class="stri">0</span>⇒<span class="stri"></span>&quot;12&quot;<span class="op">&quot;12&quot;</span><b>lpad0</b>-5<span class="stri">⇒</span><span class="stri">&quot;12&quot;</span>パッド<span class="op">整数</span>「HELLO」<b></b>パッド<span class="stri">8</span>⇒<span class="stri"></span>「HELLO」<span class="op">「HELLO」</span><b>パッド</b>6<span class="stri">⇒</span><span class="stri">「HELLO」</span>「HELLO」<span class="op"></span>パッド<b>5</b>⇒<span class="stri"></span>「HELLO」<span class="stri">「HELLO」</span><span class="op">パッド</span>4<b>⇒</b><span class="stri">「HELLO」</span>「HELLO」<span class="op"></span>パッド<a class="type" href="#types_integer">0</a>⇒<span class="stri"></span>「HELLO」<span class="op">「HELLO」</span><b>パッド</b>-8<span class="stri">⇒</span><span class="stri">「HELLO」</span>文字列<span class="op"></span>解析する<b>[</b>A<span class="stri">]</span>整数<span class="stri">char</span>&quot;abcde&quot;<span class="op">[1]</span>⇒<b></b>&#39;a&#39;<span class="stri">&quot;abcde&quot;</span>[5]<span class="stri">⇒</span><span class="op">「e」</span>&quot;abcde&quot;<b>[0]</b>⇒<span class="stri">例外</span>INDEX_ERROR<span class="stri">&quot;abcde&quot;</span>[6]<span class="op">⇒</span>例外<b>INDEX_ERROR</b>[<span class="stri">A</span><span class="stri">B</span>]<span class="op">整数</span>[<b>A</b><span class="stri">B</span>]<span class="type">&quot;abcde&quot;</span>[2.4]<span class="op">⇒</span><span class="op">&quot;bcd&quot;</span>&quot;abcde&quot;<span class="op">[2.7]</span>⇒<a class="type" href="#types_integer"></a>&quot;bcd&quot;<a class="type" href="#types_char">&quot;abcde&quot;</a>[4.3]<span class="stri">⇒</span><b>&quot;&quot;</b>&quot;abcde&quot;<span class="stri">[4.2]</span>⇒<span class="stri">例外</span>INDEX_ERROR<b>&quot;abcde&quot;</b>[6.8]<span class="stri">⇒</span><span class="stri">&quot;&quot;</span>&quot;abcde&quot;<b>[1.3]</b>⇒<a class="exception" href="#errors_INDEX_ERROR"></a>&quot;abc&quot;<span class="stri">&quot;abcde&quot;</span>[0.3]<b>⇒</b>例外<a class="exception" href="#errors_INDEX_ERROR">INDEX_ERROR</a>&quot;abcde&quot;<span class="op">[1.0]</span>⇒<span class="op"></span>&quot;&quot;<span class="op">&quot;abcde&quot;</span>[1.-1]<a class="type" href="#types_integer">⇒</a>例外<span class="op">INDEX_ERROR</span>[<span class="op">A</span>len<span class="op">B</span>]<span class="stri">整数</span>[<b>A</b>len<span class="stri">B</span>]<span class="stri">&quot;abcde&quot;</span>[2<b>len</b>3]<span class="stri">⇒</span><span class="stri">&quot;bcd&quot;</span>&quot;abcde&quot;<b>[2</b>len<span class="stri">5]</span>⇒<span class="stri"></span>&quot;bcd&quot;<b>&quot;abcde&quot;</b>[3<a class="exception" href="#errors_INDEX_ERROR">len</a>0]<span class="stri">⇒</span><b>&quot;&quot;</b>&quot;abcde&quot;<span class="stri">[6</span>len<span class="stri">2]</span>⇒<b></b>&quot;&quot;<span class="stri">&quot;abcde&quot;</span>[3<span class="stri">len</span>-1]<b>⇒</b>例外<a class="exception" href="#errors_INDEX_ERROR">INDEX_ERROR</a>&quot;abcde&quot;<span class="stri">[1</span>len<b>2]</b>⇒<span class="stri"></span>「ab」<span class="stri">&quot;abcde&quot;</span>[0<b>len</b>2]<a class="exception" href="#errors_INDEX_ERROR">⇒</a>例外<span class="op">INDEX_ERROR</span>[<span class="op">A</span>fixLen<span class="op">B</span>]<a class="type" href="#types_integer">整数</a>[<span class="op">A</span>fixLen<span class="op">B</span>]<span class="op">&quot;abcde&quot;</span>[2<span class="stri">fixLen</span>3]<span class="keywd">⇒</span><b>&quot;bcd&quot;</b>&quot;abcde&quot;<span class="stri">[2</span>fixLen<span class="stri">5]</span>⇒<span class="keywd">例外</span>INDEX_ERROR<b>&quot;abcde&quot;</b>[3<span class="stri">fixLen</span>0]<span class="stri">⇒</span><span class="keywd">&quot;&quot;</span>&quot;abcde&quot;<b>[6</b>fixLen<span class="stri">2]</span>⇒<span class="stri">例外</span>INDEX_ERROR<span class="keywd">&quot;abcde&quot;</span>[3<b>fixLen</b>-1]<span class="stri">⇒</span>例外<span class="stri">INDEX_ERROR</span>&quot;abcde&quot;<span class="keywd">[1</span>fixLen<b>2]</b>⇒<a class="exception" href="#errors_INDEX_ERROR"></a>「ab」<span class="stri">&quot;abcde&quot;</span>[0<span class="keywd">fixLen</span>2]<b>⇒</b>例外<span class="stri">INDEX_ERROR</span>[<span class="stri">A</span><span class="keywd"></span>]<b>整数</b>[<a class="exception" href="#errors_INDEX_ERROR">A</a><span class="op">]</span>&quot;abcde&quot;<span class="op">[3.]</span>⇒<span class="op"></span>「cde」<a class="type" href="#types_integer">&quot;abcde&quot;</a>[6.]<span class="op">⇒</span><span class="op">&quot;&quot;</span>&quot;&quot;<span class="op">[1.]</span>⇒<span class="stri"></span>&quot;&quot;<span class="keywd">&quot;abcde&quot;</span>[1.]<b>⇒</b><span class="stri">&quot;abcde&quot;</span>&quot;abcde&quot;<span class="stri">[0.]</span>⇒<span class="keywd">例外</span>INDEX_ERROR<b>[</b><a class="exception" href="#errors_INDEX_ERROR"></a>A<span class="stri">]</span>整数<span class="keywd">[</span><b>A</b>]<span class="stri">&quot;abcde&quot;</span>[.4]<span class="stri">⇒</span><span class="keywd">&quot;abcd&quot;</span>&quot;abcde&quot;<b>[.6]</b>⇒<a class="exception" href="#errors_INDEX_ERROR"></a>&quot;abcde&quot;<span class="stri">&quot;&quot;</span>[.5]<span class="keywd">⇒</span><b>&quot;&quot;</b>&quot;abcde&quot;<a class="exception" href="#errors_INDEX_ERROR">[.0]</a>⇒<span class="stri"></span>&quot;&quot;<span class="keywd">&quot;abcde&quot;</span>[.-1]<b>⇒</b>例外<span class="stri">INDEX_ERROR</span>=<span class="stri"></span>&lt;><span class="keywd"></span>&lt;<b></b>&lt;=<a class="exception" href="#errors_INDEX_ERROR"></a>><span class="op"></span>>=<span class="op">長さ</span>(A)長さ<span class="op">文字列</span>整数<a class="type" href="#types_integer">&quot;&quot;</a>)<span class="op">⇒</span>pos<span class="op">(A,B)1つ目の位置</span><span class="op">char</span>B in<span class="stri">文字列</span>char<b>整数</b>「ABCABC」<span class="stri"></span>「B」<span class="stri">)</span>⇒<b>「XYZ」</b><span class="stri">「A」</span>)<span class="stri">⇒</span>pos<b>(A,B)1つ目の位置</b>文字列<span class="stri">B in</span>文字列<span class="stri">整数</span>&quot;ABCDE ABCDE&quot;<b></b>&quot;BC&quot;<span class="stri">)</span>⇒<span class="stri">&quot;XYZXYZ&quot;</span><b>「ZYX」</b>)<a class="exception" href="#errors_INDEX_ERROR">⇒</a>&quot;123456789&quot;<span class="op"></span>&quot;&quot;<span class="op">)</span>⇒<span class="op">pos</span>(A、B、C) 1文字目<a class="type" href="#types_integer">char</a>B in<span class="op">文字列</span><span class="op">文字列</span>char<span class="op">整数</span>整数<span class="stri">「ABCABC」</span><b>「B」</b>,3)<span class="stri">⇒</span>&quot;XYZYX&quot;<span class="stri"></span>「Z」<b>,4)</b>⇒<span class="stri">&quot;12345&quot;</span><span class="stri">&#39;3&#39;</span>,7)<b>⇒</b>pos<span class="stri">(A、B、C) 1文字目</span>文字列<span class="stri">B in</span>文字列<b>文字列</b>整数<span class="stri">整数</span>&quot;ABCDE ABCDE&quot;<span class="stri"></span>&quot;BC&quot;<b>,3)</b>⇒<a class="exception" href="#errors_INDEX_ERROR">&quot;XYZXYZ&quot;</a><span class="op">&quot;ZXY&quot;</span>,4)<span class="op">⇒</span>&quot;12345&quot;<span class="op"></span>&quot;34&quot;<span class="op">,7)</span>⇒<span class="op">&quot;123456789&quot;</span><span class="op">&quot;&quot;</span>,2)<span class="func">⇒</span>rpos<span class="type">(A、B) 最後の位置</span>char<a class="type" href="#types_integer">B in</a>文字列<span class="stri">char</span>整数<b>「ABCABC」</b><span class="func">「B」</span>)<a class="type" href="#types_char">⇒</a>「XYZ」<span class="type"></span>「A」<a class="type" href="#types_char">)</a>⇒<a class="type" href="#types_integer">rpos</a>(A、B) 最後の位置<span class="stri">文字列</span>B in<span class="stri">文字列</span>整数<b>&quot;ABCDE ABCDE&quot;</b><span class="stri">&quot;BC&quot;</span>)<span class="stri">⇒</span>&quot;XYZXYZ&quot;<b></b>「ZYX」<span class="func">)</span>⇒<span class="type">&quot;123456789&quot;</span><span class="type">&quot;&quot;</span>)<a class="type" href="#types_integer">⇒</a>rpos<span class="stri">(A、B、C) 最後の位置</span>char<span class="stri">B in</span>文字列<b>文字列</b>char<span class="stri">整数</span>整数<span class="stri">「ABCABC」</span><b>「B」</b>,4)<span class="stri">⇒</span>&quot;XYZYX&quot;<span class="stri"></span>「Z」<b>,2)</b>⇒<span class="func">&quot;12345&quot;</span><a class="type" href="#types_char">&#39;3&#39;</a>,5)<span class="type">⇒</span>rpos<span class="type">(A、B、C) 最後の位置</span>char<a class="type" href="#types_char">B in</a>文字列<a class="type" href="#types_integer">文字列</a>整数<a class="type" href="#types_integer">整数</a>「ABCABC」<span class="stri"></span>&quot;BC&quot;<span class="stri">,4)</span>⇒<b>&quot;XYZYX&quot;</b><span class="stri">&quot;ZY&quot;</span>,2)<span class="stri">⇒</span>&quot;12345&quot;<b></b>&quot;34&quot;<span class="stri">,5)</span>⇒<span class="stri">startsWith</span>ブール<b>&quot;tmp_s7c.c&quot;</b><span class="func">&quot;tmp_&quot;</span>)<span class="type">⇒</span><span class="type">TRUE</span>&quot;例&quot;<span class="type"></span>「E」<a class="type" href="#types_integer">)</a>⇒<a class="type" href="#types_integer"></a>FALSE<span class="stri">endsWith</span>ブール<span class="stri">&quot;hello.sd7&quot;</span><b>&quot;.sd7&quot;</b>)<span class="stri">⇒</span><span class="stri">TRUE</span>&quot;文字列&quot;<b></b>&quot;\0;&quot;<span class="stri">)</span>⇒<span class="stri"></span>FALSE<b>equalAtIndex</b>ブール<span class="stri">&quot;クイックブラウンフォックス&quot;</span><span class="stri">&quot;クイック&quot;</span>,5)<b>⇒</b><span class="func">TRUE</span>&quot;軸&quot;<a class="type" href="#types_char"></a>&quot;xi&quot;<span class="type">,3)</span>⇒<a class="type" href="#types_char"></a>FALSE<a class="type" href="#types_integer">取り替える</a>「オールドゴールド」<span class="stri"></span>「古い」<span class="stri"></span>「1」<b>)</b>⇒<span class="stri"></span>「1つなくなった」<span class="stri">2を置き換える</span>&quot;x:=(*ord*)y;&quot;<b></b>&quot;(*&quot;<span class="func"></span>&quot;*)&quot;<span class="type"></span>&quot;&quot;<span class="type">)</span>⇒<a class="type" href="#types_integer"></a>&quot;x:=y;&quot;<span class="stri">分裂する</span>char<span class="stri">配列</span><b>文字列</b>&quot;&quot;<span class="stri"></span>&#39;:&#39;<span class="stri">)</span>⇒<b>[](</b>&quot;&quot;<span class="stri">&quot;:&quot;</span><span class="stri">&#39;:&#39;</span>)<b>⇒</b>[](<span class="func">&quot;&quot;</span><a class="type" href="#types_char">&quot;&quot;</a>&quot;15:30&quot;<span class="type"></span>&#39;:&#39;<span class="type">)</span>⇒<a class="type" href="#types_char">[](</a>&quot;15&quot;<a class="type" href="#types_integer"></a>&quot;30&quot;<a class="type" href="#types_integer">分裂する</a>配列<span class="stri"></span>文字列<span class="stri">&quot;&quot;</span><b>&quot;&quot;</b>)<span class="stri">⇒</span>[](<span class="stri">&quot;&quot;</span>&quot;ABC&quot;<b></b>&quot;&quot;<span class="stri">)</span>⇒<span class="stri">[](</span>&quot;ABC&quot;<b>&quot;&quot;</b><span class="func">&quot;;&quot;</span>)<a class="type" href="#types_char">⇒</a>[](<span class="type">&quot;&quot;</span>&quot;writeln;readln;&quot;<span class="type"></span>&quot;;&quot;<a class="type" href="#types_integer">)</a>⇒<a class="type" href="#types_integer">[](</a>&quot;writeln&quot;<span class="stri"></span>&quot;readln;&quot;<span class="stri">接合する</span>配列<b></b>文字列<span class="stri">char</span>「これ」<span class="stri"></span>「は」<b></b>「a」<span class="stri"></span>&quot;test&quot;<span class="stri">)</span>「」<b>)</b>⇒<span class="func"></span>「これはテストです」<a class="type" href="#types_boolean">接合する</a>配列<span class="stri"></span>文字列<span class="stri">文字列</span>「pro」<b></b>「グラム」<span class="var">)</span>&quot;&quot;<span class="stri">)</span>⇒<span class="stri"></span>&quot;プログラム&quot;<b>整える</b>&quot;/n xyz/r&quot;<span class="var">)</span>⇒<span class="func"></span>「xyz」<a class="type" href="#types_boolean">ltrim</a>&quot;/n xyz/r&quot;<span class="stri">)</span>⇒<span class="stri"></span>&quot;xyz/r&quot;<b>rtrim</b>&quot;/n xyz/r&quot;<span class="var">)</span>⇒<span class="stri"></span>&quot;/n xyz&quot;<span class="stri">str</span>(A)〜への変換<b>文字列</b>⇒<span class="var">文字通りの</span>&quot;ABC&quot;<span class="func">)</span>⇒<a class="type" href="#types_boolean"></a>&quot;\&quot;ABC\&quot;&quot;<span class="stri">&quot;O\&quot;X\&quot;&quot;</span>)<span class="stri">⇒</span><b>&quot;&quot;O&#39;\\&quot;X\\&quot;&quot;&quot;</b>上<span class="var">&quot;上&quot;</span>)<span class="stri">⇒</span><span class="stri">「UPPER」</span>下げる<b>「下」</b>)<span class="var">⇒</span><span class="func">「lower」</span>比べる<span class="stri">整数</span>&quot;ABC&quot;<span class="stri"></span>&quot;ABCD&quot;<span class="stri">)</span>⇒<b>&quot;ABC&quot;</b><span class="stri">&quot;ABC&quot;</span>)<span class="func">⇒</span>&quot;ABCD&quot;<span class="stri"></span>&quot;ABCC&quot;<span class="stri">)</span>⇒<span class="stri">hashCode</span>整数<span class="stri">&amp;:=</span>⇒<b>&amp;:=</b>char<span class="stri">⇒</span>@:=<a name="types_split(in_string,in_char)">[B]C Cをの要素Bに代入する</a>文字列<a class="type" href="#types_char">整数</a>char<a class="type" href="#types_array">⇒</a>「x」<span class="type"></span>⇒<span class="stri">例外</span>INDEX_ERROR<span class="stri">「x」</span><b>⇒</b>例外<span class="stri">INDEX_ERROR</span>@:=<span class="stri">[B]C CをBの位置に割り当てる</span>文字列<span class="stri">整数</span>⇒<b>「xyz」</b><span class="stri">⇒</span>例外<span class="stri">INDEX_ERROR</span>「xyz」<span class="stri"></span>⇒<span class="stri">例外</span>INDEX_ERROR<b>無視する</b>の<span class="stri">forVar</span>範囲<span class="stri">文字列</span>do<a name="types_split(in_string,in_string)">終わり</a><a class="type" href="#types_array">の</a>char<span class="type">proc</span>の<span class="stri"></span>キー<span class="stri">キー変数</span>範囲<b>文字列</b>do<span class="stri">終わり</span><span class="stri">の</span>整数<span class="stri">proc</span>の<b>forVar</b>キー<span class="stri">キー変数</span>範囲<span class="stri">文字列</span>do<span class="stri">終わり</span><b>の</b>char<span class="stri">整数</span>proc<span class="stri">の</span>forVar<span class="stri">範囲</span>文字列<b>まで</b>状態<span class="stri">do</span>終わり<span class="stri"></span>の<a name="types_join(in_array_string,in_char)">条件が次のようになるまで文字列のすべての要素をループする</a>TRUE<a class="type" href="#types_array">char</a>ブール<span class="type">proc</span>の<a class="type" href="#types_char"></a>キー<span class="stri">キー変数</span>範囲<span class="stri">文字列</span>まで<span class="stri">状態</span>do<span class="stri">終わり</span><span class="stri">の</span>条件が次のようになるまで、文字列のすべてのインデックスをループする<b>TRUE</b>整数<span class="stri">ブール</span>proc<a name="types_join(in_array_string,in_string)">の</a>forVar<a class="type" href="#types_array">キー</a>キー変数<span class="type">範囲</span>文字列<span class="type">まで</span>状態<span class="stri">do</span>終わり<span class="stri"></span>の<span class="stri">条件が次のようになるまで、文字列のすべての要素とインデックスをループする</span>TRUE<b>char</b>整数<span class="stri">ブール</span>proc<span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="type"></span><b></b><span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><span class="stri"></span><b></b><span class="stri"></span><span class="func"></span><a class="type" href="#types_integer"></a><span class="stri"></span><span class="stri"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><span class="stri"></span><span class="stri"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><b></b><span class="op"></span><a class="type" href="#types_char"></a><b></b><span class="op"></span><span class="type"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_char"></a><b></b><span class="stri"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><span class="op"></span><span class="type"></span><a class="type" href="#types_integer"></a><b></b><span class="stri"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><span class="stri"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_char"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_char"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><a class="type" href="#types_char"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><a class="type" href="#types_char"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_array">
        <h3>5.10アレイ</h3>
          </a>
        <p>型式<tt><span class="type">配列</span><span class="type">baseType</span></tt>のシーケンスを説明する<tt><span class="type">baseType</span></tt>要素(空のシーケンスも含む)を含みます。 配列型宣言の例を以下に示します。</p><pre class="indent">;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:striArrayType<span class="keywd">は</span><span class="type">配列</span><a class="type" href="#types_string">文字列</a>const<span class="keywd"></span>タイプ<a class="type" href="#types_type">:structArrayType</a>は<span class="keywd"></span>配列<span class="type"></span>aStructType<span class="type"></span></pre><p>これは定義する<tt><span class="type">striArrayType</span></tt>での配列型として<tt><a class="type" href="#types_string">文字列</a></tt>要素。 2番目の線は<tt><span class="type">structArrayType</span></tt>での配列型として<tt><span class="type">aStructType</span></tt>要素。 これらの型の変数は以下で宣言されます。</p><pre class="indent">value;

value;

value;
<span class="keywd">var</span><span class="type">striArrayType</span>:striArr1<span class="keywd">は</span><span class="type">striArrayType</span>value;<span class="comment">#開始インデックスが1の空の配列。</span>var<span class="keywd"></span>striArrayType<span class="type">:striArr2</span>は<span class="keywd">0</span>回<span class="op"></span>&quot;&quot;<span class="stri">;</span>#開始インデックスが1の空の配列。<span class="comment">var</span><span class="keywd">striArrayType</span>:striArr4<span class="type">は</span>[0.-1]<span class="keywd">回</span><span class="op">&quot;&quot;</span>;<span class="stri">#開始インデックスが0の空の配列。</span>var<span class="comment"></span>striArrayType<span class="keywd">:striArr3</span>は<span class="type">[0 len 0]</span>回<span class="keywd"></span>&quot;&quot;<span class="op">;</span>#開始インデックスが0の空の配列。<span class="stri">var</span><span class="comment">striArrayType</span>:striArr5<span class="keywd">は</span>[](<span class="type">「1」</span><span class="keywd">「2」</span>);<span class="stri">#2文字列要素で開始インデックス1の配列。</span>var<span class="stri"></span>striArrayType<span class="comment">:striArr6</span>は<span class="keywd">[0](</span>「ゼロ」<span class="type"></span>「1」<span class="keywd">);</span>#2つの文字列要素で始まりインデックス0を持つ配列。<span class="stri">var</span><span class="stri">structArrayType</span>:structArr1<span class="comment">は</span><span class="keywd">structArrayType</span>var<span class="type"></span>structArrayType<span class="keywd">:structArr2</span>は<span class="type">10</span>回<span class="keywd"></span>aStructType<span class="type">var</span><span class="keywd">structArrayType</span>:structArr3<span class="op">は</span>[42.365]<span class="type">回</span><span class="keywd">aStructType</span><span class="type"></span><span class="keywd"></span><span class="op"></span><span class="type"></span></pre><p>配列の要素には<tt><a class="type" href="#types_integer">整数</a></tt>index. 配列の最小および最大インデックスは値の一部であり、次の関数で取得できます。<tt><span class="func">minIdx</span></tt>および<tt><span class="func">maxIdx</span></tt>デフォルトの最小インデックスである1を持つ配列を生成する関数や、パラメータから取得した最小インデックスを持つ配列を生成する関数があります。 その<tt><span class="type">配列</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">s7i</span>&quot;</span></p><p>非整数の添字を持つ配列はライブラリで定義されます。<span class="stri">&quot;<span class="lib">idxarray.s7i</span>&quot;</span>を持つ配列型<tt><a class="type" href="#types_char">char</a></tt>indexおよび<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>要素は次のように定義されています。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:charIndexArray<span class="keywd">は</span><span class="type">配列</span>[<a class="type" href="#types_char">char</a>]<a class="type" href="#types_bigInteger">bigInteger</a></pre><p>この型の変数は以下で宣言されます。</p><pre class="indent">value;

42_;

](0_,1_,2_);

](32_、33_、34_);
<span class="keywd">var</span><span class="type">charIndexArray</span>:bigArr1<span class="keywd">は</span><span class="type">charIndexArray</span>var<span class="keywd"></span>charIndexArray<span class="type">:bigArr2</span>は<span class="keywd"></span>char<a class="type" href="#types_char"></a>回<span class="op">var</span><span class="keywd">charIndexArray</span>:bigArr3<span class="type">は</span>[<span class="keywd">char</span>var<a class="type" href="#types_char"></a>charIndexArray<span class="keywd">:bigArr4</span>は<span class="type">[</span>「」<span class="keywd"></span><span class="stri"></span></pre><p>の定義<tt><span class="type">charIndexArray</span></tt>は、特殊<tt><span class="op">回</span></tt>上記の演算子とリテラルを定義する特別な可能性<tt><span class="type">charIndexArray</span></tt></p><pre class="tt">
直定数:
[](elem1, elem2)
で指定された要素を持つファイルを検索し
インデックスタイプ
開始インデックスは1です。
[0](elem1, elem2)作成
で指定された要素を持つファイルを検索し
インデックスタイプ
開始インデックスは0です。
[
で指定された要素を持つファイルを検索し
インデックスタイプ
)。
[
で指定された要素を持つファイルを検索し
インデックスタイプ

インフィックス演算子:

配列の連結

配列の生成
(左オペランド:

右オペランド:

A
BのA要素と
3
[](B, B, B)
0
開始インデックスが1の空の配列。
(1
B
(0

-1
)
[A.B]
C言語による配列の生成
(引数A、Bの型:

引数Cの型:

[A.B]

Cのpred(B-A)要素で
[-1.-2]
開始インデックスが-1の空の配列
[-1.-3]
)
[A len L]
C言語による配列の生成
(引数A、Lの型:

引数Cの型:

[A len L]

CのL要素で
[-1 len 0]
開始インデックスが-1の空の配列
[-1 len-1]
)


へ

(引数Aのタイプ:


](5、5))
指標:

1つの配列要素にアクセスする
(引数Aのタイプ:

結果のタイプ:

A[
1要素目
A[
最後の要素
A[pred(

A[succl(
)

位置Aから位置Bまでのサブ配列を取得します。
(引数A、Bの型:

×
(A)項
anArray[

anArray[n.n-2]
)

位置Aから最大長Bのサブ配列を取得します。
(引数A、Bの型:

×
(X)かつB≧0
anArray[

anArray[n len-1]
)

位置Aから始まるサブ配列を取得します。
(引数Aのタイプ:

×
(X)
anArray[
)

位置Aで終わるサブ配列を取得します。
(引数Aのタイプ:

×
(X))
anArray[.
)
リレーション:
=、&lt;>
機能:

(A)配列の長さ
(結果の種類:


(A))

3

3

3

3

0

5)

(A)配列の最小インデックス
(結果の種類:


1

0

2



1

-1)

(A)配列の最大インデックス
(結果の種類:


3

2

4



3

4)

(A)配列からの乱数要素
乱雑な要素は一様に分布している。
(結果の種類:
)

(A、B) インデックスBの要素を配列Aから削除します。
削除された要素を返す
(引数Bのタイプ:

結果のタイプ:


(A)項

(anArray)=1

(anArray)=4)

(A、B、C) 配列AからインデックスB、長さCのサブ配列を削除します。
削除されたサブ配列を返す
(引数Bのタイプ:

引数Cの型:


(A)及びC>=0

(anArray)=1

(anArray)=4

)

)機能
ステートメント:
A
B:AにBを追加する
(A&amp;:=B
A:=AとB)
A
B要素BをAに追加する
(引数Bのタイプ:

A&amp;:=B
A:=A&amp;[](B))

(A,B,C)要素Cを配列AのインデックスBに挿入します。
(引数Bのタイプ:

引数Cの型:


(A))

(anArray)=1

(anArray)=4)

(A,B,C)配列Cを配列AのインデックスBに挿入する
(引数Bのタイプ:


(A))

(anArray)=1

(anArray)=4)
insert(A, B)ソート済み配列AにBを挿入します。
(引数Bのタイプ:
)

(A)値を無視(Ignore value)する


声明

配列の全要素をループする
(forVarの引数の型:

引数文のタイプ:
)


声明

配列のすべてのインデックスをループする
(引数keyVarの型:

引数文のタイプ:
)


声明

配列のすべての要素とインデックスをループする
(forVarの引数の型:

引数keyVarの型:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(forVarの引数の型:

引数条件のタイプ:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(引数keyVarの型:

引数条件のタイプ:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(forVarの引数の型:

引数keyVarの型:

引数条件のタイプ:

引数文のタイプ:
)
<span class="type">配列</span>整数<a class="type" href="#types_integer">配列</a>整数<span class="type">char</span>](elem1、elem2)<a class="type" href="#types_integer">配列</a>char<a class="type" href="#types_char">開始インデックスは</a>char<span class="type"></span>価値<a class="type" href="#types_char">(</a>「」<a class="type" href="#types_char">「A」</a>](elem1、elem2)<span class="var">配列</span>char<span class="stri">開始インデックスは</span>「A」<span class="stri">&amp;</span>回<span class="type">整数</span>baseType<a class="type" href="#types_char">回</a>B生成する<span class="stri">配列</span><span class="op">baseType</span>回<span class="op">B</span>⇒<a class="type" href="#types_integer">回</a>B<span class="type">⇒</span>回<span class="op_no_ul">B)[1]</span>⇒<span class="type">回</span>B)[1]<span class="type">⇒</span>例外<span class="op_no_ul">INDEX_ERROR</span>回<b>B</b>⇒<span class="op_no_ul">例外</span>範囲エラー<b>回</b>整数<span class="op_no_ul">baseType</span>回<b>C生成する</b>配列<span class="op_no_ul"></span>baseType<b>回</b>B<a class="exception" href="#errors_INDEX_ERROR">⇒</a>回<span class="op_no_ul">B</span>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">回</a>整数<span class="op">baseType</span>回<a class="type" href="#types_integer">C生成する</a>配列<span class="type"></span>baseType<span class="op_no_ul">回</span>B<span class="type">⇒</span>回<span class="type">B</span>⇒<span class="op_no_ul">例外</span>範囲エラー<b>indexType</b><span class="op_no_ul">回</span>インデックスの配列生成<b>indexType</b><a class="exception" href="#errors_RANGE_ERROR">1番目</a>indexType<span class="op"></span>最後の<a class="type" href="#types_integer">baseType</a>ブール<span class="type"></span>回<span class="op_no_ul">5</span>⇒<span class="type">[</span>FALSE<span class="type">[</span>A<span class="op_no_ul">]</span>整数<b>baseType</b>minIdx<span class="op_no_ul">(A)]</span>⇒<b>maxIdx</b>(A)]<a class="exception" href="#errors_RANGE_ERROR">⇒</a>minIdx<span class="type">(A))]</span>⇒<span class="op">例外</span>INDEX_ERROR<span class="type">maxIdx</span>(A))]<span class="var">⇒</span>例外<span class="type">INDEX_ERROR</span>[<span class="var">A</span><span class="type">B</span>]<a class="type" href="#types_boolean">整数</a>[<span class="op_no_ul">A</span><b>B</b>]<span class="var">AはでOKです>=</span>minIdx<span class="op">(X)かつB≧=</span>pred<span class="op">pred</span>(<a class="type" href="#types_integer">minIdx</a>(anArray)).n]<span class="type">⇒</span>例外<span class="func">INDEX_ERROR</span>⇒<b>例外</b>INDEX_ERROR<span class="func">[</span>A<b>len</b>B<span class="func">]</span>整数<b>[</b>A<a class="exception" href="#errors_INDEX_ERROR">len</a>B<span class="func">]</span>AはでOKです>=<b>minIdx</b>pred<a class="exception" href="#errors_INDEX_ERROR">(</a>minIdx<span class="op">(anArray))len n]</span>⇒<span class="op">例外</span>INDEX_ERROR<span class="op">⇒</span>例外<a class="type" href="#types_integer">INDEX_ERROR</a>[<span class="op">A</span><span class="op"></span>]<span class="op">整数</span>[<span class="func">A</span><span class="func">]</span>AはでOKです>=<span class="func">minIdx</span>pred<span class="func">(</span>minIdx<b>(anArray)).]</b>⇒<a class="exception" href="#errors_INDEX_ERROR">例外</a>INDEX_ERROR<b>[</b><a class="exception" href="#errors_INDEX_ERROR"></a>A<span class="op">]</span>整数<span class="op">[</span><span class="op">A</span>]<a class="type" href="#types_integer">AはでOKです>=</a>pred<span class="op">(</span>minIdx<span class="op">minIdx</span>(anArray)-2]<span class="op">⇒</span>例外<span class="func">INDEX_ERROR</span>長さ<span class="func">整数</span>長さ<span class="func">(A)=succ(</span>maxIdx<b>(A)-</b>minIdx<a class="exception" href="#errors_INDEX_ERROR">長さ</a>([](2, 3, 5))<b>⇒</b>長さ<a class="exception" href="#errors_INDEX_ERROR">([0](2、3、5))</a>⇒<span class="op">長さ</span>([2](2、3、5))<span class="op">⇒</span>長さ<span class="op">([</span>&#39;a&#39;<a class="type" href="#types_integer">](1、2、3))</a>⇒<span class="op">長さ</span>(0<span class="op">回</span><span class="op"></span>TRUE<span class="func">)</span>⇒<span class="func">長さ</span>(5<span class="func">回</span><b>TRUE</b>)<a class="exception" href="#errors_INDEX_ERROR">⇒</a>minIdx<span class="op">整数</span>minIdx<span class="op">([](2, 3, 5))</span>⇒<span class="op">minIdx</span>([0](2、3、5))<a class="type" href="#types_integer">⇒</a>minIdx<span class="op">([2](2、3、5))</span><span class="op">⇒</span>minIdx<span class="op">([</span>&#39;a&#39;<span class="func">](1、2、3))</span>⇒<span class="func"></span>&#39;a&#39;<span class="func">minIdx</span>(3<b>回</b><a class="exception" href="#errors_INDEX_ERROR">TRUE</a>)<span class="func">⇒</span>minIdx<a class="type" href="#types_integer">([-1.4]</a>回<span class="func"></span>TRUE<span class="func">)</span>⇒<span class="func">maxIdx</span>整数<span class="func">maxIdx</span>([](2, 3, 5))<b>⇒</b>maxIdx<span class="func">([0](2、3、5))</span>⇒<b>maxIdx</b>([2](2、3、5))<span class="func">⇒</span>maxIdx<b>([</b>&#39;a&#39;<span class="func">](1、2、3))</span>⇒<span class="stri"></span>「c」<b>maxIdx</b>(3<span class="func">回</span><span class="op_no_ul">TRUE</span>)<span class="var">⇒</span>maxIdx<b>([-1.4]</b>回<span class="func"></span>TRUE<span class="op_no_ul">)</span>⇒<span class="var">ランド</span>baseType<b>取り除く</b>整数<span class="func">baseType</span>取り除く<a class="type" href="#types_integer">(A,B)はB>=に対してOKです</a>minIdx<span class="func">(A)およびB≦</span>maxIdx<b>取り除く</b>(anArray, 0)<span class="func">⇒</span>例外<b>INDEX_ERROR</b>の<span class="func">minIdx</span>取り除く<b>(anArray, 5)</b>⇒<span class="func">例外</span>INDEX_ERROR<span class="stri">の</span>maxIdx<b>取り除く</b>整数<span class="stri">整数</span>取り除く<span class="func">(A,B,C)はB>=に対して有効です。</span>minIdx<span class="op_no_ul">(A)およびB≦</span>maxIdx<span class="var">取り除く</span>(anArray, 0, 1)<b>⇒</b>例外<span class="func">INDEX_ERROR</span>の<span class="op_no_ul">minIdx</span>取り除く<span class="var">(anArray, 6, 1)</span>⇒<b>例外</b>INDEX_ERROR<span class="func">の</span>maxIdx<a class="type" href="#types_integer">取り除く</a>(anArray, 1, -1)<span class="func">⇒</span>例外<b>INDEX_ERROR</b>ソート<span class="func">(A)compare(</span>baseType<b></b>baseType<span class="func">&amp;:=</span>⇒<b>&amp;:=</b>baseType<span class="func">⇒</span>挿入する<span class="stri">整数</span>baseType<b>挿入する</b>(A,B,C)はB>=に対して有効です。<span class="stri">minIdx</span>(A)およびB≦<span class="func">水</span>(<span class="op_no_ul">maxIdx</span>挿入する<span class="var">(anArray, 0, anElement)</span>⇒<b>例外</b>INDEX_ERROR<span class="func">の</span>minIdx<span class="op_no_ul">挿入する</span>(anArray, 6, anElement)<span class="var">⇒</span>例外<b>INDEX_ERROR</b>の<span class="func">maxIdx</span>挿入する<span class="type">整数</span>挿入する<span class="func">(A,B,C)はB>=に対して有効です。</span>minIdx<a class="type" href="#types_integer">(A)およびB≦</a>水<span class="type">(</span>maxIdx<span class="func">挿入する</span>(anArray, 0, anotherAnarry)<span class="func">⇒</span>例外<span class="func">INDEX_ERROR</span>の<span class="func">minIdx</span>挿入する<b>(anArray, 6, anotherAnarry)</b>⇒<a class="exception" href="#errors_INDEX_ERROR">例外</a>INDEX_ERROR<span class="func">の</span>maxIdx<span class="func">baseType</span>無視する<b>の</b>forVar<a class="exception" href="#errors_INDEX_ERROR">範囲</a>配列<span class="func">do</span>終わり<span class="func"></span>の<a class="type" href="#types_integer">baseType</a>proc<a class="type" href="#types_integer">の</a><span class="func">キー</span>キー変数<span class="func">範囲</span>配列<span class="func">do</span>終わり<span class="func"></span>の<b>indexType</b>proc<a class="exception" href="#errors_INDEX_ERROR">の</a>forVar<span class="func">キー</span>キー変数<span class="func">範囲</span>配列<b>do</b>終わり<a class="exception" href="#errors_INDEX_ERROR"></a>の<span class="func">baseType</span>indexType<span class="func">proc</span>の<b>forVar</b>範囲<a class="exception" href="#errors_INDEX_ERROR">配列</a>まで<span class="func">状態</span>do<span class="type">終わり</span><span class="type">の</span>条件が次のようになるまで配列のすべての要素をループする<span class="op">TRUE</span>baseType<b>ブール</b>proc<span class="op">の</span><span class="type">キー</span>キー変数<b>範囲</b>配列<span class="func">まで</span>状態<a class="type" href="#types_integer">do</a>終わり<span class="type"></span>の<span class="func">条件が次のようになるまで配列のすべてのインデックスをループする</span>TRUE<span class="func">indexType</span>ブール<span class="func">proc</span>の<span class="func">forVar</span>キー<span class="func">キー変数</span>範囲<b>配列</b>まで<a class="exception" href="#errors_INDEX_ERROR">状態</a>do<span class="func">終わり</span><span class="func">の</span>条件が次のようになるまで、配列のすべての要素とインデックスをループします。<b>TRUE</b>baseType<a class="exception" href="#errors_INDEX_ERROR">indexType</a>ブール<span class="func">proc</span><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><span class="func"></span><span class="func"></span><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><span class="func"></span><span class="type"></span><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="type"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><span class="type"></span><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><span class="type"></span><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><span class="type"></span><span class="type"></span><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_hash">
        <h3>5.11ハッシュ</h3>
          </a>
        <p>型式<tt><span class="type">ハッシュ</span><span class="type">[keyType]</span><span class="type">baseType</span></tt>の要素を持つハッシュテーブルを記述する<tt><span class="type">baseType</span></tt>これらの要素には、次のインデックスでアクセスできます。<tt><span class="type">キータイプ</span></tt>ハッシュ型宣言の例を次に示します。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:aHashType<span class="keywd">は</span><span class="type">ハッシュ</span><span class="type">[</span><a class="type" href="#types_string">文字列</a><span class="type">]</span><a class="type" href="#types_integer">整数</a></pre><p>これは定義する<tt><span class="type">aHashType</span></tt>ハッシュ型として<tt><a class="type" href="#types_integer">整数</a></tt>要素と<tt><a class="type" href="#types_string">文字列</a></tt>キー。 この型の変数は以下で宣言されます。</p><pre class="indent"><span class="keywd">var</span><span class="type">aHashType</span>:aHashTable1<span class="keywd">は</span><span class="type">aHashType</span>value;<span class="comment">#ハッシュテーブルが空です。</span>var<span class="keywd"></span>aHashType<span class="type">:aHashTable2</span>は<span class="keywd">[]([</span>「1」<span class="stri">:1],[</span>「2」<span class="stri">:2]);</span>#文字列を整数にマッピングする2つの要素を持つハッシュ。<span class="comment"></span></pre><p>式<tt><span class="type">aHashType</span>value</tt>および<tt><span class="type">aHashType</span>EMPTY_HASH</tt>空のハッシュテーブルを記述する。 これらの他には、ハッシュテーブルリテラルはありません。 その<tt><span class="type">キータイプ</span></tt>ハッシュのは、機能を提供する必要がある<tt><span class="func">hashCode</span></tt>および<tt><span class="func">比べる</span></tt>これに加えて<tt><span class="type">キータイプ</span></tt>任意のタイプにすることができます。 その<tt><span class="type">ハッシュ</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">hash.s7i</span>&quot;</span></p><pre class="tt">
直定数:
[]([key1:value1],[key2:value2])作成
を、指定されたキーと対応する値で更新します。
定数:

EMPTY_HASH空のハッシュテーブル
インフィックス演算子:

要素
(左引数:

結果のタイプ:
)

要素ではない
(左引数:

結果のタイプ:
)
指標:

A]1つのハッシュテーブル要素にアクセスする
(引数Aのタイプ:

結果のタイプ:
)
リレーション:
=、&lt;>
機能:

(A)ハッシュテーブルAの要素数
(結果の種類:

length(hashType.EMPTY_HASH)
0)

(A)ハッシュテーブルAからのソートされていないキーの配列
(結果の種類:
)

(A)ハッシュテーブルAからのソートされていない値の配列
(結果の種類:
)

(A)キーと値を反転させたハッシュを配信する
(結果の種類:
)
ステートメント:

(A、B、C) ハッシュテーブルAに要素Bを含める
(引数Bのタイプ:

引数Cの型:
)

(A、B) ハッシュテーブルAから要素Bを除外する
(引数Bのタイプ:
)
A
[B]C CをハッシュテーブルAの要素Bに代入する
(引数Bのタイプ:

引数Cの型:
)

(A)値を無視(Ignore value)する


声明

ハッシュのすべての値に対するソートされていないループ
(forVarの引数の型:

引数文のタイプ:
)


声明

ハッシュのすべてのキーに対するソートされていないループ
(引数keyVarの型:

引数文のタイプ:
)


声明

ハッシュのすべての値とキーに対するソートされていないループ
(forVarの引数の型:

引数keyVarの型:

引数文のタイプ:
)
<span class="type">ハッシュ</span>hashType<span class="type">で</span>baseType<span class="op">ブール</span>ない<span class="type">baseType</span>ブール<a class="type" href="#types_boolean">[</a>キータイプ<span class="op">baseType</span>長さ<span class="type">整数</span>⇒<a class="type" href="#types_boolean">キー</a>配列<span class="op"></span>キータイプ<span class="type">価値観</span>配列<span class="type"></span>baseType<span class="func">裏返す</span>ハッシュ<a class="type" href="#types_integer"></a>[baseType]<b></b>配列<span class="func"></span>キータイプ<a class="type" href="#types_array">含む</a>キータイプ<span class="type">baseType</span>除く<span class="func">キータイプ</span>@:=<a class="type" href="#types_array">キータイプ</a>baseType<span class="type">無視する</span>の<span class="func">forVar</span>範囲<span class="type">aHash</span>do<span class="type">終わり</span><a class="type" href="#types_array">の</a>baseType<span class="type">proc</span>の<span class="func"></span>キー<span class="type">キー変数</span>範囲<span class="type">aHash</span>do<span class="func">終わり</span><span class="type">の</span>キータイプ<span class="op">proc</span>の<span class="type">forVar</span>キー<span class="type">キー変数</span>範囲<a class="func" href="#stats_Ignoring_values">aHash</a>do<span class="keywd">終わり</span><span class="keywd">の</span>baseType<span class="keywd">キータイプ</span>proc<span class="keywd"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="type"></span><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_set">
        <h3>5.12セット</h3>
          </a>
        <p>型式<tt><span class="type">設定する</span><span class="type">の</span><span class="type">baseType</span></tt>の要素のセットを記述します。<tt><span class="type">baseType</span></tt>(空集合も含む) セット型宣言の例を次に示します。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:aSetType<span class="keywd">は</span><span class="type">設定する</span><span class="type">の</span><a class="type" href="#types_integer">整数</a></pre><p>これは定義する<tt><span class="type">aSetType</span></tt>とのセット型として<tt><a class="type" href="#types_integer">整数</a></tt>要素。 この型の変数は以下で宣言されます。</p><pre class="indent">value;

{1, 2, 3};

{1.5};
<span class="keywd">var</span><span class="type">aSetType</span>:aSet<span class="keywd">は</span><span class="type">aSetType</span>var<span class="keywd"></span>aSetType<span class="type">:aSet</span>は<span class="keywd">var</span><span class="keywd">aSetType</span>:aSet<span class="type">は</span><span class="keywd"></span></pre><p>型式<tt><span class="type">設定する</span><span class="type">の</span><span class="type">baseType</span></tt>がライブラリで定義されています。<span class="stri">&quot;<span class="lib">set.s7i</span>&quot;</span>この抽象データ型は、集合の実装を決定する。 いつ<tt><span class="type">baseType</span></tt>値をマップできます。<tt><a class="type" href="#types_integer">整数</a></tt>で<tt><span class="func">ord</span></tt>関数と<tt><span class="func">ord</span></tt>集合がとして実装されても例外を発生させない<tt><span class="type">bitset(baseType)</span></tt>(ライブラリで定義<span class="stri">&quot;<span class="lib">bitsetof.s7i</span>&quot;</span>)。それ以外の場合、セットはとして実装されます<tt><span class="type">hashset(baseType)</span></tt>(ライブラリで定義<span class="stri">&quot;<span class="lib">hashsetof.s7i</span>&quot;</span>)。 型式<tt><span class="type">設定する</span><span class="type">の</span><a class="type" href="#types_integer">整数</a></tt>はの代替名です。<tt><span class="type">ビットセット</span></tt>は、ライブラリで定義されています。<span class="stri">&quot;<span class="lib">bitset.s7i</span>&quot;</span></p><pre class="tt">
定数:
{}型が空集合



{1, 2}1と2で設定(type:
)
{
}3文字で設定します。
{
}2つの文字列で設定します。

({})



)
インフィックス演算子:

和集合
({1, 2}
{1, 2, 3}
{
}
{
})

積集合
({1, 2}
{1}
{
}
{
})

相違点
({1, 2}
{2}
{
}
{
})

対称差分
({1, 2}
{2, 3}
{
}
{
})

要素
(左引数:

結果のタイプ:

2

4








)

要素ではない
(左引数:

結果のタイプ:

2

4








)
リレーション:

等しいおよび等しくない
(結果の種類:
)

サブセット
(結果の種類:

A&lt;=B
それに対して要素Xが存在しないとき
×
B
を有する。
A&lt;=B
それのために要素Xが存在するとき
×
B
を有する。


A&lt;=
A&lt;>EMPTY_SETの場合
A&lt;=B
B>=A)

固有部分集合
(結果の種類:

A&lt;B
A&lt;>B

A&lt;>EMPTY_SETの場合
A&lt;

A&lt;B
B>A)

超集合
(結果の種類:

A>=B
それに対して要素Xが存在しないとき
×
A
を有する。
A>=B
それのために要素Xが存在するとき
×
A
を有する。
A>=


A&lt;>EMPTY_SETの場合
A>=B
B&lt;=A)

真部分集合
(結果の種類:

A>B
A&lt;>B
A>
A&lt;>EMPTY_SETの場合


A>B
B&lt;A)
機能:


(引数Aのタイプ:


{2、3、5、7、11})


(引数Aのタイプ:


{}

{2、3、5、7})


(結果の種類:


2220)

(A)集合の濃度
(結果の種類:


5

3

3

0)

(A)最低限の要素
(結果の種類:

セットからの要素の納品
次の条件が適用されます。
エレメント&lt;=X
集合内にあるすべてのXに対して。

2



)

(A)マキシマムエレメント
(結果の種類:

セットからの要素の納品
次の条件が適用されます。
エレメント>=X
集合内にあるすべてのXに対して。

11



)

(A, B)集合Aの中でBより大きい最小の要素
(引数Bのタイプ:

結果のタイプ:


3

5

11





)


(結果の種類:






)

(A)集合からの乱雑な要素
乱雑な要素は一様に分布している。
(結果の種類:


)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)

(A)Aの値をすべて含む配列を取得する
(結果の種類:


[](2, 3, 5)

[](&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))
ステートメント:
A
B:AとBの和集合をAに割り当てる
A
B:AとBの交差部分をAに割り当てる。
A
B:AとBの差分をAに代入する
A
[B]C AからBをそれぞれ追加または削除する
(引数Bのタイプ:

引数Cの型:

A
(A,B)
A
(A、B))

(A、B) Aを設定するには要素Bを含めてください
(引数Bのタイプ:
)

(A、B) セットAから要素Bを除外する
(引数Bのタイプ:
)

(A)値を無視(Ignore value)する


声明

集合のすべての要素をループする
(forVarの引数の型:

引数文のタイプ:
)
<span class="type">ビットセット</span>EMPTY_SET<span class="var">型の空集合</span>ビットセット<span class="type">ビットセット</span>&#39;a&#39;<span class="type"></span>「b」<span class="stri"></span>「c」<span class="stri">&quot;黒&quot;</span><span class="stri">&quot;白&quot;</span>ビットセット<span class="stri"></span>価値<span class="stri">既定値</span>ビットセット<span class="type">setType</span><span class="var">EMPTY_SET</span>型の空集合<span class="type">setType</span>setType<span class="type"></span>価値<span class="var">既定値</span>setType<span class="type">(</span>setType<span class="type"></span>EMPTY_SET<span class="var"></span><span class="type">{1, 3}</span>⇒<span class="type">&#39;a&#39;</span><span class="var">「b」</span>}<span class="op"></span>{<span class="op_no_ul">&#39;a&#39;</span><b>「c」</b>}<span class="stri">⇒</span>{<span class="stri">&#39;a&#39;</span><span class="op_no_ul">「b」</span><span class="stri">「c」</span>「1」<span class="stri"></span>「2」<b>}</b><span class="stri">{</span>「1」<span class="stri"></span>「3」<span class="stri">}</span>⇒<span class="stri">{</span>「1」<span class="stri"></span>「2」<span class="op_no_ul"></span>「3」<span class="stri">&amp;</span>&amp;<span class="stri">{1, 3}</span>⇒<b>&#39;a&#39;</b><span class="stri">「b」</span>}<span class="stri">&amp;</span>{<span class="stri">&#39;a&#39;</span><span class="op">「c」</span>}<span class="op_no_ul">⇒</span>{<b>&#39;a&#39;</b>「1」<span class="stri"></span>「2」<span class="stri">}</span>&amp;<span class="op_no_ul">{</span>「1」<span class="stri"></span>「3」<span class="stri">}</span>⇒<b>{</b>「1」<span class="stri">-</span>-<span class="stri">{1, 3}</span>⇒<span class="stri">&#39;a&#39;</span><span class="op_no_ul">「b」</span>}<span class="stri">-</span>{<span class="stri">&#39;a&#39;</span><b>「c」</b>}<span class="stri">⇒</span>{<span class="op">「b」</span>「1」<span class="op_no_ul"></span>「2」<b>}</b>-<span class="stri">{</span>「1」<span class="stri"></span>「3」<span class="op_no_ul">}</span>⇒<span class="stri">{</span>「2」<span class="stri">>&lt;</span>>&lt;<b>{1, 3}</b>⇒<span class="stri">&#39;a&#39;</span><span class="stri">「b」</span>}<span class="stri">>&lt;</span>{<span class="op_no_ul">&#39;a&#39;</span><span class="stri">「c」</span>}<span class="stri">⇒</span>{<b>「b」</b><span class="stri">「c」</span>「1」<span class="op"></span>「2」<span class="op_no_ul">}</span>>&lt;<b>{</b>「1」<span class="stri"></span>「3」<span class="stri">}</span>⇒<span class="op_no_ul">{</span>「2」<span class="stri"></span>「3」<span class="stri">で</span>baseType<b>ブール</b>で<span class="stri">{2、3、5、7}</span>⇒<span class="stri"></span>TRUE<span class="stri">で</span>{2、3、5、7}<span class="stri">⇒</span><span class="op_no_ul">FALSE</span>&#39;a&#39;<span class="stri"></span>で<span class="stri">{</span>&#39;a&#39;<b></b>「c」<span class="stri"></span>「d」<span class="stri">}</span>⇒<span class="op"></span>TRUE<span class="type">「b」</span><a class="type" href="#types_boolean">で</a>{<span class="op_no_ul">&#39;a&#39;</span><b>「c」</b><span class="var">「d」</span>}<span class="op_no_ul">⇒</span><b>FALSE</b>「1」<span class="var"></span>で<span class="stri">{</span>「1」<span class="op_no_ul"></span>「3」<span class="stri">})</span>⇒<span class="stri"></span>TRUE<span class="stri">「2」</span><b>で</b>{<span class="var">「1」</span><span class="stri">「3」</span>})<span class="op_no_ul">⇒</span><span class="stri">FALSE</span>ない<span class="stri">baseType</span>ブール<span class="stri">ない</span>{2、3、5、7}<b>⇒</b><span class="var">FALSE</span>ない<span class="stri">{2、3、5、7}</span>⇒<span class="op_no_ul"></span>TRUE<span class="stri">&#39;a&#39;</span><span class="stri">ない</span>{<b>&#39;a&#39;</b><span class="var">「c」</span><span class="stri">「d」</span>}<span class="op_no_ul">⇒</span><span class="stri">FALSE</span>「b」<span class="stri"></span>ない<b>{</b>&#39;a&#39;<span class="var"></span>「c」<span class="op"></span>「d」<span class="type">}</span>⇒<a class="type" href="#types_boolean"></a>TRUE<span class="op_no_ul">「1」</span><b>ない</b>{<span class="var">「1」</span><span class="op_no_ul">「3」</span>})<b>⇒</b><span class="var">FALSE</span>「2」<span class="stri"></span>ない<span class="op_no_ul">{</span>「1」<span class="stri"></span>「3」<span class="stri">})</span>⇒<span class="stri"></span>TRUE<b>=</b><span class="var">&lt;></span>ブール<span class="stri">&lt;=</span>ブール<span class="op_no_ul">⇒</span><span class="stri">TRUE</span>で<span class="stri">A</span>および<span class="stri">×</span>ない<b>⇒</b><span class="var">FALSE</span>で<span class="stri">A</span>および<span class="op_no_ul">×</span>ない<span class="stri">setType</span>EMPTY_SET&lt;=A<span class="stri">⇒</span><b>TRUE</b>setType<span class="var">EMPTY_SET</span>⇒<span class="stri"></span>FALSE<span class="op_no_ul">⇒</span>&lt;<span class="stri">ブール</span>⇒<span class="stri">A&lt;=B</span>および<b>setType</b>EMPTY_SET&lt;A<span class="var">⇒</span><span class="op">TRUE</span>setType<span class="op">EMPTY_SET</span>⇒<a class="type" href="#types_boolean"></a>FALSE<span class="op">⇒</span>>=<a class="type" href="#types_boolean">ブール</a>⇒<b></b>TRUE<span class="var">で</span>B<span class="op">および</span>×<span class="op">ない</span>⇒<span class="op"></span>FALSE<b>で</b>B<span class="var">および</span>×<span class="op">ない</span>setType<span class="op">EMPTY_SET</span>⇒<span class="op"></span>TRUE<span class="type">setType</span>EMPTY_SET>=A<b>⇒</b><span class="var">FALSE</span>⇒<span class="type">></span>ブール<b>⇒</b>A>=B<span class="var">および</span>setType<b>EMPTY_SET</b>⇒<span class="op"></span>TRUE<a class="type" href="#types_boolean">setType</a>EMPTY_SET>A<b>⇒</b><span class="op">FALSE</span>⇒<span class="type">ビットセット</span>(A)翻訳<b>整数</b>番号付け<span class="var">ビットセット</span>整数<span class="type">ビットセット</span>(2220)<b>⇒</b>ビットセット<span class="var">(A)Convert a</span>文字列<b>に</b>ビットセット<span class="op">文字列</span>ビットセット<a class="type" href="#types_boolean">(&quot;{}&quot;)</a>⇒<b>ビットセット</b>(&quot;{2, 3, 5, 7}&quot;)<span class="var">⇒</span>整数<span class="op">(A)Convert a</span>ビットセット<span class="op">に</span>整数<span class="op">整数</span>整数<b>({2、3、5、7、11})</b>⇒<span class="var">カード</span>整数<span class="op">カード</span>({2、3、5、7、11})<span class="op">⇒</span>カード<span class="op">({</span>&#39;a&#39;<span class="type"></span>「b」<b></b>「c」<span class="var">})</span>⇒<span class="type">カード</span>({<b>「1」</b><span class="var">「2」</span><b>「3」</b>})<span class="op">⇒</span>カード<a class="type" href="#types_boolean">(</a>setType<b>EMPTY_SET)</b>⇒<span class="op">分</span>baseType<span class="type">分</span>({2、3、5、7、11})<b>⇒</b>分<span class="var">({</span>&#39;a&#39;<span class="type"></span>「b」<b></b>「c」<span class="var">})</span>⇒<b></b>&#39;a&#39;<span class="func">分</span>(<a class="type" href="#types_integer">setType</a>EMPTY_SET)<span class="type">⇒</span>例外<a class="type" href="#types_integer">範囲エラー</a>最大<span class="func">baseType</span>最大<b>({2、3、5、7、11})</b>⇒<span class="func">最大</span>({<a class="type" href="#types_string">&#39;a&#39;</a><span class="type">「b」</span><a class="type" href="#types_string">「c」</a>})<span class="func">⇒</span><b>「c」</b>最大<span class="func">(</span>setType<b>EMPTY_SET)</b>⇒<span class="func">例外</span>範囲エラー<span class="type">次の</span>baseType<a class="type" href="#types_integer">baseType</a>次の<a class="type" href="#types_integer">({2、3、5、7、11}、2)</a>⇒<span class="func">次の</span>({2、3、5、7、11}、3)<b>⇒</b>次の<span class="func">({2、3、5、7、11}、7)</span>⇒<a class="type" href="#types_integer">次の</a>({2、3、5、7、11}、11)<span class="func">⇒</span>例外<b>範囲エラー</b>次の<span class="func">({},1)</span>⇒<span class="stri">例外</span>範囲エラー<span class="stri">次の</span>(A, max(A))<span class="stri">⇒</span>例外<b>範囲エラー</b>str<span class="func">(A)〜への変換</span>文字列<span class="stri">文字列</span>str<span class="stri">(</span>setType<span class="stri">EMPTY_SET)</span>⇒<b></b>&quot;{}&quot;<span class="func">str</span>({})<span class="type">⇒</span><b>&quot;{}&quot;</b>str<span class="func">({1, 2})</span>⇒<span class="type"></span>&quot;{1, 2}&quot;<span class="func">ランド</span>baseType<b>ランド</b>(<span class="func">setType</span>EMPTY_SET)<span class="stri">⇒</span>例外<span class="stri">範囲エラー</span>比べる<span class="stri">整数</span>hashCode<b>整数</b>toArray<span class="stri">配列</span><span class="func">baseType</span>toArray<span class="type">({2、3、5})</span>⇒<b>toArray</b>({&#39;a&#39;,&#39;b&#39;,&#39;c&#39;})<a class="exception" href="#errors_RANGE_ERROR">⇒</a>:=<span class="func">&amp;:=</span>-:=<span class="type">@:=</span>baseType<span class="func">ブール</span>@:=<b>[B]</b>TRUE<span class="func"></span>⇒<span class="stri"></span>含む<span class="stri">@:=</span>[B]<span class="stri">FALSE</span><b>⇒</b><span class="stri">除く</span>含む<span class="func">baseType</span>除く<span class="type">baseType</span>無視する<b>の</b>forVar<a class="exception" href="#errors_RANGE_ERROR">範囲</a>aSet<span class="func">do</span>終わり<span class="type"></span>の<span class="type">baseType</span>proc<span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="type"></span><b></b><span class="stri"></span><span class="func"></span><b></b><span class="stri"></span><span class="func"></span><b></b><span class="stri"></span><span class="func"></span><span class="type"></span><span class="func"></span><span class="type"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_array"></a><span class="type"></span><span class="func"></span><b></b><span class="func"></span><b></b><span class="op"></span><span class="op"></span><span class="op"></span><span class="op"></span><span class="type"></span><a class="type" href="#types_boolean"></a><span class="op_no_ul"></span><span class="var"></span><b></b><span class="func"></span><span class="op_no_ul"></span><span class="var"></span><b></b><span class="func"></span><span class="func"></span><span class="type"></span><span class="func"></span><span class="type"></span><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_struct">
        <h3>5.13構造体</h3>
          </a>
        <p>型式<tt><span class="type">構造体</span></tt>すべての構造化タイプについて説明します。 構造体型宣言の例を次に示します。</p><pre class="indent">

;


<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:aStructType<span class="keywd">は</span><span class="keywd_no_ul">新しい</span><span class="keywd_no_ul">構造体</span>var<span class="keywd"></span>文字列<a class="type" href="#types_string">:name</a>は<span class="keywd"></span>&quot;&quot;<span class="stri">終わり</span><span class="keywd_no_ul">構造体</span><span class="keywd_no_ul"></span></pre><p>この型の変数は以下で宣言されます。</p><pre class="indent">value;
<span class="keywd">var</span><span class="type">aStructType</span>:aStructVariable<span class="keywd">は</span><span class="type">aStructType</span></pre><p>場所<tt><span class="type">aStructType</span>value</tt>すべての要素は、構造体宣言からの初期化値を持つ。<tt><span class="type">aStructType</span></tt>・加えて<tt><span class="type">aStructType</span>value</tt>構造体リテラルはありません。</p><pre class="tt">
タイプジェネレータ:



value;



新しい構造タイプを作成する




value;



サブタイプとして新規構造型を作成

建物ではなく




value;



サブタイプとして新規構造型を作成

構造体型です。 新しい構造型はすべてを継承します。
構造体型の要素



価値
構造体要素&#39;name&#39;を&#39;value&#39;で宣言します

インフィックス演算子:
STRUCTのアクセス要素
(例.要素)
->ptr STRUCTのアクセス要素
(例->要素)
リレーション:
=、&lt;>
ステートメント:

(A)値を無視(Ignore value)する
<span class="keywd_no_ul">新しい</span><span class="keywd_no_ul">構造体</span>var<span class="keywd"></span>aType<span class="type">:name</span>は<span class="keywd">終わり</span><span class="keywd_no_ul">構造体</span>新しい<span class="keywd_no_ul"></span>baseType<span class="keywd_no_ul"></span>構造体<span class="type">var</span><span class="keywd_no_ul">aType</span>:name<span class="keywd">は</span>終わり<span class="type"></span>構造体<span class="keywd">baseType</span>サブ<span class="keywd_no_ul"></span>baseType<span class="keywd_no_ul"></span>構造体<tt><span class="type">var</span></tt><span class="keywd_no_ul">aType</span>:name<span class="type">は</span>終わり<span class="keywd_no_ul"></span>構造体<span class="keywd">baseType</span>baseType<span class="type">var</span><span class="keywd">aType</span>:name<span class="keywd_no_ul">は</span>無視する<span class="keywd_no_ul"></span><tt><span class="type"></span></tt><tt><span class="type"></span></tt><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_enumeration">
        <h3>5.14列挙</h3>
          </a>
        <p>有</p><pre class="indent">
列挙型リテラル1、列挙型リテラル2

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:anEnumType<span class="keywd">は新しい列挙型です。</span>エンド列挙型<span class="keywd"></span></pre><p>新しい列挙型が宣言されます。 この型の値は次のとおりです。</p><pre class="box">enum_literal1とenum_literal2
</pre><p>列挙型では、少数の操作だけが事前定義されています。 追加の操作は別に定義する必要があります。 したがって、関数を定義する必要があります。<tt><span class="func">str</span></tt>および<tt><font color="blue">解析する</font></tt>新しい列挙型に対して入出力を行います。 例:</p><pre class="indent">

literal(enumValue);

enable_output(
);
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:str(<a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">anEnumType</span>:enum値)<span class="keywd">は</span>リターン<span class="keywd">anEnumType</span><span class="type"></span></pre><p>定義する必要性<tt><span class="func">str</span></tt>は、元のリテラルとは異なる文字列に変換する機会を開きます。</p><pre class="tt">
定数:

(enum_literal1)

(enum_literal1)

(enum_literal2)
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


enum_literal1

enum_literal2



)


(結果の種類:


0

1)
リレーション:

、&lt;、&lt;=、>、>=
機能:

(A)序数
(結果の種類:


0

1)

(A)序数
(結果の種類:


0

1)

(ア)承継人
(
(A))

enum_literal2

)

①前任者
(
(A))

enum_literal1

)

(A)直定数化
(結果の種類:


&quot;enum_literal1&quot;

&quot;enum_literal2&quot;)

(A, B)[A, B]の範囲のランダムな値
ランダム値は一様分布です。
(
(A, B)は、以下のようなランダムな列挙値を返す。
A&lt;=
(A, B)≦Bが成立する。

A

)

(A, B)比較関数
(結果の種類:


-1

0

1)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)インクリメント
(
(A))

(A)減分
(
(A))

(A)値を無視(Ignore value)する
<span class="type">anEnumType</span><span class="var">価値</span>既定値<span class="type">anEnumType</span>anEnumType<span class="type"></span>1番目<span class="var">最小値</span>anEnumType<span class="type">anEnumType</span><span class="type">最後の</span>の最大値<span class="var">anEnumType</span><span class="type">B</span>:<span class="op">ブール</span>TRUE<span class="op">a:b</span>⇒<a class="type" href="#types_boolean">FALSE</a>a:b<span class="var">⇒</span>anEnumType<b></b>conv<span class="var">A変換元</span>整数<b>Aから</b>anEnumType<span class="type">整数</span>anEnumType<span class="op"></span>conv<a class="type" href="#types_integer">0</a>⇒<span class="type">anEnumType</span><a class="type" href="#types_integer">conv</a>1<span class="type">⇒</span>anEnumType<span class="op_no_ul"></span>conv<b>2</b>⇒<span class="type">例外</span>範囲エラー<span class="op_no_ul">anEnumType</span><b>conv</b>(-1)<span class="type">⇒</span>例外<span class="op_no_ul">範囲エラー</span>整数<b></b>conv<a class="exception" href="#errors_RANGE_ERROR">A変換元</a>anEnumType<span class="type">Aから</span>整数<span class="op_no_ul">整数</span>整数<b></b>conv<a class="exception" href="#errors_RANGE_ERROR">enum_literal1</a>⇒<a class="type" href="#types_integer">整数</a><span class="op">conv</span>enum_literal2<span class="type">⇒</span>=<a class="type" href="#types_integer"></a>&lt;><a class="type" href="#types_integer">ord</a>整数<a class="type" href="#types_integer">ord</a>(enum_literal1)<span class="op_no_ul">⇒</span>ord<b>(enum_literal2)</b>⇒<a class="type" href="#types_integer">整数</a>整数<span class="op_no_ul">整数</span>(enum_literal1)<b>⇒</b>整数<span class="op">(enum_literal2)</span>⇒<span class="op">水</span>水<span class="func">(A)</span>⇒<a class="type" href="#types_integer">列挙型</a>conv<span class="func"></span>水<b>(</b>ord<span class="func">水</span>(enum_literal1)<b>⇒</b>水<span class="func">(</span>anEnumType<a class="type" href="#types_integer"></a>最後の<span class="func">)</span>⇒<b>例外</b>範囲エラー<span class="func">pred</span>pred<b>(A)</b>⇒<span class="func">列挙型</span>conv<span class="func"></span>pred<b>(</b>ord<span class="op_no_ul">pred</span>(enum_literal2)<span class="func">⇒</span>pred<span class="func">(</span>anEnumType<span class="func"></span>1番目<b>)</b>⇒<span class="func">例外</span>範囲エラー<span class="type">文字通りの</span>文字列<span class="var">文字通りの</span>(enum_literal1)<b>⇒</b>文字通りの<a class="exception" href="#errors_RANGE_ERROR">(enum_literal2)</a>⇒<span class="func">ランド</span>ランド<span class="func">ランド</span>(A、B)<b>および</b><span class="op_no_ul">ランド</span>ランド<span class="func">(A、A)</span>⇒<span class="func">ランド</span>(enum_literal2, enum_literal1)<span class="func">⇒</span>例外<b>範囲エラー</b>比べる<span class="func">整数</span>比べる<span class="type">(enum_literal1, enum_literal2)</span>⇒<span class="var">比べる</span>(enum_literal1, enum_literal1)<b>⇒</b>比べる<a class="exception" href="#errors_RANGE_ERROR">(enum_literal2, enum_literal1)</a>⇒<span class="func">hashCode</span>整数<a class="type" href="#types_string">増加</a>増加<span class="func">(A)</span>⇒<b>A:=</b>水<span class="func">decr</span>decr<b>(A)</b>⇒<span class="func">A:=</span>pred<span class="func">無視する</span><span class="func"></span><span class="op"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_bin64">
        <h3>5.15ビン64</h3>
          </a>
        <p>型式<tt><span class="type">bin64</span></tt>では、64ビットのビットパターンについて説明します。 これは<tt><a class="type" href="#types_integer">整数</a></tt>責任分担が存在する。 型式<tt><span class="type">bin64</span></tt>はビット単位の演算用で<tt><a class="type" href="#types_integer">整数</a></tt>は算術演算用です。 コンパイルされたプログラムにおける変換<tt><span class="type">bin64</span></tt>および<tt><a class="type" href="#types_integer">整数</a></tt>オーバーヘッドがない。</p><pre class="tt">
定数:

(〇))
前置演算子:

ビット否定
インフィックス演算子:

ビット単位および

ビット単位の包含or

ビット単位排他的論理和(xor)
A
Bシフトレフト
(引数Bのタイプ:

A&lt;&lt;BはB>=0およびB&lt;=63で使用できます。
A&lt;&lt;B
B&lt;0またはB>=64のとき
A&lt;&lt;0
A

(16#234567890abcde00))
A
B右シフト
(引数Bのタイプ:

A>>BはB>=0およびB&lt;=63でOKです。
A>>B
B&lt;0またはB>=64のとき
A>>0
A

(16#1234567890 abcde))
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)
A
B基数を用いて文字列に変換する
(結果の種類:

引数Bの型:
)
A
B基数を用いて文字列に変換する
(結果の種類:

引数Bの型:
)


(結果の種類:
)


(引数Aのタイプ:
)
リレーション:


機能:


(引数のタイプ:
)


(引数のタイプ:
)


(引数のタイプ:
)


(引数のタイプ:


(16#3ff0000000000000))

(A)序数
(結果の種類:
)

(A)序数
(結果の種類:
)


(結果の種類:
)


(結果の種類:
)

IEEE 754倍精度表現のビットから
(結果の種類:


1.0)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)

(A)最小2進表現のビット数。
(結果の種類:

bitLength(bin64(0))
0
bitLength(bin64(1))
1
bitLength(bin64(4))
3)

(A)2進表現における最下位の0ビットの数。
(結果の種類:

A>>B&lt;&lt;B=A for A&lt;>bin64(0)and B=lowestSetBit(A)
lowestSetBit(bin64(0))
-1
lowestSetBit(bin64(1))
0
lowestSetBit(bin64(2))
1)

価値
ランダム値は一様分布です。
(
)))


(結果の種類:


)

ビッグエンディアンエンコーディングによるバイトの
(結果の種類:
)

リトルエンディアンの符号化によるバイトの
(結果の種類:
)

(A, B)AのビットをBビットだけ左に回転させる
(
(16#43210fedcba98765))

(A, B)AのビットをBビットだけ右に回転させる
(
(16#10fedcba98765432))

(aBitset, lowestBitNum)lowestBitNumから始まるaBitsetから64ビットを取得します。
(引数aBitsetのタイプ:

引数lowestBitNumのタイプ:
)

(フロート、ダブル) FloatUPからMBF倍精度表現のビットを取得します。
Microsoftバイナリ形式(MBF)は、浮動小数点数の形式です。
(引数FloatUPの型:


(16#8100000000000000_))

(ビット) MBF倍精度表現のビットからfloatを取得します。
Microsoftバイナリ形式(MBF)は、浮動小数点数の形式です。
(結果の種類:


1.0)


(引数バイトの種類:
)


(引数バイトの種類:
)
ステートメント:
A
Bビット単位およびコピー
(A&amp;:=B⇒A:=A&amp;B)
A
Bビット単位の包含またはコピー
(A:=B⇒A:=AB)
A
Bビット単位の排他的論理和(xor)コピー
(A>&lt;:= B ⇒ A := A >&lt;B)
A
Bシフトレフトコピー
(A&lt;&lt;:=B⇒A:=A&lt;&lt;B)
A
B右シフトコピー
(A>>:=B⇒A:=A>>B)

(A)値を無視(Ignore value)する
<span class="type">bin64</span><span class="var">価値</span>既定値<span class="type">bin64</span>(<span class="func">bin64</span>~<span class="op">&amp;</span><span class="op">>&lt;</span>&lt;&lt;<span class="op">整数</span>⇒<span class="op">例外</span>OVERFLOW_ERROR<span class="op">⇒</span>bin64<a class="type" href="#types_integer">(16#1234567890abcde0)</a>&lt;&lt;<b>4</b>⇒<a class="exception" href="#errors_OVERFLOW_ERROR"></a>bin64<b>>></b>整数<span class="func">⇒</span>例外<span class="op">OVERFLOW_ERROR</span>⇒<b>bin64</b>(16#1234567890abcde0)<span class="func">>></span>4<span class="op">⇒</span><a class="type" href="#types_integer">bin64</a><b>B</b>:<a class="exception" href="#errors_OVERFLOW_ERROR">ブール</a>TRUE<b>a:b</b>⇒<span class="func">FALSE</span>a:b<span class="op">⇒</span>基数<b>文字列</b>整数<span class="func">RADIX</span>文字列<span class="op">整数</span>整数<span class="op"></span>conv<a class="type" href="#types_boolean">A変換</a>整数<span class="var">整数</span>bin64<b></b>conv<span class="var">A変換</span>bin64<b>整数</b>=<span class="op"></span>&lt;><a class="type" href="#types_string">bin64</a>(ア)Conversion of<a class="type" href="#types_integer">整数</a>へ<span class="op">bin64</span>整数<a class="type" href="#types_string">bin64</a>(ア)Conversion of<a class="type" href="#types_integer">bigInteger</a>へ<a class="type" href="#types_integer">bin64</a>bigInteger<span class="op">bin64</span>(ア)Conversion of<a class="type" href="#types_integer">char</a>へ<a class="type" href="#types_integer">bin64</a>char<span class="type">bin64</span>(A)IEEE 754倍精度表現のビットを<span class="op">浮かぶ</span>浮かぶ<span class="type">bin64</span>(1.0)<a class="type" href="#types_integer">⇒</a><span class="op">bin64</span>ord<span class="op">整数</span>整数<span class="func">整数</span>大きい<a class="type" href="#types_integer">(A)〜への変換</a>bigInteger<span class="type">bigInteger</span>bigInteger<a class="type" href="#types_integer">(A)〜への変換</a>bigInteger<span class="func">bigInteger</span>浮かぶ<a class="type" href="#types_bigInteger">(A)Get</a>浮かぶ<span class="type">浮かぶ</span>浮かぶ<a class="type" href="#types_bigInteger">(</a>bin64<span class="func">(16#3ff0000000000000))</span>⇒<a class="type" href="#types_char">比べる</a>整数<span class="type">hashCode</span>整数<a class="type" href="#types_char">bitLength</a>整数<span class="func">⇒</span>⇒<a class="type" href="#types_float">⇒</a>lowestSetBit<a class="type" href="#types_float">整数</a>⇒<span class="func">⇒</span>⇒<b>ランド</b>(<span class="func">bin64</span>)ランダム<span class="func">bin64</span>ランド<a class="type" href="#types_integer">(</a>bin64<span class="func">)</span>⇒<a class="type" href="#types_integer"></a>bin64<span class="func">(</span>ランド<a class="type" href="#types_bigInteger">(</a>整数<a class="type" href="#types_bigInteger"></a>1番目<span class="func"></span>整数<a class="type" href="#types_bigInteger"></a>最後の<a class="type" href="#types_bigInteger">str</a>(A)〜への変換<span class="func">文字列</span>文字列<a class="type" href="#types_float">str</a>(<a class="type" href="#types_float">bin64</a>(18446744073709551615_))<span class="func">⇒</span><span class="func">&quot;18446744073709551615&quot;</span>バイト<b>(aBin64, BE, len)に変換します。</b>文字列<span class="func">文字列</span>バイト<a class="type" href="#types_integer">(aBin64, LE, len)に変換します。</a>文字列<span class="func">文字列</span>rotLeft<a class="type" href="#types_integer">rotLeft</a>(<span class="func">bin64</span>(16#76543210fedcba98)、12)<a class="type" href="#types_integer">⇒</a><b>bin64</b>rotRight<b>rotRight</b>(<b>bin64</b>(16#76543210fedcba98)、40)<span class="func">⇒</span><a class="type" href="#types_integer">bin64</a>getBinary<b>ビットセット</b>整数<b>float2MbfBits</b>浮かぶ<b>float2MbfBits</b>(1.0、DOUBLE)<span class="func">⇒</span><span class="type">bin64</span>mbfBits 2浮動小数点<span class="type">浮かぶ</span>mbfBits 2浮動小数点<span class="func">(</span>bin64<span class="type">(16#8100000000000000_))</span>⇒<b>bin64</b>(bytes, LE)変換<span class="func">文字列</span>リトルエンディアンのバイト数<span class="func">bin64</span>文字列<a class="type" href="#types_integer">bin64</a>(bytes, BE)Convert<span class="var">文字列</span>にビッグエンディアンバイトの<a class="type" href="#types_integer">bin64</a>文字列<span class="var">&amp;:=</span>:=<span class="func">>&lt;:=</span>&lt;&lt;:=<a class="type" href="#types_string">>>:=</a>無視する<a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><b></b><span class="stri"></span><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><a class="type" href="#types_set"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_float"></a><span class="func"></span><b></b><span class="func"></span><span class="func"></span><a class="type" href="#types_float"></a><span class="func"></span><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_bin32">
        <h3>5.16ビン32</h3>
          </a>
        <p>型式<tt><span class="type">ビン32</span></tt>では、32ビットのビットパターンについて説明します。 これは<tt><a class="type" href="#types_integer">整数</a></tt>責任分担が存在する。 型式<tt><span class="type">ビン32</span></tt>はビット単位の演算用で<tt><a class="type" href="#types_integer">整数</a></tt>は算術演算用です。 コンパイルされたプログラムにおける変換<tt><span class="type">ビン32</span></tt>および<tt><a class="type" href="#types_integer">整数</a></tt>オーバーヘッドがない。</p><pre class="tt">
定数:

(〇))
前置演算子:

ビット否定
インフィックス演算子:

ビット単位および

ビット単位の包含or

ビット単位排他的論理和(xor)
A
Bシフトレフト
(引数Bのタイプ:

A&lt;&lt;BはB>=0およびB&lt;=63で使用できます。
A&lt;&lt;B
B&lt;0またはB>=64のとき
A&lt;&lt;0
A

(16#abcdef0))
A
B右シフト
(引数Bのタイプ:

A>>BはB>=0およびB&lt;=63でOKです。
A>>B
B&lt;0またはB>=64のとき
A>>0
A

(16#abcde))
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)
A
B基数を用いて文字列に変換する
(結果の種類:

引数Bの型:
)
A
B基数を用いて文字列に変換する
(結果の種類:

引数Bの型:
)


(結果の種類:
)


(引数Aのタイプ:
)
リレーション:


機能:


(引数のタイプ:
)


(引数のタイプ:
)


(引数のタイプ:


(16#3f800000))

(A)序数
(結果の種類:
)

(A)序数
(結果の種類:
)

IEEE 754単精度表現のビットから
(結果の種類:


1.0)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)

(A)最小2進表現のビット数。
(結果の種類:

bitLength(bin32(0))
0
bitLength(bin32(1))
1
bitLength(bin32(4))
3)

(A)2進表現における最下位の0ビットの数。
(結果の種類:

A>>B&lt;&lt;B=A for A&lt;>bin32(0)and B=lowestSetBit(A)
lowestSetBit(bin32(0))
-1
lowestSetBit(bin32(1))
0
lowestSetBit(bin32(2))
1)

価値
ランダム値は一様分布です。
(
(0、4294967295)))


(結果の種類:


)

ビッグエンディアンエンコーディングによるバイトの
(結果の種類:
)

リトルエンディアンの符号化によるバイトの
(結果の種類:
)

(A, B)AのビットをBビットだけ左に回転させる
(
(16#34567812))

(A, B)AのビットをBビットだけ右に回転させる
(
(16#78123456))

(フロート、シングル) FloatUPからMBF単精度表現のビットを取得します。
Microsoftバイナリ形式(MBF)は、浮動小数点数の形式です。
(引数FloatUPの型:


(16#81000000))

(ビット) MBF単精度表現のビットからfloatを取得します。
Microsoftバイナリ形式(MBF)は、浮動小数点数の形式です。
(結果の種類:


1.0)


(引数バイトの種類:
)


(引数バイトの種類:
)
ステートメント:
A
Bビット単位およびコピー
(A&amp;:=B⇒A:=A&amp;B)
A
Bビット単位の包含またはコピー
(A:=B⇒A:=AB)
A
Bビット単位の排他的論理和(xor)コピー
(A>&lt;:= B ⇒ A := A >&lt;B)
A
Bシフトレフトコピー
(A&lt;&lt;:=B⇒A:=A&lt;&lt;B)
A
B右シフトコピー
(A>>:=B⇒A:=A>>B)

(A)値を無視(Ignore value)する
<span class="type">ビン32</span><span class="var">価値</span>既定値<span class="type">ビン32</span>(<span class="func">ビン32</span>~<span class="op">&amp;</span><span class="op">>&lt;</span>&lt;&lt;<span class="op">整数</span>⇒<span class="op">例外</span>OVERFLOW_ERROR<span class="op">⇒</span>ビン32<a class="type" href="#types_integer">(16#abcdef)</a>&lt;&lt;<b>4</b>⇒<a class="exception" href="#errors_OVERFLOW_ERROR"></a>ビン32<b>>></b>整数<span class="func">⇒</span>例外<span class="op">OVERFLOW_ERROR</span>⇒<b>ビン32</b>(16#abcdef)<span class="func">>></span>4<span class="op">⇒</span><a class="type" href="#types_integer">ビン32</a><b>B</b>:<a class="exception" href="#errors_OVERFLOW_ERROR">ブール</a>TRUE<b>a:b</b>⇒<span class="func">FALSE</span>a:b<span class="op">⇒</span>基数<b>文字列</b>整数<span class="func">RADIX</span>文字列<span class="op">整数</span>整数<span class="op"></span>conv<a class="type" href="#types_boolean">A変換</a>整数<span class="var">整数</span>ビン32<b></b>conv<span class="var">A変換</span>ビン32<b>整数</b>=<span class="op"></span>&lt;><a class="type" href="#types_string">ビン32</a>(ア)Conversion of<a class="type" href="#types_integer">整数</a>へ<span class="op">ビン32</span>整数<a class="type" href="#types_string">ビン32</a>(ア)Conversion of<a class="type" href="#types_integer">char</a>へ<a class="type" href="#types_integer">ビン32</a>char<span class="op">ビン32</span>(A)IEEE 754単精度表現のビットを<a class="type" href="#types_integer">浮かぶ</a>浮かぶ<a class="type" href="#types_integer">ビン32</a>(1.0)<span class="type">⇒</span><span class="op">ビン32</span>ord<span class="type">整数</span>整数<a class="type" href="#types_integer">整数</a>浮かぶ<span class="op">(A)Get</span>浮かぶ<span class="op">浮かぶ</span>浮かぶ<span class="func">(</span>ビン32<a class="type" href="#types_integer">(16#3f800000))</a>⇒<span class="type">比べる</span>整数<a class="type" href="#types_integer">hashCode</a>整数<span class="func">bitLength</span>整数<a class="type" href="#types_char">⇒</a>⇒<span class="type">⇒</span>lowestSetBit<a class="type" href="#types_char">整数</a>⇒<span class="func">⇒</span>⇒<a class="type" href="#types_float">ランド</a>(<a class="type" href="#types_float">ビン32</a>)ランダム<span class="func">ビン32</span>ランド<b>(</b>ビン32<span class="func">)</span>⇒<span class="func"></span>ビン32<a class="type" href="#types_integer">(</a>ランド<span class="func">str</span>(A)〜への変換<a class="type" href="#types_integer">文字列</a>文字列<span class="func">str</span>(<a class="type" href="#types_float">ビン32</a>(4294967295))<a class="type" href="#types_float">⇒</a><span class="func">&quot;4294967295&quot;</span>バイト<span class="func">(aBin32, BE, len)に変換します。</span>文字列<b>文字列</b>バイト<span class="func">(aBin32, LE, len)に変換します。</span>文字列<a class="type" href="#types_integer">文字列</a>rotLeft<span class="func">rotLeft</span>(<a class="type" href="#types_integer">ビン32</a>(16#12345678)、8)<span class="func">⇒</span><a class="type" href="#types_integer">ビン32</a>rotRight<b>rotRight</b>(<b>ビン32</b>(16#12345678)、8)<b>⇒</b><span class="func">ビン32</span>float2MbfBits<a class="type" href="#types_integer">浮かぶ</a>float2MbfBits<b>(1.0、SINGLE)</b>⇒<b></b>ビン32<b>mbfBits 2浮動小数点</b>浮かぶ<span class="func">mbfBits 2浮動小数点</span>(<span class="type">ビン32</span>(16#81000000))<span class="type">⇒</span>ビン32<span class="func">(bytes, LE)変換</span>文字列<span class="type">リトルエンディアンのバイト数</span>ビン32<b>文字列</b>ビン32<span class="func">(bytes, BE)Convert</span>文字列<span class="func">にビッグエンディアンバイトの</span>ビン32<span class="func">文字列</span>&amp;:=<a class="type" href="#types_string">:=</a>>&lt;:=<a class="type" href="#types_string">&lt;&lt;:=</a>>>:=<span class="func">無視する</span><span class="func"></span><b></b><span class="stri"></span><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><b></b><span class="func"></span><span class="func"></span><a class="type" href="#types_float"></a><span class="func"></span><b></b><span class="func"></span><span class="func"></span><a class="type" href="#types_float"></a><span class="func"></span><span class="func"></span><b></b><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_bstring">
        <h3>5.17ボーリング</h3>
          </a>
        <p>型式<tt><span class="type">bstring</span></tt>はバイト列を記述する。 バイナリー・データを格納するのに使用されます。</p><pre class="tt">
定数:

))
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:
)
指標:

1文字にアクセスする
(引数Aのタイプ:

結果のタイプ:
)
機能:


(結果の種類:
)

(A)直定数化
(結果の種類:
)


(結果の種類:
)


(引数Aのタイプ:
)


(結果の種類:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)


(引数のタイプisSigned:

結果のタイプ:
)


(引数のタイプisSigned:

結果のタイプ:
)


(引数Aのタイプ:

引数のタイプisSigned:
)


(引数Aのタイプ:

引数のタイプisSigned:
)
リレーション:


ステートメント:

(A)値を無視(Ignore value)する


声明

bstringのすべての要素をループする
(forVarの引数の型:

引数文のタイプ:
)
<span class="type">bstring</span><span class="var">価値</span>既定値<span class="type">bstring</span>(<span class="func">bstring</span>(<span class="stri">&quot;&quot;</span><span class="op">B</span>:<span class="op">ブール</span>TRUE<a class="type" href="#types_boolean">a:b</a>⇒<span class="var">FALSE</span>a:b<b>⇒</b>bstring<span class="var"></span>解析する<b>A変換</b>文字列<span class="type">へ</span>bstring<span class="op">文字列</span>[<a class="type" href="#types_string">A</a>]<span class="type">整数</span>char<a class="type" href="#types_string">str</a>(A)〜への変換<span class="op">文字列</span>文字列<span class="op">文字通りの</span>文字列<a class="type" href="#types_integer">文字列</a>(A)〜への変換<a class="type" href="#types_char">文字列</a>文字列<span class="func">bstring</span>(A)〜への変換<a class="type" href="#types_string">bstring</a>文字列<a class="type" href="#types_string">長さ</a>(A)長さ<span class="func">bstring</span>整数<a class="type" href="#types_string">比べる</a>整数<span class="func">hashCode</span>整数<a class="type" href="#types_string">BTstRibe 2 BigInt</a>(A, isSigned)<a class="type" href="#types_string">bstring</a>(ビッグエンディアンとして解釈される)から<span class="func">bigInteger</span>ブール<span class="type">bigInteger</span>bStriLe2BigInt<a class="type" href="#types_string">(A, isSigned)</a>bstring<span class="func">(リトルエンディアンと解釈されます)から</span>bigInteger<span class="type">ブール</span>bigInteger<a class="type" href="#types_integer">bStriBe</a>(A, isSigned)<span class="func">bigInteger</span>ビッグエンディアンに<a class="type" href="#types_integer">bstring</a>bigInteger<span class="func">ブール</span>bStriLe<a class="type" href="#types_integer">(A, isSigned)</a>bigInteger<span class="func">リトルエンディアンに</span>bstring<span class="type">bigInteger</span>ブール<a class="type" href="#types_bigInteger">=</a><a class="type" href="#types_boolean">&lt;></a>無視する<a class="type" href="#types_bigInteger">の</a>forVar<span class="func">範囲</span>bstri<span class="type">do</span>終わり<a class="type" href="#types_bigInteger"></a>の<a class="type" href="#types_boolean">char</a>proc<a class="type" href="#types_bigInteger"></a><span class="func"></span><a class="type" href="#types_bigInteger"></a><span class="type"></span><a class="type" href="#types_bigInteger"></a><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_bigInteger"></a><span class="type"></span><a class="type" href="#types_bigInteger"></a><a class="type" href="#types_boolean"></a><span class="op"></span><span class="op"></span><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_char"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_color">
        <h3>5.18色</h3>
          </a>
        <p>型式<tt><span class="type">色</span></tt>に色の説明があります。 赤、緑、青の光による加色モデルを使用しています。 赤、緑、青のライトは<tt><a class="type" href="#types_integer">整数</a></tt>範囲の値は0. 65535.<tt><span class="type">色</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">color.s7i</span>&quot;</span></p><pre class="tt">
要素:

0;

0;

0;
定数:

(黒)
black color(0, 0, 0);
dark_red color(32768, 0, 0);
dark_green color(0, 32768, 0);
brown color(32768, 16384, 0);
dark_blue color(0, 0, 32768);
dark_magenta color(32768, 0, 32768);
dark_cyan color(0, 65535, 65535);
light_gray color(49152, 49152, 49152);
dark_gray color(16384, 16384, 16384);
light_red color(65535, 0, 0);
light_green color(0, 65535, 0);
yellow color(65535, 65535, 0);
light_blue color(0, 0, 65535);
light_magenta color(65535, 0, 65535);
light_cyan color(32768, 65535, 65535);
white color(65535, 65535, 65535);
オレンジカラー(65535, 32768, 0);
アンバー色(49152, 32768, 16384);
ピンク(65535, 32768, 32768);
インフィックス演算子:

加法カラーシステムで2色を追加する
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)
リレーション:


機能:

(R、G、B) 赤、緑、青から色を作成します
(引数Rの型:

引数Gの型:

引数Bの型:
)

(BR)BRからグレーカラー値を作成する
(引数BRのタイプ:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)現在のウィンドウをクリアする

(A)値を無視(Ignore value)する
<span class="keywd">var</span><a class="type" href="#types_integer">整数</a>:redLight<span class="keywd">は</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:greenLight</a>は<span class="keywd">var</span><span class="keywd">整数</span>:blueLight<a class="type" href="#types_integer">は</a>色<span class="keywd"></span>価値<span class="type">既定値</span>色<span class="var">+</span><span class="type">B</span>:<span class="op">ブール</span>TRUE<span class="op">a:b</span>⇒<span class="op">FALSE</span>a:b<a class="type" href="#types_boolean">⇒</a>=<span class="var"></span>&lt;><b>色</b>整数<span class="var">整数</span>整数<b>灰色</b>整数<span class="op">比べる</span>整数<span class="op">hashCode</span>整数<span class="func">晴れた</span>無視する<a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_time">
        <h3>5.19倍</h3>
          </a>
        <p>型式<tt><span class="type">時間</span></tt>時刻と日付を記述する。 日付については、プロレプティック・グレゴリオ暦が使用される(これは、グレゴリオ暦が公式に導入される前の日付でも有効であったことを前提とする)。 この規則はISO 8601に従って使用されています。ISO 19005では、正の年と負の年が存在し、1の前年は0であると定義されています。 時間は、時、分、秒、およびマイクロ秒で測定されます。 さらに、UTCとの差分、およびサマータイムを示すフラグに関する情報も保持されます。 その<tt><span class="type">時間</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">時間.s7i</span>&quot;</span></p><pre class="tt">
要素:

0;

1;

1;

0;

0;

0;

0;
定数:

(time(0, 1, 1, 0, 0, 0))
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


2005-02-28 12:00:01

)
リレーション:


機能:

(NOW)現在の時刻を取得します。


(引数Aのタイプ:


2005-02-28 12:00:01

)


(結果の種類:
)


ISO 8601 YYYY-MM-DD日付形式で
(結果の種類:
)


ISO 8601 hh:mm:ss時刻形式
(結果の種類:
)


(ISO 8601 YYYY-MM-DD hh:mm:ss形式)
(結果の種類:
)
strTimeZone(A)タイムゾーンからへの変換

(結果の種類:
)

(A)時間を秒に切り捨てる

(A)時間を1分に切り捨てる

(A)時間を1時間に切り捨てる

(A)時間を一日に切り捨てる

(A)時間を一ヶ月に切り捨てる

(A)時間を年に切り捨てる

(A)特定の年がうるう年であるかどうかを調べる
(引数Aのタイプ:
)
(結果の種類:
)

Y 1年間の日数を計算する
(引数Yのタイプ:

結果のタイプ:
)

(Y, M)月の日数を計算する
(引数Yのタイプ:

引数Mの型:

結果のタイプ:
)

(A)月の日数を計算する
(結果の種類:
)

イ月曜日を1とする曜日
(結果の種類:
)

イ1月1日を1とする年中の日
(結果の種類:
)

(Y, D)1年の第何週目かを計算する(0～53)
ISO 8601による:第1週
毎年、4が含まれます。 1月。
(引数Yのタイプ:

引数Dの型:

結果のタイプ:
)

(A)1年の週番号(0～53)を計算する。
ISO 8601による:第1週
毎年、4が含まれます。 1月。
(結果の種類:
)

(A)ISO 8601 weekの日付の年を計算する
(結果の種類:
)

(A)ISO 8601 weekの日付の週を計算する
(結果の種類:
)

(ア)協定世界時(UTC:Coordinated Universal Time)への変換

指定された時刻をローカル・タイムゾーンの時刻に変換します。

指定された時間のtimeZoneとdaylightSavingTimeを設定します。

イ次に掲げる日から経過した日数
ユリウス暦の紀元前4713年1月1日
(結果の種類:
)

(A)ユリウス日を時間に変換する
(引数Aのタイプ:
)

(A)始動からの経過時間(秒)
Unixエポック(1970-01-01 00:00:00 UTC)
(結果の種類:
)

(A)Unixタイムスタンプを
現地時間帯
(引数Aのタイプ:
)

(A)放電開始から100ナノ秒の間隔
Windowsエポック(1601-01-01 00:00:00 UTC)
(結果の種類:
)

(A)FILETIMEをの時刻に変換します。
現地時間帯
(引数Aのタイプ:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)与えられた時間まで待つ

(A)値を無視(Ignore value)する
<span class="keywd">var</span><a class="type" href="#types_integer">整数</a>:年<span class="keywd">は</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:月</a>は<span class="keywd">var</span><span class="keywd">整数</span>:日<a class="type" href="#types_integer">は</a>var<span class="keywd"></span>整数<span class="keywd">:時</span>は<a class="type" href="#types_integer">var</a><span class="keywd">整数</span>:分<span class="keywd">は</span>var<a class="type" href="#types_integer"></a>整数<span class="keywd">:第2</span>は<span class="keywd">var</span><a class="type" href="#types_integer">整数</a>:マイクロ秒<span class="keywd">は</span>時間<span class="keywd"></span>価値<a class="type" href="#types_integer">既定値</a>時間<span class="keywd"></span>B<span class="type">:</span>ブール<span class="var">TRUE</span>a:b<span class="type">⇒</span>FALSE<span class="op">a:b</span>⇒<span class="op">時間</span><a class="type" href="#types_boolean">解析する</a>A変換<span class="var">文字列</span>へ<b>時間</b>文字列<span class="var">時間</span><b>解析する</b><span class="type">&quot;2005-02-28 12:00:01&quot;</span><span class="op">⇒</span>時間<a class="type" href="#types_string"></a>解析する<span class="type"></span>&quot;2005-02-29 12:00:01&quot;<a class="type" href="#types_string"></a>⇒<span class="type">例外</span>範囲エラー<span class="op">=</span><span class="stri">&lt;></span><b>&lt;</b><span class="type">&lt;=</span><span class="op">></span><span class="stri">>=</span>時間<b>時間</b>(ア)Conversion of<a class="exception" href="#errors_RANGE_ERROR">文字列</a>へ<span class="op">時間</span>文字列<span class="op">時間</span>(<span class="op">&quot;2005-02-28 12:00:01&quot;</span>)<span class="op">⇒</span>時間<span class="op">(</span>&quot;2005-02-29 12:00:01&quot;<span class="op">)</span>⇒<span class="func">例外</span>範囲エラー<span class="func">str</span>(A)〜への変換<a class="type" href="#types_string">文字列</a>文字列<span class="type">strDate</span>イ当該日から<a class="type" href="#types_string">文字列</a>文字列<span class="func">strTime</span>(A)昼間から昼間への変換<span class="stri">文字列</span>文字列<b>strDateTime</b>イ日時のからへの変換<span class="func">文字列</span>文字列<span class="stri">文字列</span>文字列<b>truncToSecond</b>truncToMinute<a class="exception" href="#errors_RANGE_ERROR">truncToHour</a>truncToDay<span class="func">今月(3月)</span>今年いっぱい<a class="type" href="#types_string">IsReapYear</a>整数<a class="type" href="#types_string">ブール</a>daysInYear<span class="func">整数</span>整数<a class="type" href="#types_string">daysInMonth</a>整数<a class="type" href="#types_string">整数</a>整数<span class="func">daysInMonth</span>整数<a class="type" href="#types_string">dayOfWeek</a>整数<a class="type" href="#types_string">dayOfYear</a>整数<span class="func">weekOfYear</span>整数<a class="type" href="#types_string">整数</a>整数<a class="type" href="#types_string">weekOfYear</a>整数<a class="type" href="#types_string">weekDateYear</a>整数<a class="type" href="#types_string">weekDateWeek</a>整数<span class="func">東UTC</span>toLocalTZ<span class="func">setLocalTZ</span>julianDayNumber<span class="func">整数</span>julianDayNumToTime<span class="func">整数</span>タイムスタンプ1970<span class="func">整数</span>timestamp1970ToTime<span class="func">整数</span>タイムスタンプ1601<span class="func">整数</span>timestamp1601ToTime<a class="type" href="#types_integer">整数</a>比べる<a class="type" href="#types_boolean">整数</a>hashCode<span class="func">整数</span>await<a class="type" href="#types_integer">無視する</a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_duration">
        <h3>5.20持続時間</h3>
          </a>
        <p>型式<tt><span class="type">持続時間</span></tt>に、継続する時間と日付を示します。 その<tt><span class="type">持続時間</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">duration.s7i</span>&quot;</span></p><pre class="tt">
定数:

))
前置演算子:

アイデンティティ

符号を変える
インフィックス演算子:

2つのデュレーションの追加

2つのデュレーションの減算


(左オペランドのタイプ:
)


(右オペランドの型:
)

時間にデュレーションを追加する
(左オペランドのタイプ:

結果のタイプ:
)

時間からデュレーションを引く
(左オペランドのタイプ:

結果のタイプ:
)

引き算2回
(左オペランドのタイプ:

右オペランドのタイプ:
)
A
C三項演算子条件?thenValue:elseValue
(引数Aのタイプ:


a

b)


(引数Aのタイプ:


P2M28DT12H1S

)
リレーション:


機能:


(引数Aのタイプ:


P2M28DT12H1S

)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)

年で
(結果の種類:
)

月数
(結果の種類:
)

日で
(結果の種類:
)

数時間で
(結果の種類:
)

分で
(結果の種類:
)

秒で
(結果の種類:
)

マイクロ秒で
(結果の種類:
)


(結果の種類:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
A
B甲を乙が増す
(A
B)
A
B減分AをBで
(A
B)
A
A by B
(引数Aのタイプ:

A
B)
A
A by B
(引数Aのタイプ:

A
B)

(A)所定時間待つ

(A)値を無視(Ignore value)する
<span class="type">持続時間</span><span class="var">価値</span>既定値<span class="type">持続時間</span>(duration(<span class="stri">&quot;P0D&quot;</span>+<span class="op">-</span>+<span class="op">-</span>*<span class="op">durationに</span>整数<span class="op">整数</span>*<span class="op">durationに</span>整数<a class="type" href="#types_integer">整数</a>+<a class="type" href="#types_integer">時間</a>時間<span class="op">-</span>時間<a class="type" href="#types_integer">時間</a>-<a class="type" href="#types_integer">時間</a>時間<span class="op"></span>B<a class="type" href="#types_time">:</a>ブール<a class="type" href="#types_time">TRUE</a>a:b<span class="op">⇒</span>FALSE<a class="type" href="#types_time">a:b</a>⇒<a class="type" href="#types_time">持続時間</a><span class="op">解析する</span>A変換<a class="type" href="#types_time">文字列</a>へ<a class="type" href="#types_time">持続時間</a>文字列<span class="op">持続時間</span><span class="op">解析する</span><a class="type" href="#types_boolean">「P2M28DT12H1S」</a><span class="var">⇒</span>持続時間<b></b>解析する<span class="var"></span>「P13M28DT12H1S」<b></b>⇒<span class="type">例外</span>範囲エラー<span class="op">=</span><a class="type" href="#types_string">&lt;></a><span class="type">&lt;</span><a class="type" href="#types_string">&lt;=</a><span class="type">></span><span class="op">>=</span>持続時間<span class="stri">(ア)Conversion of</span>文字列<b>へ</b>持続時間<span class="type">文字列</span>持続時間<span class="op">(</span>「P2M28DT12H1S」<span class="stri">)</span>⇒<b>持続時間</b>(<a class="exception" href="#errors_RANGE_ERROR">「P13M28DT12H1S」</a>)<span class="op">⇒</span>例外<span class="op">範囲エラー</span>getYears<span class="op">(A)aの年を取得する</span>持続時間<span class="op">整数</span>getMonths<span class="op">(A)月を取得します。</span>持続時間<span class="op">整数</span>getDays<span class="func">(A)aの日を求める</span>持続時間<a class="type" href="#types_string">整数</a>getHours<span class="type">(A)aの時間を取得する</span>持続時間<a class="type" href="#types_string">整数</a>getMinutes<span class="func">(A)aの議事録を取得する</span>持続時間<span class="stri">整数</span>getSeconds<b>(A)aの秒を求める</b>持続時間<span class="func">整数</span>getMicroSeconds<span class="stri">(A)aのマイクロ秒を取得します。</span>持続時間<b>整数</b>年<a class="exception" href="#errors_RANGE_ERROR">(A)返却</a>持続時間<span class="func">整数</span>現在の月数<span class="type">(A)返却</span>持続時間<a class="type" href="#types_integer">整数</a>本日<span class="func">(A)返却</span>持続時間<span class="type">整数</span>時間<a class="type" href="#types_integer">(A)返却</a>持続時間<span class="func">整数</span>toMinutes<span class="type">(A)返却</span>持続時間<a class="type" href="#types_integer">整数</a>toSeconds<span class="func">(A)返却</span>持続時間<span class="type">整数</span>toMIcroS<a class="type" href="#types_integer">(A)返却</a>持続時間<span class="func">整数</span>str<span class="type">(A)〜への変換</span>文字列<a class="type" href="#types_integer">文字列</a>比べる<span class="func">整数</span>hashCode<span class="type">整数</span>+:=<a class="type" href="#types_integer">+:=</a>B<span class="func">⇒</span>A:=A<span class="type">+</span>-:=<a class="type" href="#types_integer">-:=</a>B<span class="func">⇒</span>A:=A<span class="type">-</span>+:=<a class="type" href="#types_integer">B増分</a>時間<span class="func">時間</span>+:=<span class="type">B</span>⇒<a class="type" href="#types_integer">A:=A</a>+<span class="func">-:=</span>B減分<span class="type">時間</span>時間<a class="type" href="#types_integer">-:=</a>B<span class="func">⇒</span>A:=A<span class="type">-</span>待つ<a class="type" href="#types_integer">無視する</a><span class="func"></span><span class="type"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="op"></span><span class="op"></span><b></b><span class="op"></span><span class="op"></span><span class="op"></span><b></b><span class="op"></span><span class="op"></span><a class="type" href="#types_time"></a><a class="type" href="#types_time"></a><span class="op"></span><b></b><span class="op"></span><span class="op"></span><a class="type" href="#types_time"></a><a class="type" href="#types_time"></a><span class="op"></span><b></b><span class="op"></span><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p>操作について<tt><span class="op">-</span></tt>(否定する<tt><span class="type">持続時間</span></tt>)および<tt><span class="op">-</span></tt>(2を引く<tt><a class="type" href="#types_time">時間</a></tt>値)には以下が含まれる:</p><pre class="box">
(tim1
tim1)
<span class="op">-</span>tim2)<span class="op">=</span><span class="op">-</span>(tim2<span class="op">-</span></pre><p>操作について<tt><span class="op">+</span></tt>(<tt><span class="type">持続時間</span></tt>に<tt><a class="type" href="#types_time">時間</a></tt>)および<tt><span class="op">-</span></tt>(2を引く<tt><a class="type" href="#types_time">時間</a></tt>値)には以下が含まれる:</p><pre class="box">
tim2
tim1
<span class="op">+</span>(tim1<span class="op">-</span>tim2)<span class="op">=</span></pre><p>操作について<tt><span class="op">-</span></tt>(aを引く<tt><span class="type">持続時間</span></tt>から<tt><a class="type" href="#types_time">時間</a></tt>)および<tt><span class="op">-</span></tt>(2を引く<tt><a class="type" href="#types_time">時間</a></tt>値)には以下が含まれる:</p><pre class="box">
tim1
tim2
<span class="op">-</span>(tim1<span class="op">-</span>tim2)<span class="op">=</span></pre><p></p>
          <a name="types_file">
        <h3>5.21ファイル</h3>
          </a>
        <p>型式<tt><span class="type">ファイルする</span></tt>順編成ファイル用のインタフェースタイプです。 その<tt><span class="type">ファイルする</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">s7i</span>&quot;</span></p><pre class="tt">
定数:

)
変数:

標準NULLファイル

オペレーティングシステムの標準入力

オペレーティングシステムの標準出力

オペレーティングシステムの標準エラー出力

ファイル入力で使用する標準入力ファイル
ファイルが指定されない場合の操作
(
)

ファイル出力で使用する標準出力ファイル
ファイルが指定されない場合の操作
(
)

操作卓鍵盤を記述した鍵盤ファイル

グラフィックキーボードを記述したキーボードファイル。

キーボードを記述する変数。
(
)
要素:

;
その




変数を使用して現在の文字を格納することもできます。
もし
数字を含むと、スキャナは、数字がその後に続くとみなす
そしてもし
などが続く場合には
の実装タイプ
インターフェイス:

ファイル・インタフェースの基本実装型

オペレーティングシステムのファイル

オペレーティング・システムのUTF-8エンコード・ファイル

オペレーティング・システムのUTF-16エンコード・ファイル

オペレーティング・システムのUTF-16LEエンコード・ファイル

オペレーティング・システムのUTF-16BEエンコード・ファイル

ディレクトリの内容を読み込みます。

入力のエコーを生成します。

baseFileを行方向に読み込みます。

履歴付きの行単位の編集をサポート

GZIPファイルから解凍されたデータを読み込む

圧縮データをGZIPファイルに書き込む

指定されたベースファイルに基づいてデータをバッファ(キャッシュ)に格納します。

解凍されたデータをLZMAファイルから読み取ります。

オペレーティングシステムパイプ

UTF-8エンコードのオペレーティング・システム・パイプ

オペレーションシステムのソケット

Transport Layer Security(TLS/SSL)ソケット

文字列で格納されたファイル

複数のコピー先ファイルに同時に書き込むファイル

別のファイルを画面表示するフィルタファイル

文字を小文字に変換するフィルタファイル

文字を大文字に変換するフィルタファイル

ベースファイルのサブセグメントへの読み込みアクセス

XZファイルから解凍データを読み取ります。

Zstandardファイルから解凍されたデータを読み込む
リレーション:
=、&lt;>
を開く関数
:


(引数パスのタイプ:

引数モードのタイプ。

結果のタイプ:

リターン
開くことができなかった場合)


(引数パスのタイプ:

引数モードのタイプ。

結果のタイプ:

リターン
開くことができなかった場合)


(引数パスのタイプ:

引数モードのタイプ。

結果のタイプ:

リターン
開くことができなかった場合)


(引数パスのタイプ:

引数モードのタイプ。

結果のタイプ:

リターン
開くことができなかった場合)


(引数パスのタイプ:

引数モードのタイプ。

結果のタイプ:

リターン
開くことができなかった場合)

を、指定した文字列の内容で
(引数内容の種類:
)

空の文字列内容で

(destFiles) Teeファイルを開いて、指定の目的ファイルに書き込みます。
(引数destFilesのタイプ:
)

(dest1, dest2) 2つの宛先ファイルに書き込むティーファイルを開く

(dest, cmds, pageSize) ファイルをページ単位で表示するためにフィルタファイルを開きます。
(引数pageSizeの型:
)

(先) 文字を小文字に変換するフィルタファイルを開く

(先) 文字を大文字に変換するフィルタファイルを開く

)読み込み(解凍)のためにGZIPファイルを開く
(返品
ファイルがGZIP形式でない場合)

)書き込み用のGZIPファイルを開く(圧縮)
このファイルに書き込まれるデータはGZIPで圧縮され、destFileに書き込まれます。

(圧縮) 読み込み(解凍)のためにLZMAファイルを開きます。
(返品
ファイルがLZMA形式でない場合)

(圧縮)XZファイルを読み込み用に開く(解凍)
(返品
ファイルがXZフォーマットでない場合)

(圧縮) Zstandardファイルを読み込み用に開く(解凍)
(返品
ファイルがZstandard形式でない場合)

(A, B)プロセスへのパイプを開く
(引数Aのタイプ:

引数Bの型:

結果のタイプ:

リターン
popenが不可能な場合)

(A, B)プロセスへのUTF-8パイプを開く
(引数Aのタイプ:

引数Bの型:

結果のタイプ:

リターン
popen8が不可能な場合)

(ポート) ローカルインターネットクライアントソケットを開く
(引数ポートのタイプ:

結果のタイプ:

リターン
開くことができなかった場合)

(addr, port) インターネットクライアントソケットを開く
(引数の種類addr:

引数ポートのタイプ:

結果のタイプ:

リターン
開くことができなかった場合)

(addr, port) TLSソケットを開く
(引数の種類addr:

引数ポートのタイプ:

結果のタイプ:

リターン
開くことができなかった場合)

(directoryPath)ディレクトリファイルを開きます
(引数directoryPathのタイプ:
)

(inFile, outFile) エコーファイルを開く

(aFile) ファイルを行単位でフィルタリングするためにlineFileを開く

(inFile, outFile) Unicodeフィルタファイルを開く
履歴付きの行単位の編集用

(inFile, outFile) ラテン1フィルタファイルを開く
履歴付きの行単位の編集用
機能:

A
(結果の種類:
)

地位
(引数のタイプ:

ファイルの最初の位置は1です。

Aはシーク可能です。

A
(結果の種類:
)

A
(引数Aのタイプ:

引数Bの型:

結果のタイプ:

(A, -1)を取得します。
)

(A, B)文字Bが見つかるまで、Aから文字列を読み込みます。
文字列終端文字をA.bufferCharに割り当てる。
(結果の種類:
)

A.
語尾の文字をA.bufferCharに代入する。
(結果の種類:
)

A.
行末文字をA.bufferCharに代入する。
(結果の種類:
)
eoln(A)行末
(結果の種類:
)

(A)End of file
(結果の種類:
)

(A)getcを呼び出してもEOF文字を返さない
(結果の種類:
)

(A)少なくとも1文字が、ブロック化されずに読めること。
(結果の種類:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

A
(引数Bのタイプ:
)

A

A
(引数Bのタイプ:
)

B
(引数Bのタイプ:
)

AをBにコピーするか、デフォルト値Cを使用する。
(引数Bのタイプ:

引数Cの型:
)

A

B
(右オペランドの型:
)

AをBにコピーするか、デフォルト値Cを使用する。
(引数Bのタイプ:

引数Cの型:
)

A
backSpace(A)Write backSpace to
A

A

A

AからB
(引数Bのタイプ:

seek(A, 1)
ファイル開始に設定します。
seek(A, length(A))
最後の位置にセット
seek(A, length(A)+1)
ファイルの終わりに設定します。
seek(A, 0)
)

Aから長さBまで
(引数Bのタイプ:
)

(A)値を無視(Ignore value)する
<span class="type">ファイルする</span><span class="var">価値</span>既定値<span class="type">ファイルする</span>(<span class="var">STD_NULL</span>STD_NULL<span class="var">STD_IN</span>標準出力<span class="var">標準偏差</span>IN<span class="var">IN</span>で初期化されます。<span class="var">STD_IN</span>OUT<span class="var">OUT</span>で初期化されます。<span class="var">標準出力</span>コンソール_キーボード<span class="var">グラフ_キーボード</span>キーボード<span class="var">キーボード</span>で初期化されます。<span class="var">コンソール_キーボード</span>var<span class="var"></span>char<span class="var">:bufferChar</span>は<span class="var"></span>&#39;\n&#39;<span class="var">bufferChar</span>変数は～から受け継がれる<span class="var">空ファイル</span>getTerminatedString<span class="var"></span>getwd<span class="keywd">および</span>getln<a class="type" href="#types_char">終端文字を格納する</a>bufferChar<span class="keywd">スキャナ機能</span>を使用するか<span class="stri">bufferChar</span>bufferChar<span class="var">bufferChar</span>を含む<span class="type">&quot;</span>ファイルする<span class="func">空ファイル</span>外部ファイル<span class="func">utf 8ファイル</span>utf 16ファイル<span class="func">utf16leFile</span>utf16beFile<span class="var">dirFile</span>echoFile<a class="keywd" href="#file_Scanning_a_file">lineFile</a>editLineFile<span class="var">gzipファイル</span>gzipWriteFile<span class="var">bufferFile</span>lzmaFile<span class="var">popenFile</span>popen 8ファイル<span class="stri">ソケット</span>tlsFile<span class="type">striFile</span>ティーファイル<span class="type">moreFile</span>lowerFile<span class="type">upperFile</span>subFile<span class="type">xzFile</span>zstdFile<span class="type">ファイルする</span>開いたさま<span class="type">(path, mode) 外部を開く</span>ファイルする<span class="type">文字列</span>文字列<span class="type">ファイルする</span>STD_NULL<span class="type">openUtf8</span>(path, mode) 外部UTF-8エンコードを開く<span class="type">ファイルする</span>文字列<span class="type">文字列</span>ファイルする<span class="type">STD_NULL</span>openUtf16<span class="type">(path, mode) 既存のUTF-16LEまたはUTF-16BEエンコードを開く</span>ファイルする<span class="type">文字列</span>文字列<span class="type">ファイルする</span>STD_NULL<span class="type">openUtf16le</span>(path, mode) オープンUTF-16LEエンコード<span class="type">ファイルする</span>文字列<span class="type">文字列</span>ファイルする<span class="type">STD_NULL</span>openUtf16be<span class="type">(path, mode) UTF-16BEエンコードを開く</span>ファイルする<span class="type">文字列</span>文字列<span class="type">ファイルする</span>STD_NULL<span class="type">openStriFile</span>(含量) を開く<span class="type">striFile</span>文字列<span class="type">openStriFile</span>を開く<span class="type">striFile</span>オープンティー<span class="type">配列</span><span class="type">文字列</span>オープンティー<span class="func">もっと見る</span>整数<a class="type" href="#types_file">下を開く</a>openUpper<a class="type" href="#types_string">openGzipFile</a>(圧縮<a class="type" href="#types_string">読む</a>STD_NULL<a class="type" href="#types_file">openGzipFile</a>(destFile<span class="var">書き込み</span>openLzmaFile<span class="func">STD_NULL</span>openXzFile<a class="type" href="#types_file">STD_NULL</a>openZstdFile<a class="type" href="#types_string">STD_NULL</a>popen<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_file">ファイルする</a>STD_NULL<span class="var">popen8</span>文字列<span class="func">文字列</span>ファイルする<a class="type" href="#types_file">STD_NULL</a>openInetSocket<a class="type" href="#types_string">整数</a>ファイルする<a class="type" href="#types_string">STD_NULL</a>openInetSocket<a class="type" href="#types_file">文字列</a>整数<span class="var">ファイルする</span>STD_NULL<span class="func">openTlsSocket</span>文字列<a class="type" href="#types_file">整数</a>ファイルする<a class="type" href="#types_string">STD_NULL</a>openDir<a class="type" href="#types_string">文字列</a>openEcho<a class="type" href="#types_file">openLine</a>openEditLine<span class="var">openEditLineLatin1</span>長さ<span class="func">(A)長さ</span>ファイルする<a class="type" href="#types_file">整数</a>話す<a class="type" href="#types_string">(A)実際の</a>ファイルする<a class="type" href="#types_string">ファイルする</a>求めることができる<a class="type" href="#types_file">(A)次の事項を決定すること。</a>ファイルする<span class="var">getc</span>(A)下記から1文字を取得します。<span class="func">ファイルする</span>char<span class="type">取得</span>(A, B)取得<a class="type" href="#types_string">文字列</a>から最大長さBの<span class="func">ファイルする</span>整数<span class="type">ファイルする</span>文字列<span class="func">⇒</span>例外<a class="type" href="#types_array">範囲エラー</a>getTerminatedString<a class="type" href="#types_string">文字列</a>getwd<span class="func">(A)下記から1語を取得する。</span>ファイルする<span class="func">文字列</span>getln<a class="type" href="#types_integer">(A)下記から1行を取得する。</a>ファイルする<span class="func">文字列</span>ブール<span class="func">eof</span>ブール<span class="func">hasNext</span>ブール<span class="var">inputReady</span>ブール<span class="var">比べる</span>整数<span class="func">hashCode</span>整数<span class="var">書く</span>(A, B)書き込み<span class="func">文字列</span>Bから<span class="var">ファイルする</span>文字列<span class="func">writeln</span>(A)改行<span class="var">ファイルする</span>writeln<span class="func">(A, B)書き込み</span>文字列<span class="var">Bおよび改行</span>ファイルする<span class="func">文字列</span>読む<a class="type" href="#types_string">(A, B)単語を読み込む</a>ファイルする<a class="type" href="#types_string">Aから</a>文字列<a class="type" href="#types_file">文字列</a>読む<span class="var">(A, B, C)から1語を読む</span>ファイルする<span class="func">文字列</span>文字列<a class="type" href="#types_string">readln</a>(A)テキストを読む<a class="type" href="#types_string">ファイルする</a>readln<a class="type" href="#types_file">(A, B)Read a line from</a>ファイルする<span class="var">Aを</span>文字列<span class="func">文字列</span>readln<a class="type" href="#types_integer">(A, B, C)Read a line from</a>ファイルする<a class="type" href="#types_file">文字列</a>文字列<span class="var">飛ばす</span>(A, B)B文字をスキップ<span class="func">ファイルする</span>ファイルする<a class="type" href="#types_string">クローズ</a>(A)閉じる<a class="type" href="#types_integer">ファイルする</a>フラッシュ<a class="type" href="#types_file">(A)フラッシュ</a>ファイルする<span class="var">シークする</span>(A, B)の実際のファイル位置を設定する<span class="func">ファイルする</span>整数<a class="type" href="#types_string">⇒</a>⇒<a class="type" href="#types_integer">⇒</a>⇒<a class="type" href="#types_file">例外</a>範囲エラー<span class="var">切り詰める</span>(A, B)Truncate<span class="func">ファイルする</span>整数<a class="type" href="#types_string">無視する</a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_char"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_file"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_integer"></a><b></b><b></b><b></b><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_text">
        <h3>5.22テキスト</h3>
          </a>
        <p>型式<tt><span class="type">テキスト</span></tt>2次元ファイルのためのインタフェース型である。 これらのファイルは、列を含む行で構成されています。 その<tt><span class="type">テキスト</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">テキスト.s7i</span>&quot;</span></p><pre class="tt">
変数:

現行プロセスの標準コンソールファイル。
の実装タイプ
インターフェイス:

テキストコンソール/ウィンドウに書き込む

グラフィックウィンドウにシステムフォントで書き込みます。



ピクスマップフォントによるグラフィックウィンドウへの書き込み

文字列の配列に格納されたテキストファイル
リレーション:
=、&lt;>
を開く関数
:

(CONSOLE)コンソール/ウィンドウの左上隅にconsole_fileを作成します。

(graphWin)graphWinの左上隅にグラフファイルを作成します。
(引数graphWinのタイプ:
)

(graphWin, minX, minY)graphWinの(minX, minY)にgraph_fileを作成します。
(引数graphWinのタイプ:

引数minXの型:

引数minYの型:
)

(graphWin, minX, minY, width, height)graphWinの(minX, minY)にgraph_fileを作成します。
(引数graphWinのタイプ:

引数minXの型:

引数minYの型:

引数幅のタイプ:

引数の高さのタイプ:
)

(outText, upper, left, height, width)outTextの(left, upper)にウィンドウファイルを作成します。
(引数のタイプ上限:

残りの引数のタイプ:

引数の高さのタイプ:

引数幅のタイプ:
)

勝の左上角で
(引数のタイプ:
)

in winにおけるat(minX, minY)
(引数のタイプ:

引数minXの型:

引数minYの型:
)

(content)指定したコンテンツのstriTextを開きます。
(引数内容の種類:
)
機能:


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)


(結果の種類:
)
ステートメント:

A
(引数Bのタイプ:
)

A

A
(引数Bのタイプ:
)

B
(右オペランドの型:
)

A

B
(右オペランドの型:
)
backSpace(A)Write backSpace to
A

A

A

(A)窓をきれいにする

(A、UP、LO、LE、RI)窓の領域をクリアにします
(引数UPの型:

引数LOのタイプ:

引数LEの型:

引数RIのタイプ:
)
v_scroll(A)ウィンドウを垂直にスクロールする
h_scroll(A)ウィンドウを水平にスクロールする

A
(引数Bのタイプ:
)

A
(引数Bのタイプ:

引数Cの型:
)

A
(引数Bのタイプ:

引数Cの型:
)

A
(引数Bのタイプ:
)

A
(引数Bのタイプ:
)
box(A)窓の周りに箱を書く
clear_box(A)窓の周りのボックスをクリアする
cursor_on(A)カーソルを表示する
cursor_off(A)カーソルを非表示にする

(A)値を無視(Ignore value)する
<span class="var">STD_CONSOLE</span>テキスト<span class="type">コンソールファイル</span>グラフファイル<span class="type">ウィンドウファイル</span>他の矩形領域に書き込む<span class="type">テキスト</span>pixmapFontFile<span class="type">striText</span>テキスト<span class="type">開いたさま</span>開いたさま<span class="type">PR IMERIC_WINDOW</span>開いたさま<span class="type">PR IMERIC_WINDOW</span>整数<span class="type">整数</span>開いたさま<span class="func">PR IMERIC_WINDOW</span>整数<span class="func">整数</span>整数<span class="type">整数</span>openWindow<span class="func">整数</span>整数<span class="type">整数</span>整数<a class="type" href="#types_integer">openPixmapFontFile</a>(win)作成<a class="type" href="#types_integer">pixmapFontFile</a>PR IMERIC_WINDOW<span class="func">openPixmapFontFile</span>(win, minX, minY)<span class="type">pixmapFontFile</span>PR IMERIC_WINDOW<a class="type" href="#types_integer">整数</a>整数<a class="type" href="#types_integer">openStriText</a>配列<a class="type" href="#types_integer"></a>文字列<a class="type" href="#types_integer">高さ</a>(A)翼の高さ<span class="func">テキスト</span>整数<a class="type" href="#types_integer">横</a>(A)容器の幅<a class="type" href="#types_integer">テキスト</a>整数<a class="type" href="#types_integer">線</a>(A)現在の<a class="type" href="#types_integer">テキスト</a>整数<span class="func">列</span>(A)対象の「電流列」<span class="type">テキスト</span>整数<span class="type">書く</span>(A, B)書き込み<span class="func">文字列</span>Bから<span class="type">テキスト</span>文字列<span class="type">writeln</span>(A)改行<a class="type" href="#types_integer">テキスト</a>writeln<a class="type" href="#types_integer">(A, B)書き込み</a>文字列<span class="func">Bおよび改行</span>テキスト<a class="type" href="#types_array">文字列</a>読む<a class="type" href="#types_string">(A, B)単語を読み込む</a>テキスト<span class="func">Aから</span>文字列<a class="type" href="#types_text">文字列</a>readln<a class="type" href="#types_integer">(A)テキストを読む</a>テキスト<span class="func">readln</span>(A, B)Read a line from<a class="type" href="#types_text">テキスト</a>Aを<a class="type" href="#types_integer">文字列</a>文字列<span class="func">テキスト</span>クローズ<a class="type" href="#types_text">(A)閉じる</a>テキスト<a class="type" href="#types_integer">フラッシュ</a>(A)フラッシュ<span class="func">テキスト</span>晴れた<a class="type" href="#types_text">晴れた</a>整数<a class="type" href="#types_integer">整数</a>整数<span class="func">整数</span>色<a class="type" href="#types_string">(A, B)テキストの前景色を設定します。</a>テキスト<a class="type" href="#types_text">色</a>色<a class="type" href="#types_string">(A, B, C)の前景色と背景色を設定します。</a>テキスト<span class="func">色</span>色<a class="type" href="#types_text">setPos</a>(A, B, C)の現在位置を設定します。<span class="func">テキスト</span>整数<a class="type" href="#types_string">整数</a>setLine<a class="type" href="#types_text">(A, B)カレント行の</a>テキスト<a class="type" href="#types_string">整数</a>setColumn<span class="func">(A, B)現在の</span>テキスト<a class="type" href="#types_text">整数</a>無視する<a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_text"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><a class="type" href="#types_text"></a><span class="func"></span><a class="type" href="#types_text"></a><span class="func"></span><a class="type" href="#types_text"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_color"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_color"></a><a class="type" href="#types_color"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_text"></a><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_fileSys">
        <h3>5.23 fileSys</h3>
          </a>
        <p>型式<tt><span class="type">fileSys</span></tt>ファイルシステムのインタフェースタイプです。 オペレーティング・システムのファイルとアーカイブ・ファイルの内容は、どちらもファイル・システムとして構成されます。 リモートコンピュータに格納されているファイルへの接続では<tt><span class="type">fileSys</span></tt>インタフェース。</p><pre class="tt">
定数:

)
変数:

オペレーティング・システム・ファイルのファイル・システム
の実装タイプ
インターフェイス:

空のファイルシステム(デフォルト値として使用)

オペレーティング・システム・ファイルにアクセスするためのファイル・システム

拡張現実アーカイブにアクセスする

CPIOアーカイブへのアクセス

RPMアーカイブへのアクセス

TARアーカイブへのアクセス

ZIPアーカイブにアクセスする

FTPサーバへの接続
を開く関数
:

(arFile)指定したarFileでARアーカイブを開きます。
(引数arFileのタイプ:

リターン
開くことができなかった場合)

(arFileName)指定したarFileNameでARアーカイブを開きます。
(引数のタイプarFileName:

リターン
開くことができなかった場合)

(cpioFile)指定したcpioFileでCPIOアーカイブを開きます。
(引数cpioFileのタイプ:

リターン
開くことができなかった場合)

(cpioFileName)指定したcpioFileNameでCPIOアーカイブを開きます。
(引数の種類cpioFileName:

リターン
開くことができなかった場合)

(rpmFile)指定したrpmFileでRPMアーカイブを開きます。
(引数rpmFileの型:

リターン
開くことができなかった場合)

(rpmFileName)指定したrpmFileNameでRPM書庫を開きます。
(引数のタイプrpmFileName:

リターン
開くことができなかった場合)

(tarFile)指定したtarFileでTARアーカイブを開きます。
(引数tarFileのタイプ:

リターン
開くことができなかった場合)

(tarFileName)指定したtarFileNameでTARアーカイブを開きます。
(引数の種類tarFileName:

リターン
開くことができなかった場合)

(zipFile)指定したzipFileでZIPアーカイブを開きます。
(引数zipFileのタイプ:

リターン
開くことができなかった場合)

(zipFileName)指定したzipFileNameでZIPアーカイブを開きます。
(引数のタイプzipFileName:

リターン
開くことができなかった場合)

(hostName, user, password, ftpControlPort)FTPファイル・システムを開きます。
(引数hostNameのタイプ:

引数ユーザのタイプ:

引数パスワードのタイプ:

引数ftpControlPortのタイプ:
)

(hostName, user, password)FTPファイル・システムをオープンします。
(引数hostNameのタイプ:

引数ユーザのタイプ:

引数パスワードのタイプ:
)

(connectStri, ftpControlPort)FTPファイルシステムを開く
(引数ConnectSTRのタイプ:

引数ftpControlPortのタイプ:
)

(connectStri)FTPファイルシステムを開く
(引数ConnectSTRのタイプ:
)
機能:

(aFileSys)ファイルシステムを閉じます。

(aFileSys, dirPath)ディレクトリ名を読み込みます。
(引数dirPathのタイプ:

結果のタイプ:
)

(aFileSys, dirPath, RECURSIVE)ディレクトリのファイルパスを再帰的に読み取ります。
(引数dirPathのタイプ:

結果のタイプ:
)

(aFileSys)ルートディレクトリのファイル名を読み込みます。
(結果の種類:
)

(aFileSys, RECURSIVE)ルートディレクトリのファイルパスを再帰的に読み取ります。
(結果の種類:
)

(aFileSys, path)ファイルのタイプを取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルのタイプを取得します(シンボリックリンクを追跡しません)。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルのファイルモード(パーミッション)を取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルのサイズを取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルのサイズを取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルの更新日時を取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルの所有者(UID)の名前を取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys, path)ファイルが属するグループ(GID)の名前を取得します。
(引数パスのタイプ:

結果のタイプ:
)

(aFileSys、filePath、mode)filePathとモードを使用してファイルを開きます
(引数filePathのタイプ:

引数モードのタイプ。

結果のタイプ:
)

(aFileSys, filePath)ファイルfilePathの内容を取得
(引数filePathのタイプ:

結果のタイプ:
)

(aFileSys, path)シンボリックリンク先を読み込みます。
(引数パスのタイプ:

結果のタイプ:
)
ステートメント:

(aFileSys, path, mode)ファイルのファイルモード(パーミッション)を変更します。
(引数パスのタイプ:

引数モードのタイプ。
)

(aFileSys, path, modificationTime)
(引数パスのタイプ:

引数modificationTimeのタイプ:
)

(aFileSys, path, owner)ファイルの所有者を設定します。
(引数パスのタイプ:

引数所有者のタイプ:
)

(aFileSys, path, group)ファイルのグループを設定します。
(引数パスのタイプ:

引数グループのタイプ:
)

(aFileSys, filePath, stri)ファイルシステムを使用してstriをファイルfilePathに書き込みます。
(引数filePathのタイプ:

引数striの型:
)

(aFileSys, path)ファイルを削除します(空でないディレクトリを除く)
(引数パスのタイプ:
)

(aFileSys, path)ディレクトリツリーを含むすべてのタイプのファイルを削除します。
(引数パスのタイプ:
)

(aFileSys, sourcePath, destPath)ファイルまたはディレクトリツリーの移動と名前の変更
(引数sourcePathのタイプ:

引数destPathのタイプ:
)

(aFileSys, dirPath)ディレクトリを作成します
(引数dirPathのタイプ:
)

(aFileSys, symlinkPath, targetPath)シンボリックリンクを作成します。
(引数symlinkPathのタイプ:

引数targetPathのタイプ:
)

(aFileSys, dirPath)空のディレクトリを削除します
(引数dirPathのタイプ:
)

(aFileSys)現在の作業ディレクトリを決定します。

(aFileSys, dirPath)現在の作業ディレクトリを変更します。
(引数dirPathのタイプ:
)

(A)値を無視(Ignore value)する
<span class="type">fileSys</span><span class="var">価値</span>既定値<span class="type">fileSys</span>(<span class="type">emptyFileSys</span><span class="var">価値</span>osFiles<span class="var">fileSys</span>emptyFileSys<span class="type">osFileSys</span>arArchive<span class="type">cpioArchive</span>rpmArchive<span class="type">tarArchive</span>zipArchive<span class="type">ftpConnection</span>fileSys<span class="type">オープンAr</span>ファイルする<span class="type">fileSys</span><span class="type">価値</span>オープンAr<span class="type">文字列</span>fileSys<span class="type"></span>価値<span class="type">openCpio</span>ファイルする<span class="func">fileSys</span><a class="type" href="#types_file">価値</a>openCpio<span class="type">文字列</span>fileSys<span class="var"></span>価値<span class="func">openRpm</span>ファイルする<a class="type" href="#types_string">fileSys</a><span class="type">価値</span>openRpm<span class="var">文字列</span>fileSys<span class="func"></span>価値<a class="type" href="#types_file">オープンタール</a>ファイルする<span class="type">fileSys</span><span class="var">価値</span>オープンタール<span class="func">文字列</span>fileSys<a class="type" href="#types_string"></a>価値<span class="type">openZip</span>ファイルする<span class="var">fileSys</span><span class="func">価値</span>openZip<a class="type" href="#types_file">文字列</a>fileSys<span class="type"></span>価値<span class="var">openFtp</span>文字列<span class="func">文字列</span>文字列<a class="type" href="#types_string">整数</a>openFtp<span class="type">文字列</span>文字列<span class="var">文字列</span>openFtp<span class="func">文字列</span>整数<a class="type" href="#types_file">openFtp</a>文字列<span class="type">クローズ</span>readDir<span class="var">文字列</span>配列<span class="func"></span>文字列<a class="type" href="#types_string">readDir</a>文字列<span class="type">配列</span><span class="var">文字列</span>readDir<span class="func">配列</span><a class="type" href="#types_file">文字列</a>readDir<span class="type">配列</span><span class="var">文字列</span>ファイルタイプ<span class="func">文字列</span>ファイルタイプ<a class="type" href="#types_string">ファイルタイプL</a>文字列<span class="type">ファイルタイプ</span>getFileMode<span class="var">文字列</span>ファイルモード<span class="func">ファイルサイズ</span>文字列<a class="type" href="#types_string">整数</a>bigFileSize<a class="type" href="#types_string">文字列</a>bigInteger<a class="type" href="#types_string">getMTime</a>文字列<a class="type" href="#types_integer">時間</a>getOwner<span class="func">文字列</span>文字列<a class="type" href="#types_string">getGroup</a>文字列<a class="type" href="#types_string">文字列</a>開いたさま<a class="type" href="#types_string">文字列</a>文字列<span class="func">ファイルする</span>getFile<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_integer">readLink</a>文字列<span class="func">文字列</span>setFileMode<a class="type" href="#types_string">文字列</a>ファイルモード<span class="func">setMTime</span>文字列<span class="func">時間</span>所有者を設定する<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_array">setGroup</a>文字列<a class="type" href="#types_string">文字列</a>putFile<span class="func">文字列</span>文字列<a class="type" href="#types_string">removeFile</a>文字列<a class="type" href="#types_array">removeTree</a>文字列<a class="type" href="#types_string">moveFile</a>文字列<span class="func">文字列</span>makeDir<a class="type" href="#types_array">文字列</a>makeLink<a class="type" href="#types_string">文字列</a>文字列<span class="func">rmdir</span>文字列<a class="type" href="#types_array">getcwd</a>chdir<a class="type" href="#types_string">文字列</a>無視する<span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_bigInteger"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_time"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="type"></span><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_time"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_string"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_pollData">
        <h3>5.24 pollData</h3>
          </a>
        <p>タイプで<tt><span class="type">pollData</span></tt>関数の入力(checkedEvents)と出力(eventFindings)<tt><span class="func">投票する</span></tt>を維持する。 型式<tt><span class="type">pollData</span></tt>ソケットのセットを維持します。 すべてのソケットについて、checkedEventsとeventFindingsが維持されます。 checkedEventsは、どのイベント(POLLIN、POLLOUT、POLLINOUT)を<tt><span class="func">投票する</span></tt>・機能<tt><span class="func">投票する</span></tt>検出されたイベントを判別し、eventFindingsとして保存します。 型式<tt><span class="type">pollData</span></tt>にはイテレータも用意されています。このイテレータは、checkedEventsおよびeventFindingsを反復処理するために使用できます。</p><pre class="tt">
定数:

(空のpollData)
機能:

(pData, aSocket)aSocketに関するpDataからのイベントをチェックしました
(引数aSocketのタイプ:

結果のタイプ:
)

(pData, aFile)Checked events from pData for aFile
(引数aFileのタイプ:

結果のタイプ:
)

(pData, aSocket)aSocketに関するpDataからのイベント検出情報
(引数aSocketのタイプ:

結果のタイプ:
)

(pData, aFile)aFileに対するpDataからの事象発見
(引数aFileのタイプ:

結果のタイプ:
)

(pData)pDataイテレータが別のファイルを配信できるかどうかを決定します。
(結果の種類:
)

(pData)pDataイテレータから次のファイルを取得します。
(結果の種類:
)
ステートメント:

(pData)pDataをクリアします。

(pData, aSocket, eventsToCheck, aFile)eventToCheck for aSocketをpDataに追加します。
(引数aSocketのタイプ:

eventToCheck引数のタイプ:

引数aFileの型:
)

(pData, aFile, eventsToCheck)eventToCheck for aFileをpDataに追加します。
(引数aFileのタイプ:

eventToCheck引数のタイプ:
)

(pData、aSocket、eventsToCheck) pDataからaSocketのeventsToCheckを削除します。
(引数aSocketのタイプ:

eventToCheck引数のタイプ:
)

(pData, aFile, eventsToCheck)pDataからaFileのeventsToCheckを削除
(引数aFileのタイプ:

eventToCheck引数のタイプ:
)

(pData)pDataからの1つ以上のcheckedEventsを待ちます

(pData, pollMode)pollDataイテレータをcheckedEventsを処理するようにリセットします。
(引数pollModeの型:
)

(pData, pollMode)eventFindingsを処理するためにpollDataイテレータをリセットします。
(引数pollModeの型:
)

(A)値を無視(Ignore value)する


声明

pData反復子の値をループする
(forVarの引数の型:

引数文のタイプ:
)
<span class="type">pollData</span><span class="var">価値</span>既定値<span class="type">pollData</span>getCheck<span class="func">PR IMERIC_SOCKET</span>整数<span class="type">getCheck</span>ファイルする<a class="type" href="#types_integer">整数</a>getFinding<span class="func">PR IMERIC_SOCKET</span>整数<a class="type" href="#types_file">getFinding</a>ファイルする<a class="type" href="#types_integer">整数</a>hasNext<span class="func">ブール</span>nextFile<span class="type">ファイルする</span>晴れた<a class="type" href="#types_integer">addCheck</a>PR IMERIC_SOCKET<span class="func">整数</span>ファイルする<a class="type" href="#types_file">addCheck</a>ファイルする<a class="type" href="#types_integer">整数</a>removeチェック<span class="func">PR IMERIC_SOCKET</span>整数<a class="type" href="#types_boolean">removeチェック</a>ファイルする<span class="func">整数</span>投票する<a class="type" href="#types_file">iterChecks</a>整数<span class="func">調査結果</span>整数<span class="func">無視する</span>の<span class="type">forVar</span>範囲<a class="type" href="#types_integer">pData</a>do<a class="type" href="#types_file">終わり</a><span class="func">の</span>ファイルする<a class="type" href="#types_file">proc</a><a class="type" href="#types_integer"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><a class="type" href="#types_file"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_listener">
        <h3>5.25リスナー</h3>
          </a>
        <p>型式<tt><span class="type">聞き手</span></tt>は、リスナーのインタフェース型です。 その<tt><span class="type">聞き手</span></tt>インタフェースは<tt><span class="type">inetListener</span></tt>A<tt><span class="type">聞き手</span></tt>そのソケットを管理する。</p><pre class="tt">
機能:

(portNumber)localhostのポートにバインドされたインターネットリスナーを作成します。
(引数portNumberの型:
)

(aListener)aListener用の新しい受け付け接続ソケットを作成します。
(結果の種類:
)
ステートメント:

(aListener)リスナーaListenerを閉じます。

(aListener、backlog)ソケット接続をlistenし、着信キューを制限します。
(引数バックログの種類:
)

(aListener, sock)リスナー内のソケットに署名する
(引数sockのタイプ:
)

(aListener, sock)ソケットをリスナーからサインオフする
(引数sockのタイプ:
)

(aListener)リクエストが読み取られるか、受信接続が受け入れられるまで待機します。

(A)値を無視(Ignore value)する
<span class="func">openInetListener</span>整数<a class="type" href="#types_integer">受理する</a>ファイルする<span class="func">クローズ</span>耳を傾ける<a class="type" href="#types_file">整数</a>signOn<span class="func">ファイルする</span>サインオフ<span class="func">ファイルする</span>waitForRequest<a class="type" href="#types_integer">無視する</a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="type" href="#types_file"></a><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_database">
        <h3>5.26データベース</h3>
          </a>
        <p>型式<tt><span class="type">データベース</span></tt>データベース接続について説明します。 図書館<span class="stri">&quot;<span class="lib">sql_base.s7i</span>&quot;</span>データベース接続を管理するための関数を定義する。</p><pre class="tt">
定数:

(空のデータベース)
リレーション:


機能:

(ドライバ、ホスト、ポート、データベース名、ユーザー、パスワード)データベースを開く
(引数ドライバのタイプ:

引数ホストのタイプ:

引数ポートのタイプ:

引数dbNameの型:

引数ユーザのタイプ:

引数パスワードのタイプ:
)

(DB_ODBC, odbcDriver, server, dbName, user, password)ODBCデータベースを開く
(引数odbcDriverのタイプ:

引数サーバのタイプ:

引数dbNameの型:

引数ユーザのタイプ:

引数パスワードのタイプ:
)

(DB_INFORMIX, host, port, server, dbName, user, password)Informixデータベースを開く
(引数ホストの種類:

引数ポートのタイプ:

引数サーバのタイプ:

引数dbNameの型:

引数ユーザのタイプ:

引数パスワードのタイプ:
)

(driver, dbPath, user, password)指定したユーザとパスワードでデータベースdbPathを開きます。
(引数ドライバのタイプ:

引数dbPathのタイプ:

引数ユーザのタイプ:

引数パスワードのタイプ:
)

(driver, connectStri)指定したドライバとconnectStriでデータベースを開きます。
(引数ドライバのタイプ:

引数ConnectSTRのタイプ:
)

(db)指定したデータベースdbを閉じます

(db)dbの現在の自動コミットモードを取得します。
(結果の種類:
)
ステートメント:

(db, autoCommit)dbの自動コミットモードを設定します。
(引数autoCommitのタイプ:
)

dbコミット文の実行

(db)dbに対するロールバック文の実行

(A)値を無視(Ignore value)する
<span class="type">データベース</span><span class="var">価値</span>既定値<span class="type">データベース</span>=<span class="op"></span>&lt;><span class="op">openDatabase</span>dbCategory<span class="func">文字列</span>整数<span class="type">文字列</span>文字列<a class="type" href="#types_string">文字列</a>openDatabase<a class="type" href="#types_integer">文字列</a>文字列<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_string">文字列</a>openDatabase<a class="type" href="#types_string">文字列</a>整数<span class="func">文字列</span>文字列<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_string">openDatabase</a>dbCategory<a class="type" href="#types_string">文字列</a>文字列<a class="type" href="#types_string">文字列</a>openDatabase<a class="type" href="#types_string">dbCategory</a>文字列<span class="func">クローズ</span>getAutoCommit<a class="type" href="#types_string">ブール</a>setAutoCommit<a class="type" href="#types_integer">ブール</a>委ねる<a class="type" href="#types_string">後退</a>無視する<a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="type"></span><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_boolean"></a><span class="func"></span><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_sqlStatement">
        <h3>5.27 sqlStatement</h3>
          </a>
        <p>型式<tt><span class="type">sqlStatement</span></tt>準備されたsql文を説明します。</p><pre class="tt">
定数:


リレーション:


機能:

(db, sqlStatementStri)db用のプリペアードステートメントの作成
(引数の型db:

引数sqlStatementStrの型:
)

(文)実行した文の結果データから行を取り出します。
(結果の種類:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)

ブール値&lt;/a
(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)


(引数列のタイプ:

結果のタイプ:
)

(statement, column)指定したカラムのフェッチしたデータがNULLかどうかを判断します。
(引数列のタイプ:

結果のタイプ:
)

(文)文の結果データの列数を返します。
(結果の種類:
)

(statement, column)statementの結果データにある列名を返します。
(引数列のタイプ:

結果のタイプ:
)
ステートメント:

(statement, pos, num)bigIntegerパラメータを準備されたSQL文にバインドします。
(引数の型pos:

引数の型num:
)

(statement, pos, bigRatData)bigRationalパラメータを準備されたSQL文にバインドします。
(引数の型pos:

引数bigRatDataのタイプ:
)

(statement, pos, flag)準備されたSQL文にブールパラメータをバインドします。
(引数の型pos:

引数フラグのタイプ:
)

(statement, pos, bstri)bstringパラメータを準備されたSQL文にバインドします。
(引数の型pos:

引数brstriのタイプ:
)

(statement, pos, number)floatパラメータをプリペアドSQL文にバインドする
(引数の型pos:

引数番号の型:
)

(statement, pos, number)プリペアードSQL文に整数パラメータをバインドする
(引数の型pos:

引数番号の型:
)

(statement, pos, NULL)NULLパラメータを準備したSQL文にバインドします。
(引数の型pos:
)

(statement, pos, stri)文字列パラメータをプリペアードSQL文にバインドします。
(引数の型pos:

引数のタイプ:
)

(statement, pos, timeData)準備されたSQL文に時間パラメータをバインドする
(引数の型pos:

引数timeDataの型:
)

(statement, pos, durationData)準備されたSQL文にdurationパラメータをバインドします。
(引数の型pos:

引数durationデータのタイプ:
)

(文)指定したプリペアードSQL文を実行します。

(A)値を無視(Ignore value)する
<span class="type">sqlStatement</span><span class="var">価値</span>既定値<span class="type">sqlStatement</span>=<span class="op"></span>&lt;><span class="op">準備する</span>データベース<span class="func">文字列</span>取ってくる<a class="type" href="#types_database">ブール</a>列<a class="type" href="#types_string">(ステートメント、列</a>bigInteger<span class="func">)フェッチされたデータの指定した列を</span>bigInteger<a class="type" href="#types_boolean">整数</a>bigInteger<span class="func">列</span>(ステートメント、列<a class="type" href="#types_bigInteger">bigRational</a>)フェッチされたデータの指定した列を<a class="type" href="#types_bigInteger">bigRational</a>整数<a class="type" href="#types_integer">bigRational</a>列<a class="type" href="#types_bigInteger">(ステートメント、列</a>ブール<span class="func">)フェッチされたデータの指定した列を</span><a class="type" href="#types_bigRational">整数</a>ブール<a class="type" href="#types_bigRational">列</a>(ステートメント、列<a class="type" href="#types_integer">bstring</a>)フェッチされたデータの指定した列を<a class="type" href="#types_bigRational">bstring</a>整数<span class="func">bstring</span>列<a class="type" href="#types_boolean">(ステートメント、列</a>持続時間<a class="type" href="#types_boolean">持続時間<a class="type" href="#types_integer">整数</a>持続時間<a class="type" href="#types_boolean">列</a>(ステートメント、列<span class="func">浮かぶ</span>)フェッチされたデータの指定した列を<a class="type" href="#types_bstring">浮かぶ</a>整数<a class="type" href="#types_bstring">浮かぶ</a>列<a class="type" href="#types_integer">(ステートメント、列</a>整数<a class="type" href="#types_bstring">)フェッチされたデータの指定した列を</a>整数<span class="func">整数</span>整数<a class="type" href="#types_duration">列</a>(ステートメント、列<a class="type" href="#types_duration">文字列</a>)フェッチされたデータの指定した列を<a class="type" href="#types_integer">文字列</a>整数<a class="type" href="#types_duration">文字列</a>列<span class="func">(ステートメント、列</span>時間<a class="type" href="#types_float">)フェッチされたデータの指定した列を</a>時間<a class="type" href="#types_float">整数</a>時間<a class="type" href="#types_integer">isNull</a>整数<a class="type" href="#types_float">ブール</a>列数<span class="func">整数</span>列名<a class="type" href="#types_integer">整数</a>文字列<a class="type" href="#types_integer">拘束する</a>整数<a class="type" href="#types_integer">bigInteger</a>拘束する<a class="type" href="#types_integer">整数</a>bigRational<span class="func">拘束する</span>整数<a class="type" href="#types_string">ブール</a>拘束する<a class="type" href="#types_string">整数</a>bstring<a class="type" href="#types_integer">拘束する</a>整数<a class="type" href="#types_string">浮かぶ</a>拘束する<span class="func">整数</span>整数<a class="type" href="#types_time">拘束する</a>整数<a class="type" href="#types_time">拘束する</a>整数<a class="type" href="#types_integer">文字列</a>拘束する<a class="type" href="#types_time">整数</a>時間<span class="func">拘束する</span>整数<a class="type" href="#types_integer">持続時間</a>実行する<a class="type" href="#types_boolean">無視する</a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_bigInteger"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_bigRational"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_boolean"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_bstring"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_float"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_time"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_duration"></a><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_process">
        <h3>5.28プロセス(process)</h3>
          </a>
        <p>型式<tt><span class="type">プロセス</span></tt>オペレーティングシステムのプロセスを説明する。 図書館<span class="stri">&quot;<span class="lib">プロセス.s7i</span>&quot;</span>プロセスを作成および管理するための機能を定義します。</p><pre class="tt">
定数:

)
リレーション:


機能:

(コマンド、パラメータ)新しいプロセスを開始する
(引数コマンドのタイプ:

引数パラメータの型。
)

(cmdAndParams)新しいプロセスを開始します
(引数cmdAndParamsのタイプ:
)

(command, parameters, childStdin, childStdout)プロセスを開始します
パイプを標準入出力ファイルに接続します。
(引数コマンドのタイプ:

引数パラメータの型。

引数childStdinの型:

引数childStdoutのタイプ:
)

(process)プロセスの標準入力ファイル
(結果の種類:
)

(process)プロセスの標準出力ファイル
(結果の種類:
)

(process)プロセスの標準エラーファイル
(結果の種類:
)

(process)指定したプロセスが動作しているかどうかをテストします。
(結果の種類:
)

(process)processの終了値
(結果の種類:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)

(process)プロセスID(PID)を取得します。

オペレーティングシステムの検索パス。
(結果の種類:
)

(コマンド)検索パスのディレクトリで実行可能ファイルを検索します。
(引数コマンドのタイプ:

結果のタイプ:
)

(コマンド)検索パスで実行可能ファイルのディレクトリを検索します。
(引数コマンドのタイプ:

結果のタイプ:
)
ステートメント:

(process)Kill process

(process)Wait until process has terminated

(searchPath)現在のプロセスの検索パスを設定します。
(引数のタイプsearchPath:
)

(A)値を無視(Ignore value)する
<span class="type">プロセス</span><span class="var">価値</span>既定値<span class="type">プロセス</span>(<span class="type">プロセス</span><span class="var">空</span>=<span class="op"></span>&lt;><span class="op">startProcess</span>文字列<span class="func">配列</span><a class="type" href="#types_string">文字列</a>startProcess<a class="type" href="#types_array">文字列</a>パイプ2<a class="type" href="#types_string">文字列</a>配列<span class="func"></span>文字列<a class="type" href="#types_string">ファイルする</a>ファイルする<span class="func">子標準入力</span>ファイルする<a class="type" href="#types_string">子標準出力</a>ファイルする<a class="type" href="#types_array">子の標準エラー出力</a>ファイルする<a class="type" href="#types_string">isAlive</a>ブール<a class="type" href="#types_file">exitValue</a>整数<a class="type" href="#types_file">比べる</a>整数<span class="func">hashCode</span>整数<a class="type" href="#types_file">str</a>getSearchPath<span class="func">配列</span><a class="type" href="#types_file">文字列</a>commandPath<span class="func">文字列</span>文字列<a class="type" href="#types_file">commandDir</a>文字列<span class="func">文字列</span>殺す<a class="type" href="#types_boolean">waitFor</a>setSearchPath<span class="func">配列</span><a class="type" href="#types_integer">文字列</a>無視する<span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><a class="type" href="#types_array"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_string"></a><a class="type" href="#types_string"></a><span class="func"></span><span class="func"></span><span class="func"></span><a class="type" href="#types_array"></a><a class="type" href="#types_string"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_category">
        <h3>5.29カテゴリ</h3>
          </a>
        <p>型式<tt><span class="type">カテゴリ</span></tt>のカテゴリを説明する<tt><a class="type" href="#types_reference">参考</a></tt>その<tt><span class="type">カテゴリ</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">s7i</span>&quot;</span></p><pre class="tt">
リテラル:




















定数:

(SYMBOLOBJECT)
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(
a

b)


(引数Aのタイプ:


INTOBJECT)


(引数Aのタイプ:


FLOATOBJECT

)
リレーション:


機能:

(A)序数
(結果の種類:
)


(引数Aのタイプ:


INTOBJECT)


(結果の種類:

str(CHAROBJECT)
)


(引数Aのタイプ:


FLOATOBJECT

)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)値を無視(Ignore value)する


D

BからCまでのすべてのカテゴリをループする
(引数Dのタイプ:
)


D

BからCまでのすべてのカテゴリをループする
(引数Dのタイプ:
)
<a name="types_category_SYMBOLOBJECT">SYMBOLOBJECT</a><a name="types_category_DECLAREDOBJECT">DECLAREDOBJECT</a><a name="types_category_FORWARDOBJECT">FORWARDOBJECT</a><a name="types_category_FWDREFOBJECT">FWDREFOBJECT</a><a name="types_category_BLOCKOBJECT">BLOCKOBJECT</a>CALLOBJECT<a name="types_category_CALLOBJECT"></a>MATCHOBJECT<a name="types_category_MATCHOBJECT"></a>TYPEOBJECT<a name="types_category_TYPEOBJECT"></a>FORMPARAMOBJECT<a name="types_category_FORMPARAMOBJECT"></a>INTOBJECT<a name="types_category_INTOBJECT">BIGINTOBJECT</a><a name="types_category_BIGINTOBJECT">CHAROBJECT</a><a name="types_category_CHAROBJECT">STRIOBJECT</a><a name="types_category_STRIOBJECT">BSTRIOOBJECT</a><a name="types_category_BSTRIOBJECT">ARRAYOBJECT</a>HASHOBJECT<a name="types_category_ARRAYOBJECT"></a>HASHELEMOBJECT<a name="types_category_HASHOBJECT"></a>STRUCTOBJECT<a name="types_category_HASHELEMOBJECT"></a>STRUCTELEMOBJECT<a name="types_category_STRUCTOBJECT">CLASSOBJECT</a><a name="types_category_STRUCTELEMOBJECT">INTERFACEOBJECT</a><a name="types_category_CLASSOBJECT">SETOBJECT</a><a name="types_category_INTERFACEOBJECT">FILEOBJECT</a><a name="types_category_SETOBJECT">SOCKETOBJECT</a>POLLOBJECT<a name="types_category_FILEOBJECT"></a>LISTOBJECT<a name="types_category_SOCKETOBJECT"></a>FLOATOBJECT<a name="types_category_POLLOBJECT"></a>WINOBJECT<a name="types_category_LISTOBJECT"></a>POINTLISTOBJECT<a name="types_category_FLOATOBJECT">PROCESSOBJECT</a><a name="types_category_WINOBJECT">ENUMLITERALOBJECT</a><a name="types_category_POINTLISTOBJECT">CONSTENUMOBJECT</a><a name="types_category_PROCESSOBJECT">VARENUMOBJECT</a>REFOBJECT<a name="types_category_ENUMLITERALOBJECT"></a>REFLISTOBJECT<a name="types_category_CONSTENUMOBJECT"></a>EXPROBJECT<a name="types_category_VARENUMOBJECT"></a>ACTOBJECT<a name="types_category_REFOBJECT"></a>VALUEPARAMOBJECT<a name="types_category_REFLISTOBJECT">REFPARAMOBJECT</a><a name="types_category_EXPROBJECT">結果オブジェクト</a><a name="types_category_ACTOBJECT">LOCALVOOBJECT</a><a name="types_category_VALUEPARAMOBJECT">DATABASEOBJECT</a>SQLSTMTOBJECT<a name="types_category_REFPARAMOBJECT"></a>PROGOBJECT<a name="types_category_RESULTOBJECT"></a>ILLEGALOBJECT<a name="types_category_LOCALVOBJECT">カテゴリ</a><a name="types_category_DATABASEOBJECT">価値</a>既定値<a name="types_category_SQLSTMTOBJECT">カテゴリ</a><a name="types_category_PROGOBJECT">B</a>:<a name="types_category_ILLEGALOBJECT">TRUE</a>a:b<span class="type">⇒</span>FALSE<span class="var">a:b</span>⇒<span class="type">カテゴリ</span><span class="op">conv</span>A変換<span class="op">整数</span>へ<span class="var">カテゴリ</span>整数<b>カテゴリ</b><span class="var">conv</span>ord(INTOBJECT)<b>⇒</b>カテゴリ<span class="type"></span>解析する<span class="op">A変換</span>文字列<a class="type" href="#types_integer">へ</a>カテゴリ<span class="type">文字列</span>カテゴリ<a class="type" href="#types_integer"></a>解析する<span class="type"></span>&quot;FLOATOBJECT&quot;<span class="op"></span>⇒<b>カテゴリ</b><span class="type">解析する</span><span class="op">&quot;ない&quot;</span><a class="type" href="#types_string">⇒</a>例外<span class="type">範囲エラー</span>=<a class="type" href="#types_string"></a>&lt;><span class="type">ord</span>整数<span class="op">カテゴリ</span>(ア)Conversion of<span class="stri">整数</span>へ<b>カテゴリ</b>整数<span class="type">カテゴリ</span>(ord(INTOBJECT))<span class="op">⇒</span>str<span class="stri">(A)〜への変換</span>文字列<b>文字列</b>⇒<a class="exception" href="#errors_RANGE_ERROR"></a>「CHAROBJECT」<span class="op">カテゴリ</span>(ア)Conversion of<span class="op">文字列</span>へ<span class="func">カテゴリ</span>文字列<a class="type" href="#types_integer">カテゴリ</a>(<span class="func">&quot;FLOATOBJECT&quot;</span>)<a class="type" href="#types_integer">⇒</a>カテゴリ<span class="type">(</span>&quot;ない&quot;<a class="type" href="#types_integer">)</a>⇒<span class="func">例外</span>範囲エラー<b>比べる</b>整数<span class="func">hashCode</span>整数<a class="type" href="#types_string">無視する</a>の<a class="type" href="#types_string">A</a>範囲<b>B</b>へ<span class="stri">C</span>do<span class="func">終わり</span><a class="type" href="#types_string">の</a>proc<span class="type">の</span>A<a class="type" href="#types_string">範囲</a>B<span class="func">ダウントゥ</span>C<span class="stri">do</span>終わり<b></b>の<span class="func">proc</span><span class="stri"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_reference">
        <h3>5.30参照</h3>
          </a>
        <p>型式<tt><span class="type">参考</span></tt>プログラムの抽象構文木(AST)内のオブジェクトへの参照を記述する。 現在実行中のプログラムのASTにアクセスできません。 その代わりに、プログラムを解析してそのASTにアクセスできます。 その<tt><span class="type">参考</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">参照.s7i</span>&quot;</span></p><pre class="tt">
定数:

要素への参照がありません。

)
リレーション:


機能:

(A)参照オブジェクトのカテゴリを取得する
(結果の種類:

カテゴリ(NIL)
)


(結果の種類:
)

(A)参照オブジェクトの型を取得します。
(結果の種類:

getType(NIL)
)

(A)オブジェクトごとにユニークな番号を与える
(結果の種類:

objNumber(NIL)
0)

(A)変数オブジェクトへの参照
(結果の種類:

isVar(NIL)
)

(A) 関数の仮パラメータを取得します。
(結果の種類:

formalParams(NIL)
)

(A) 関数のローカル変数を取得する。
(結果の種類:

localVars(NIL)

localVars(A)
カテゴリ(A)用&lt;>BLOCKOBJECT)

(A) 関数の局所定数を取得します。
(結果の種類:

localConsts(NIL)

localConsts(A)
カテゴリ(A)用&lt;>BLOCKOBJECT)

(A)関数の本体を取得する
(本文(NIL)

本体(A)
カテゴリ(A)用&lt;>BLOCKOBJECT)

(A) 関数の結果変数を取得します。
(resultVar(NIL)

結果変数(A)
カテゴリ(A)用&lt;>BLOCKOBJECT)

(A) 結果の初期値を取得します。
関数の目的語
(resultInitValue(NIL)

resultInitValue(A)
カテゴリ(A)用&lt;>BLOCKOBJECT)
arrayToList(A)配列の要素をリストとして返す
(結果の種類:

arrayToList(NIL)

arrayToList(A)
カテゴリ(A)用&lt;>ARRAYOBJECT)

(A)配列の最小インデックスを返す
(結果の種類:

arrayMinIdx(NIL)

arrayMinIdx(A)
カテゴリ(A)用&lt;>ARRAYOBJECT)

(A)配列の最大のインデックスを返す
(結果の種類:

arrayMaxIdx(NIL)

arrayMaxIdx(A)
カテゴリ(A)用&lt;>ARRAYOBJECT)
structToList(A)構造体の要素をリストとして返す
(結果の種類:

structToList(NIL)

structToList(A)
カテゴリ(A)用&lt;>STRUCTOBJECT)
interfaceToStruct(A)インターフェースオブジェクトが指す構造体を返します。
(interfaceToStruct(NIL)

interfaceToStruct(A)
カテゴリ(A)用&lt;>INTERFACEOBJECT)

(A)参照先オブジェクトのファイル名
(結果の種類:

ファイル(NIL)
)

(A)参照先オブジェクトの絶対ファイルパス
(結果の種類:

path(NIL)
)

(A)参照先オブジェクトの行番号
(結果の種類:

行(NIL)
)
alloc(A)Aが参照するオブジェクトのコピーを作成します。
コピーのオブジェクト値はNULLに設定されます。
getValue(A

(結果の種類:

getValue(NIL

getValue(A
の
カテゴリ(A)が{FWDREFOBJECT, REFOBJECT, REFPARAMOBJECT, RESULTOBJECT
LOCALVOBJECT, ENUMLITERALOBJECT, CONSTENUMOBJECT, VARENUMOBJECT})
getValue(A

(結果の種類:

getValue(NIL

getValue(A
の
カテゴリ(A)は{MATCHOBJECT, CALLOBJECT, REFLISTOBJECT})にありません
getValue(A

(結果の種類:

getValue(NIL

getValue(A
)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>INTOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>BIGINTOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>FLOATOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>CHAROBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリー(A)の場合&lt;>STRIOOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリー(A)の場合&lt;>BSTRIOOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>SETOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>FILEOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>PROGOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>ACTOBJECT)
getValue(A

(結果の種類:

getValue(NIL

getValue(A
カテゴリ(A)用&lt;>TYPEOBJECT)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A, B)参照先オブジェクトAのvarフラグをBに設定
(引数Bのタイプ:

setVar(NIL, B)
)

(A, B)参照オブジェクトAのカテゴリをBに設定
(引数Bのタイプ:

setCategory(NIL, B)
)

(A, B)参照オブジェクトAの型をBに設定
(引数Bのタイプ:

setType(NIL, B)
)
setValue(A, B)参照先オブジェクトAの値をBに設定する
(引数Bのタイプ:
)
setFormalParams(A, B)関数の仮パラメータを設定します。
(引数Bのタイプ:

setFormalParams(NIL, B)
)

(A)値を無視(Ignore value)する
<span class="var">NIL</span>参考<span class="type"></span>価値<span class="var">既定値</span>参考<span class="type">(</span>NIL<span class="var">=</span><span class="op">&lt;></span>カテゴリ<span class="op">カテゴリ</span>⇒<span class="func">例外</span>範囲エラー<a class="type" href="#types_category">str</a>(A)〜への変換<b>文字列</b>文字列<a class="exception" href="#errors_RANGE_ERROR">getType</a>タイプ<span class="func">⇒</span>例外<a class="type" href="#types_string">範囲エラー</a>objNumber<a class="type" href="#types_string">整数</a>⇒<span class="func">isVar</span>ブール<a class="type" href="#types_type">⇒</a>例外<b>範囲エラー</b>formalParams<a class="exception" href="#errors_RANGE_ERROR">参照リスト</a>⇒<span class="func">例外</span>範囲エラー<a class="type" href="#types_integer">localVars</a>参照リスト<b>⇒</b>例外<span class="func">範囲エラー</span>⇒<a class="type" href="#types_boolean">例外</a>範囲エラー<b>localConsts</b>参照リスト<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<span class="func">範囲エラー</span>⇒<a class="type" href="#types_ref_list">例外</a>範囲エラー<b>胴体</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="func">⇒</span>例外<a class="type" href="#types_ref_list">範囲エラー</a>結果変数<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">resultInitValue</a>⇒<span class="func">例外</span>範囲エラー<a class="type" href="#types_ref_list">⇒</a>例外<b>範囲エラー</b>参照リスト<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<b>範囲エラー</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="func">arrayMinIdx</span>整数<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">arrayMaxIdx</a>整数<span class="func">⇒</span>例外<b>範囲エラー</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<b>参照リスト</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="func">⇒</span>例外<b>範囲エラー</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>ファイルする<a class="type" href="#types_ref_list">文字列</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">経路</a>文字列<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>線<span class="func">整数</span>⇒<a class="type" href="#types_integer">例外</a>範囲エラー<b>参考</b>)として参照解除<a class="exception" href="#errors_RANGE_ERROR">参考</a>参考<b>参考</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<span class="func">範囲エラー</span>参考<a class="type" href="#types_integer">)</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">参照リスト</a>)として参照解除<b>参照リスト</b>参照リスト<a class="exception" href="#errors_RANGE_ERROR">参照リスト</a>)<a class="type" href="#types_ref_list">⇒</a>例外<b>範囲エラー</b>参照リスト<a class="exception" href="#errors_RANGE_ERROR">)</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">ブール</a>)として参照解除<b>ブール</b>ブール<a class="exception" href="#errors_RANGE_ERROR">ブール</a>)<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>ブール<span class="func">)</span>⇒<a class="type" href="#types_string">例外</a>範囲エラー<b>Aが参照しない場合</b>FALSE<a class="exception" href="#errors_RANGE_ERROR">または</a>TRUE<span class="func">整数</span>)として参照解除<a class="type" href="#types_string">整数</a>整数<b>整数</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<span class="func">範囲エラー</span>整数<a class="type" href="#types_integer">)</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">bigInteger</a>)として参照解除<span class="type">bigInteger</span>bigInteger<span class="type">bigInteger</span>)<span class="type">⇒</span>例外<span class="type">範囲エラー</span>bigInteger<b>)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="type">浮かぶ</span>)として参照解除<b>浮かぶ</b>浮かぶ<a class="exception" href="#errors_RANGE_ERROR">浮かぶ</a>)<a class="type" href="#types_ref_list">⇒</a>例外<a class="type" href="#types_ref_list">範囲エラー</a>浮かぶ<a class="type" href="#types_ref_list">)</a>⇒<a class="type" href="#types_ref_list">例外</a>範囲エラー<b>char</b>)として参照解除<a class="exception" href="#errors_RANGE_ERROR">char</a>char<a class="type" href="#types_ref_list">char</a>)<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>char<a class="type" href="#types_boolean">)</a>⇒<a class="type" href="#types_boolean">例外</a>範囲エラー<a class="type" href="#types_boolean">文字列</a>)として参照解除<a class="type" href="#types_boolean">文字列</a>文字列<b>文字列</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<a class="type" href="#types_boolean">範囲エラー</a>文字列<b>)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<span class="var">bstring</span>)として参照解除<span class="var">bstring</span>bstring<a class="type" href="#types_integer">bstring</a>)<a class="type" href="#types_integer">⇒</a>例外<a class="type" href="#types_integer">範囲エラー</a>bstring<a class="type" href="#types_integer">)</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">ビットセット</a>)として参照解除<a class="type" href="#types_integer">ビットセット</a>ビットセット<b>ビットセット</b>)<a class="exception" href="#errors_RANGE_ERROR">⇒</a>例外<a class="type" href="#types_bigInteger">範囲エラー</a>ビットセット<a class="type" href="#types_bigInteger">)</a>⇒<a class="type" href="#types_bigInteger">例外</a>範囲エラー<a class="type" href="#types_bigInteger">clib_file</a>)として参照解除<b>clib_file</b>clib_file<a class="exception" href="#errors_RANGE_ERROR">clib_file</a>)<a class="type" href="#types_bigInteger">⇒</a>例外<b>範囲エラー</b>clib_file<a class="exception" href="#errors_RANGE_ERROR">)</a>⇒<a class="type" href="#types_float">例外</a>範囲エラー<a class="type" href="#types_float">プログラム</a>)として参照解除<a class="type" href="#types_float">プログラム</a>プログラム<a class="type" href="#types_float">プログラム</a>)<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>プログラム<a class="type" href="#types_float">)</a>⇒<b>例外</b>範囲エラー<a class="exception" href="#errors_RANGE_ERROR">ACTION</a>)として参照解除<a class="type" href="#types_char">ACTION</a>ACTION<a class="type" href="#types_char">ACTION</a>)<a class="type" href="#types_char">⇒</a>例外<a class="type" href="#types_char">範囲エラー</a>ACTION<b>)</b>⇒<a class="exception" href="#errors_RANGE_ERROR">例外</a>範囲エラー<a class="type" href="#types_char">タイプ</a>)として参照解除<b>タイプ</b>タイプ<a class="exception" href="#errors_RANGE_ERROR">タイプ</a>)<a class="type" href="#types_string">⇒</a>例外<a class="type" href="#types_string">範囲エラー</a>タイプ<a class="type" href="#types_string">)</a>⇒<a class="type" href="#types_string">例外</a>範囲エラー<b>比べる</b>整数<a class="exception" href="#errors_RANGE_ERROR">hashCode</a>整数<a class="type" href="#types_string">変数を設定</a>ブール<b>⇒</b>例外<a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>setCategory<a class="type" href="#types_bstring">カテゴリ</a>⇒<a class="type" href="#types_bstring">例外</a>範囲エラー<a class="type" href="#types_bstring">setType</a>タイプ<a class="type" href="#types_bstring">⇒</a>例外<b>範囲エラー</b>参照リスト<a class="exception" href="#errors_RANGE_ERROR">参照リスト</a>⇒<a class="type" href="#types_bstring">例外</a>範囲エラー<b>無視する</b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_set"></a><a class="type" href="#types_set"></a><a class="type" href="#types_set"></a><a class="type" href="#types_set"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_set"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="type"></span><span class="type"></span><span class="type"></span><span class="type"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="type"></span><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_program"></a><a class="type" href="#types_program"></a><a class="type" href="#types_program"></a><a class="type" href="#types_program"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_program"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><font color="red"></font><font color="red"></font><font color="red"></font><font color="red"></font><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><font color="red"></font><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_type"></a><a class="type" href="#types_type"></a><a class="type" href="#types_type"></a><a class="type" href="#types_type"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_type"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_boolean"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_category"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><span class="func"></span><a class="type" href="#types_type"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="type" href="#types_ref_list"></a><a class="type" href="#types_ref_list"></a><b></b><a class="exception" href="#errors_RANGE_ERROR"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_ref_list">
        <h3>5.31参照リスト</h3>
          </a>
        <p>型式<tt><span class="type">参照リスト</span></tt>リストを説明する<tt><a class="type" href="#types_reference">参考</a></tt>オブジェクト。 その<tt><span class="type">参照リスト</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">ref_list.s7i</span>&quot;</span></p><pre class="tt">
定数:

参照リストが空です。

(ref_list.EMPTY)
インフィックス演算子:

参照リストリスト連結
A
Bは、ref_list内の要素です。
(引数Aのタイプ:

結果のタイプ:
)
A
Bは、ref_listにないエレメントです。
(引数Aのタイプ:

結果のタイプ:
)
指標:

1つのref_list要素へのアクセス
(引数Aのタイプ:

結果のタイプ:

A[1]
1要素目
A[長さ(A)]
最後の要素
A[0]

A[succc(長さ(A))]
)

サブリストにアクセスする
(引数A、Bの型:
)

A位置から始まるサブリストにアクセスする
(引数Aのタイプ:
)

Aで終わるサブリストにアクセスする
(引数Aのタイプ:
)
リレーション:


機能:

(A)ref_listの長さ
(結果の種類:

長さ(
0)

(A)要素Aを持つref_listの作成
(引数Aのタイプ:
)

A
(引数Bのタイプ:

結果のタイプ:
)

A
検索は位置Cから開始されます。
A
(引数Bのタイプ:

引数Cの型:

結果のタイプ:
)
(A, B)を含むリストに要素を含める
(引数Bのタイプ:
)
〜を除く(A, B)リストから要素を除外する
(引数Bのタイプ:
)
ステートメント:
A
B:AにBを追加する
(A&amp;:=B
A:=AとB)
A
[B]C ref_list Aの要素BにCを割り当てる。
(引数Bのタイプ:

引数Cの型:

A@:=[B]C

A:=A[.pred(B)]&amp;make_list(C)&amp;A[succc(B).]
A@:=[0]C

A@:=[cucc(length(A))]C
)

(A)値を無視(Ignore value)する


声明

ref_listのすべての要素をループする
(forVarの引数の型:

引数文のタイプ:
)


声明


ループ本体のステートメントが実行される前に条件を確認してください。
(forVarの引数の型:

引数条件のタイプ:

引数文のタイプ:
)
<span class="type">参照リスト</span><span class="var">空</span>参照リスト<span class="type"></span>価値<span class="var">既定値</span>参照リスト<span class="type">&amp;</span>で<span class="op">参考</span>ブール<span class="op">ない</span>参考<a class="type" href="#types_reference">ブール</a>[<a class="type" href="#types_boolean">A</a>]<span class="op">整数</span>参考<a class="type" href="#types_reference">⇒</a>⇒<a class="type" href="#types_boolean">⇒</a>例外<span class="op">INDEX_ERROR</span>⇒<span class="op">例外</span>INDEX_ERROR<a class="type" href="#types_integer">[</a>A<a class="type" href="#types_reference"></a>B<b>]</b>整数<b>[</b>A<b></b><a class="exception" href="#errors_INDEX_ERROR">]</a>整数<b>[</b><a class="exception" href="#errors_INDEX_ERROR"></a>A<span class="op">]</span>整数<span class="op">=</span><span class="op">&lt;></span>長さ<a class="type" href="#types_integer">整数</a>参照リスト<span class="op">EMPTY)</span>⇒<span class="op">make_list</span>参考<span class="op">pos</span>(A,B)1つ目の位置<a class="type" href="#types_integer">参考</a>B in<span class="op">参照リスト</span>参考<span class="op">整数</span>pos<span class="op">(A、B、C) 1文字目</span>参考<a class="type" href="#types_integer">B in</a>参照リスト<span class="op">参照リスト</span>参考<span class="op">整数</span>整数<span class="func">参考</span>参考<a class="type" href="#types_integer">&amp;:=</a>⇒<span class="type">@:=</span>整数<b>参考</b>⇒<span class="func">⇒</span>例外<a class="type" href="#types_reference">INDEX_ERROR</a>⇒<span class="func">例外</span>INDEX_ERROR<a class="type" href="#types_reference">無視する</a>の<span class="type">forVar</span>範囲<a class="type" href="#types_reference">aRefList</a>do<a class="type" href="#types_integer">終わり</a><span class="func">の</span>参考<a class="type" href="#types_reference">proc</a>の<span class="type">forVar</span>範囲<span class="type">aRefList</span>まで<a class="type" href="#types_reference">状態</a>do<a class="type" href="#types_integer">終わり</a><a class="type" href="#types_integer">の</a>条件が次のようになるまで、ref_listのすべての要素をループする。<a class="type" href="#types_reference">TRUE</a>参考<a class="type" href="#types_reference">ブール</a>proc<span class="op"></span><b></b><span class="op"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_reference"></a><b></b><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><b></b><a class="exception" href="#errors_INDEX_ERROR"></a><a class="func" href="#stats_Ignoring_values"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_reference"></a><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><a class="type" href="#types_reference"></a><a class="type" href="#types_boolean"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_structElement">
        <h3>5.32 structElement</h3>
          </a>
        <p>型式<tt><span class="type">structElement</span></tt>の要素を説明する<tt><a class="type" href="#types_struct">構造体</a></tt>A<tt><span class="type">structElement</span></tt>valueには次の2つのプロパティがあります</p><ul>
    <li>その<tt><a class="type" href="#types_type">タイプ</a></tt>構造体要素の(これは<tt><span class="func">getType</span></tt>)。<li>構造体要素の名前(構造体名は<tt><span class="func">getName</span></tt>)。</ul><p>機能<tt><span class="func">要素</span></tt>は<tt><span class="type">structElement</span></tt>配列。<tt><a class="type" href="#types_struct">構造体</a></tt>:</p><pre class="indent">(aStructType)
<span class="func">要素</span></pre><p>以下のプログラムは<tt><span class="type">exampleStruct</span></tt>:</p><pre class="indent">
$
;




&quot;&quot;;

0;

;






;




writeln(str(
(anElement));

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<span class="keywd"></span>タイプ<a class="type" href="#types_type">:exampleStruct is</a>新しい<span class="keywd"></span>構造体<span class="keywd">var</span><span class="keywd">文字列</span>:aKey<a class="type" href="#types_string">は</a>var<span class="keywd"></span>整数<span class="keywd">:数</span>は<a class="type" href="#types_integer">終わり</a><span class="keywd">構造体</span>const<span class="keywd"></span>proc<span class="keywd">:main</span>は<span class="keywd"></span>機能<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>structElement<span class="keywd">:anElement</span>は<span class="keywd"></span>structElement<span class="keywd"></span>価値<span class="type">begin</span>の<span class="keywd">anElement</span>範囲<span class="type"></span>要素<span class="var">(exampleStruct)</span>do<span class="keywd">getType</span>(anElement))&lt;&amp;&quot;:&quot;&lt;&amp;<span class="keywd">getName</span>終わる<span class="keywd">関数終了</span><span class="func"></span><span class="keywd"></span><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span></pre><p>このプログラムの出力は、次のとおりです。</p><pre class="indent">string:aKey
integer:number
</pre><p>要素記述はテンプレート内で使用できます。 JSONのシリアライズとデシリアライズは<span class="stri">&quot;<span class="lib">json_serde.s7i</span>&quot;</span>図書館の利用<tt><span class="type">structElement</span></tt>その<tt><span class="type">structElement</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">struct_elem.s7i</span>&quot;</span></p><pre class="tt">
定数:

構造体要素が空です。
前置演算子:


(結果の種類:


)
リレーション:


機能:

(A)構造体要素の名前
(結果の種類:
)

(A)構造体要素の型
(結果の種類:
)

(A)構造体型から全ての構造体要素を取得する
(引数Aのタイプ:

結果のタイプ:


)


(引数Aのタイプ:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:

(A)値を無視(Ignore value)する
<span class="type">structElement</span><span class="var">価値</span>シンボル<span class="op">に変換する</span>シンボルパラメータ<a class="link" href="#params_Symbol_parameter">f_param</a>シンボル<span class="type"></span>structElement<span class="op_no_ul"></span>価値<span class="type_no_ul"></span>⇒<span class="var_no_ul">例外</span>範囲エラー<b>=</b><a class="exception" href="#errors_RANGE_ERROR">&lt;></a>getName<span class="op">文字列</span>getType<span class="op">タイプ</span>要素<span class="func">タイプ</span>structElementArray<a class="type" href="#types_string">要素</a>(<span class="func">ブール</span>)<a class="type" href="#types_type">⇒</a>例外<span class="func">ILLEGAL_ACTION</span>structElement<a class="type" href="#types_type">(A)Convert a</a>参考<span class="type">に</span>structElement<span class="func">参考</span>比べる<a class="type" href="#types_boolean">整数</a>hashCode<b>整数</b>無視する<a class="exception" href="#errors_ILLEGAL_ACTION"></a><span class="func"></span><a class="type" href="#types_reference"></a><span class="type"></span><a class="type" href="#types_reference"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_program">
        <h3>5.33プログラム</h3>
          </a>
        <p>型式<tt><span class="type">プログラム</span></tt>に、Seed7プログラムを示します。 現在実行中のプログラムにアクセスできません。 その代わりに、プログラムを解析してそのデータにアクセスできます。 その<tt><span class="type">プログラム</span></tt>関数はライブラリで定義されます。<span class="stri">&quot;<span class="lib">プロジェクトs7i</span>&quot;</span></p><pre class="tt">
定数:

空のプログラムです。

(program.EMPTY)
リレーション:


機能:

アプログラムAのパス、拡張子を除いたもの

イプログラムAの絶対パス

(A)Aという名前のファイルを解析する
(引数Aのタイプ:
)

(A)文字列Aを解析する
(引数Aのタイプ:
)

(A)bstring Aを解析する
(引数Aのタイプ:
)

(A, B)プログラムAの一部である式Bを評価する
(結果の種類:

引数Bの型:
)

(A, B)プログラムAのシステム変数Bの参照を返します。
(結果の種類:

引数Bの型:
)

(A)プログラムAのエラー数
(結果の種類:
)

(A, N)プログラムAからエラーNを取得
(引数Nの型:

結果のタイプ:
)

イプログラムA内のグローバル定義オブジェクト一覧
(結果の種類:
)

(A, B)プログラムAでBという名前のオブジェクトを返す
(結果の種類:

引数Bの型:
)

(A, B)Bに一致するプログラムAからのオブジェクトを返す
(結果の種類:

引数Bの型:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
ステートメント:

(A)Aから参照されるプログラムを実行する

(A)値を無視(Ignore value)する
<span class="type">プログラム</span><span class="var">空</span>プログラム<span class="type"></span>価値<span class="var">既定値</span>プログラム<span class="type">=</span><span class="op">&lt;></span>名前<span class="op">経路</span>parseFile<span class="func">文字列</span>parseStri<span class="func">文字列</span>parseStri<span class="func">bstring</span>評価する<a class="type" href="#types_string">参考</a>参考<span class="func">sysVar</span>参考<a class="type" href="#types_string">文字列</a>errorCount<span class="func">整数</span>getError<a class="type" href="#types_bstring">整数</a>parseError<span class="func">globalObjects</span>参照リスト<a class="type" href="#types_reference">syobject</a>参考<a class="type" href="#types_reference">文字列</a>試合<span class="func">参考</span>参照リスト<a class="type" href="#types_reference">比べる</a>整数<a class="type" href="#types_string">hashCode</a>実行する<span class="func">無視する</span><a class="type" href="#types_integer"></a><span class="func"></span><a class="type" href="#types_integer"></a><a class="type" href="#types_parseError"></a><span class="func"></span><a class="type" href="#types_ref_list"></a><span class="func"></span><a class="type" href="#types_reference"></a><a class="type" href="#types_string"></a><span class="func"></span><a class="type" href="#types_reference"></a><a class="type" href="#types_ref_list"></a><span class="func"></span><a class="type" href="#types_integer"></a><span class="func"></span><span class="func"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_parseError">
        <h3>5.34 parseError</h3>
          </a>
        <p>型式<tt><span class="type">parseError</span></tt>構文的で意味的なことを説明する<a class="link" href="#errors_Parsing_errors">エラー</a>パーサーによって検出されます。 エラー、ファイル、行、列、エラーメッセージ、エラー行に関する情報が表示されます。</p><pre class="tt">
要素:

value;

&quot;&quot;;

0;

0;

&quot;&quot;;

&quot;&quot;;
機能:

(A, N)プログラムAからエラーNを取得
(引数Aのタイプ:

引数の型N:
)
ステートメント:

(A)値を無視(Ignore value)する
<span class="keywd">var</span><span class="type">errorType</span>:error<span class="keywd">は</span><span class="type">errorType</span>var<span class="keywd"></span>文字列<a class="type" href="#types_string">:fileName</a>は<span class="keywd">var</span><span class="keywd">整数</span>:lineNumber<a class="type" href="#types_integer">は</a>var<span class="keywd"></span>整数<span class="keywd">:columnNumber</span>は<a class="type" href="#types_integer">var</a><span class="keywd">文字列</span>:message<span class="keywd">は</span>var<a class="type" href="#types_string"></a>文字列<span class="keywd">:errorLine</span>は<span class="keywd">getError</span>プログラム<a class="type" href="#types_string">整数</a>無視する<span class="keywd"></span><span class="func"></span><a class="type" href="#types_program"></a><a class="type" href="#types_integer"></a><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_ptr">
        <h3>5.35 ptr</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_ptr">ptr</a><span class="type">baseType</span></tt>のオブジェクトへのポインタを記述します。<tt><span class="type">baseType</span></tt>with</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:ptrType<span class="keywd">は</span><a class="type" href="#types_ptr">ptr</a><span class="type">baseType</span></pre><p>新しいポインタ型<tt><span class="type">ptrType</span></tt>が宣言される。</p><pre class="tt">
定数:

NIL参照先となる要素がありません
前置演算子:
&amp;住所
(オペランドのタイプ:
)
後置演算子:
^参照解除
(結果の種類:
)
インフィックス演算子:




リレーション:
=、&lt;>
機能:
base_type(

(主張の種類
)
<span class="type">ptrType</span>baseType<span class="type">baseType</span>ptrType<span class="type"></span>conv<span class="type">A変換元</span>参考<font color="blue">Aから</font>ptrType<a class="type" href="#types_reference">参考</a><span class="type">conv</span>A変換元<a class="type" href="#types_reference">ptrType</a>Aから<font color="blue">参考</font>ptrType<span class="type">)を取得します。</span>baseType<a class="type" href="#types_reference">の</a>ptrType<span class="type">ptrType</span>:<span class="type">タイプ</span><span class="type"></span><span class="type"></span><a class="type" href="#types_type"></a></pre><p></p>
          <a name="types_func">
        <h3>5.36機能</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_func">機能</a><span class="type">baseType</span></tt>を返す関数について説明する。<tt><span class="type">baseType</span></tt>例:<tt><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a></tt>に<tt><a class="type" href="#types_integer">整数</a></tt>関数を使用します。</p><pre class="tt">
値:
ord、str、abs、sqrt、rand、A+B、A*B、A**B
trunc, round, sin, cos, compare, hashCode, pos
replace、trim、length、keys、color、dayOfWeek

で宣言されたすべての関数
は値です。

前置演算子:





value;


声明


の作成
機能
(種類

結果のタイプ:
)






value;


宣言


声明


の作成
ローカル変数を持つ関数
(種類

種類

結果のタイプ:
)


価値
値の結果型で関数を作成する
(値のタイプ:
-これは、任意のタイプ
結果のタイプ:
)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a>機能<span class="keywd">結果</span>var<span class="keywd"></span>baseType<span class="keywd">:resultVariable</span>は<span class="type"></span>baseType<span class="keywd">begin</span>関数終了<span class="type">baseType</span>「声明」<span class="keywd">:</span>proc<span class="keywd">機能</span><span class="type">baseType</span>機能<tt>結果</tt>var<a class="type" href="#types_proc"></a>baseType<a class="type" href="#types_func">:resultVariable</a>は<span class="type"></span>baseType<span class="keywd">地域の</span>begin<span class="keywd">関数終了</span>baseType<span class="keywd">&#39;declarations&#39;</span>:<span class="type">proc</span>「声明」<span class="keywd">:</span>proc<span class="type">機能</span><span class="keywd">baseType</span>リターン<span class="keywd">anyType</span>機能<span class="keywd"></span>anyType<span class="type"></span><tt></tt><a class="type" href="#types_proc"></a><tt></tt><a class="type" href="#types_proc"></a><a class="type" href="#types_func"></a><span class="type"></span><span class="keywd"></span><span class="type"></span><a class="type" href="#types_func"></a><span class="type"></span></pre><p>関数は<tt><a class="type" href="#types_func">機能</a></tt>で始まり<tt><span class="keywd">機能結果</span></tt>または<tt><span class="keywd">リターン</span></tt>オペレータ。 例:</p><pre class="indent">



0;




tak:=z;


tak:=tak(tak(pred(x),y, z)
tak(pred(y),z, x)
tak(pred(z),x, y));

;


<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:tak(<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:x<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:y<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:z)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">整数</span>:tak<a class="type" href="#types_integer">は</a>begin<span class="keywd">if</span>y>=x<span class="keywd">その時</span>else<span class="keywd">if終了</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>を使用した別の例<tt><span class="keywd">リターン</span></tt>機能:</p><pre class="indent">

x*57.295779513082320876798154814114;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_float">浮かぶ</a>:convertReConoDegree(<span class="keywd">で</span><a class="type" href="#types_float">浮かぶ</a>:x)<span class="keywd">は</span>リターン<span class="keywd"></span></pre><p>これは<tt><span class="keywd">リターン</span></tt>関数を<tt><span class="keywd">リターン</span></tt>ステートメントを使用します。 重要なのは<tt><span class="keywd">リターン</span></tt>文が存在します。 の宣言<tt><span class="keywd">リターン</span></tt>関数は次のとおりです。</p><pre class="indent">;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_func">機能</a><span class="type">aType</span>:return(<a class="keywd_no_ul" href="#params_ref_parameter">参照</a><a class="type" href="#types_func">機能</a><span class="type">aType</span><span class="keywd">param</span>)<span class="keywd">はアクションです</span><span class="stri">&quot;PRC_RETURN&quot;</span>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>機能<a class="type" href="#types_func"></a>aType<span class="type">:return(</span>参照<a class="keywd_no_ul" href="#params_ref_parameter"></a>aType<span class="type"></span>param<span class="keywd">)</span>はアクションです<span class="keywd"></span>&quot;PRC_RETURN&quot;<span class="stri"></span></pre><p>その<tt><a class="type" href="#types_func">機能</a></tt>タイプもパラメータとして使用できます。 を用いた関数<tt><a class="type" href="#types_func">機能</a></tt>パラメータは、関数呼び出しの前にこのパラメータを評価しません。 代わりに、このパラメータを関数内で0回以上評価できます。 例:</p><pre class="indent">



FALSE;




conjunction:=second;

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:(<span class="keywd">で</span><a class="type" href="#types_boolean">ブール</a>:first)および(<span class="keywd">で</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:秒)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">ブール</span>:接続詞<a class="type" href="#types_boolean">は</a>begin<span class="keywd">if</span>1番目<span class="keywd">その時</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>ここでは、第1引数が<tt><span class="var">TRUE</span></tt></p>
          <a name="types_varfunc">
        <h3>5.37 varfunc</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_varfunc">varfunc</a><span class="type">baseType</span></tt>を返す関数について説明する。<tt><span class="type">baseType</span></tt>変数。 例:戻り値として<tt><a class="type" href="#types_integer">整数</a></tt>変数は以下で記述される。<tt><a class="type" href="#types_varfunc">varfunc</a><a class="type" href="#types_integer">整数</a></tt>のコール<tt><a class="type" href="#types_varfunc">varfunc</a></tt>は、代入の左側で使用できます。 一般的には<tt><a class="type" href="#types_varfunc">varfunc</a></tt>がある場所で使用することができる<tt><span class="keywd">入力する</span></tt>パラメータが変数を要求しています。</p><pre class="tt">
前置演算子:

value;
変数を返すvarfuncを作成します。

(値のタイプ:
-これは、任意のタイプ
値のアクセス権:

結果のタイプ:
)
<span class="keywd">varを返します。</span>&#39;value&#39;<tt>anyType</tt>var<span class="type">=変数</span>入力する<span class="keywd">パラメータまたは</span>varfunc<tt><span class="keywd">varfunc</span></tt><tt><a class="type" href="#types_varfunc">anyType</a></tt><a class="type" href="#types_varfunc"></a><span class="type"></span></pre><p>var関数は、次のことを表すために使用されます。<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt>および<tt><a class="type" href="#types_struct">構造体</a></tt>アサインの左側と右側で使用できるアクセス。 のアクセス関数。<tt><a class="type" href="#types_hash">ハッシュ</a></tt>は次のように定義されます。</p><pre class="indent">

keyCompare);




keyCompare);
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">baseType</span>:(<span class="keywd">で</span><span class="type">hashType</span>:aHash)[(<span class="keywd">で</span><span class="type">キータイプ</span>:aKey)]<span class="keywd">は</span>リターン<span class="keywd">INDEX(aHash, aKey, hashCode(aKey)</span>hashType<span class="type">const</span><span class="keywd">varfunc</span><a class="type" href="#types_varfunc">baseType</a>:(<span class="type">入力する</span><span class="keywd">hashType</span>:aHash)[(<span class="type">で</span><span class="keywd">キータイプ</span>:aKey)]<span class="type">は</span>varを返します。<span class="keywd">INDEX(aHash, aKey, hashCode(aKey)</span>hashType<span class="keywd"></span><span class="type"></span></pre><p>上の例は<tt><span class="keywd">で</span></tt>および<tt><span class="keywd">入力する</span></tt>パラメータを多重定義することができます。 課題の右側には<tt><a class="type" href="#types_func">機能</a></tt>が呼び出され、左側では<tt><a class="type" href="#types_varfunc">varfunc</a></tt>が呼び出されます。 これにより<a class="type" href="#types_array">配列</a>s<a class="type" href="#types_hash">ハッシュ</a>esおよび<a class="type" href="#types_struct">構造体</a>sは通常どおりに使用できます。</p>
          <a name="types_void">
        <h3>5.38空間</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_void">無</a></tt>は空型を記述します。</p><pre class="tt">
値:


定数:

(空)
<a name="types_empty">空の</a>これは、タイプの唯一の値です。<a class="type" href="#types_void">無</a>無<a class="type" href="#types_void"></a>価値<span class="var">既定値</span>無<a class="type" href="#types_void"></a></pre><p></p>
          <a name="types_proc">
        <h3>5.39 proc</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_proc">proc</a></tt>では、手順について説明します 型式<tt><a class="type" href="#types_proc">proc</a></tt>は次のように定義され<tt><a class="type" href="#types_func">機能</a><a class="type" href="#types_void">無</a></tt></p><pre class="tt">
値:
noop;

;

;
writeln(.);
A:=B;
incr(A);

で宣言されたすべてのプロシージャ
:.は値です
手順
何もせず、空手続きとして使用されます。

前置演算子:




声明


プロシージャを作成する
(種類

結果のタイプ:
)





宣言


声明


ローカル変数を使用したプロシージャを作成する
(種類

種類

結果のタイプ:
)
<span class="keywd">一方で</span><span class="keywd">do</span><span class="keywd">whileを終了する</span>繰り返す<span class="keywd"></span>まで<span class="keywd">const</span><span class="keywd">proc</span>「noop」<a class="type" href="#types_proc">機能</a>begin<tt>関数終了</tt>「声明」<span class="keywd">:</span>proc<span class="keywd">proc</span>機能<span class="keywd">地域の</span>begin<tt>関数終了</tt>&#39;declarations&#39;<a class="type" href="#types_proc">:</a>proc<a class="type" href="#types_proc">「声明」</a>:<span class="keywd">proc</span>proc<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><tt></tt><a class="type" href="#types_proc"></a><tt></tt><a class="type" href="#types_proc"></a><a class="type" href="#types_proc"></a></pre><p></p>
          <a name="types_creator">
        <h3>5.40作成者</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_creator">作成者</a></tt>create演算子について説明します。 演算子の作成(<tt>::=</tt>)は初期化に使用されます。 次のようなものです。<a class="link" href="#stats_Assignment">代入文</a>(<tt><a class="op_no_ul" href="#stats_Assignment">:=</a></tt>)が、行き先は不定である(ゴミが入っている可能性がある)と仮定している。 作成演算子が明示的にコールされません。 その代わりに、定数宣言と変数宣言によって呼び出されます。 値パラメータも初期化にcreate演算子を使用します。 宣言と値パラメータを許可するには、型に対応するcreate演算子が必要です。 create演算子の宣言の例は次のとおりです。</p><pre class="indent">;

;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_creator">作成者</a>:(<a class="keywd_no_ul" href="#params_ref_parameter">参照</a><a class="type_no_ul" href="#types_boolean">ブール</a>:dest)::=(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_boolean">ブール</a>:source)<span class="keywd">は</span><span class="keywd">行動</span><span class="stri">&quot;BLN_CREATE&quot;</span>const<span class="keywd"></span>作成者<a class="type" href="#types_creator">:(</a>参照<a class="keywd_no_ul" href="#params_ref_parameter"></a>整数<a class="type_no_ul" href="#types_integer">:dest)::=(</a>参照<a class="keywd_no_ul" href="#params_ref_parameter"></a>整数<a class="type_no_ul" href="#types_integer">:source)</a>は<span class="keywd"></span>行動<span class="keywd"></span>&quot;INT_CREATE&quot;<span class="stri">const</span><span class="keywd">作成者</span>:(<a class="type" href="#types_creator">参照</a><a class="keywd_no_ul" href="#params_ref_parameter">bigInteger</a>:dest)::=(<a class="type_no_ul" href="#types_bigInteger">参照</a><a class="keywd_no_ul" href="#params_ref_parameter">bigInteger</a>:source)<a class="type_no_ul" href="#types_bigInteger">は</a><span class="keywd">行動</span><span class="keywd">「BIG_CREATE」</span>const<span class="stri"></span>作成者<span class="keywd">:(</span>参照<a class="type" href="#types_creator"></a>文字列<a class="keywd_no_ul" href="#params_ref_parameter">:dest)::=(</a>で<a class="type_no_ul" href="#types_string"></a>文字列<a class="keywd_no_ul" href="#params_in_parameter">:source)</a>は<a class="type_no_ul" href="#types_string"></a>行動<span class="keywd"></span>&quot;STR_CREATE&quot;<span class="keywd">const</span><span class="stri">作成者</span>:(<span class="keywd">参照</span><a class="type" href="#types_creator">proc</a>:dest)::=(<a class="keywd_no_ul" href="#params_ref_parameter">参照</a><a class="type_no_ul" href="#types_proc">proc</a>:source)<a class="keywd_no_ul" href="#params_ref_parameter">は</a><a class="type_no_ul" href="#types_proc">行動</a><span class="keywd">&quot;PRC_CREATE&quot;</span><span class="keywd"></span><span class="stri"></span></pre><p>種類<tt><a class="type_no_ul" href="#types_boolean">ブール</a></tt><tt><a class="type_no_ul" href="#types_integer">整数</a></tt><tt><a class="type_no_ul" href="#types_float">浮かぶ</a></tt><tt><a class="type_no_ul" href="#types_char">char</a></tt><tt><a class="type_no_ul" href="#types_bin64.htm#bin64">bin64</a></tt><tt><a class="type_no_ul" href="#types_bin32.htm#bin64">ビン32</a></tt>および<a class="link" href="#types_enumeration">列挙型</a>ヒープは使用しないでください。 この場合<tt>::=</tt>演算子は、(代入が行うように)送信元から宛先に数バイトをコピーするだけです。</p><p>次のようなタイプの場合<tt><a class="type_no_ul" href="#types_string">文字列</a></tt>および<tt><a class="type_no_ul" href="#types_bigInteger">bigInteger</a></tt>データがヒープに格納されます。 この場合<tt>::=</tt>operatorは、ヒープメモリを割り当て、データを割り当てた領域にコピーします。 最後に、宛先にヒープへのポインタを格納します。</p><p>型式<tt><a class="type" href="#types_creator">作成者</a></tt>は次のように定義され<tt><a class="type" href="#types_func">機能</a><span class="type">作成結果</span></tt>型式<tt><a class="type" href="#types_creator">作成者</a></tt>is similar to<tt><a class="type_no_ul" href="#types_proc">proc</a></tt>型式<tt><a class="type" href="#types_creator">作成者</a></tt>文が必要な場所でのcreate演算子を禁止するために導入されました。 の利用を試みる。<tt>::=</tt>asステートメントはエラーになります:</p><pre class="indent">
***tst492.sd7(7):57:

number::=1;
<a class="link" href="#errors_NO_MATCH">{INT_CREATE({number::=1});{number writeln}}に一致しませんでした</a></pre><p></p>
          <a name="types_destroyer">
        <h3>5.41駆逐艦</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_destroyer">破壊者</a></tt>では、destroy操作について説明し 破棄操作は、データを解放するために使用されます。 それらは明示的に呼び出されていません。 破棄操作は、ある値にアクセスできなくなったときに、自動メモリ管理によって実行されます。 破棄操作の宣言の例は、次のとおりです。</p><pre class="indent">;

;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_destroyer">破壊者</a>:destroy(<a class="keywd_no_ul" href="#params_ref_parameter">参照</a><a class="type_no_ul" href="#types_boolean">ブール</a>:aValue)<span class="keywd">は</span><span class="keywd">行動</span><span class="stri">&quot;GEN_DESTR&quot;</span>const<span class="keywd"></span>破壊者<a class="type" href="#types_destroyer">:destroy(</a>参照<a class="keywd_no_ul" href="#params_ref_parameter"></a>整数<a class="type_no_ul" href="#types_integer">:aValue)</a>は<span class="keywd"></span>行動<span class="keywd"></span>&quot;GEN_DESTR&quot;<span class="stri">const</span><span class="keywd">破壊者</span>:destroy(<a class="type" href="#types_destroyer">参照</a><a class="keywd_no_ul" href="#params_ref_parameter">bigInteger</a>:aValue)<a class="type_no_ul" href="#types_bigInteger">は</a><span class="keywd">行動</span><span class="keywd">&quot;BIG_宣言&quot;</span>const<span class="stri"></span>破壊者<span class="keywd">:destroy(</span>参照<a class="type" href="#types_destroyer"></a>bstring<a class="keywd_no_ul" href="#params_ref_parameter">:aValue)</a>は<a class="type_no_ul" href="#types_bstring"></a>行動<span class="keywd"></span>&quot;BST_DESTR&quot;<span class="keywd">const</span><span class="stri">破壊者</span>:destroy(<span class="keywd">参照</span><a class="type" href="#types_destroyer">proc</a>:aValue)<a class="keywd_no_ul" href="#params_ref_parameter">は</a><a class="type_no_ul" href="#types_proc">行動</a><span class="keywd">&quot;PRC_DESTR&quot;</span><span class="keywd"></span><span class="stri"></span></pre><p>タイプについて<tt><a class="type_no_ul" href="#types_boolean">ブール</a></tt><tt><a class="type_no_ul" href="#types_integer">整数</a></tt><tt><a class="type_no_ul" href="#types_float">浮かぶ</a></tt><tt><a class="type_no_ul" href="#types_char">char</a></tt><tt><a class="type_no_ul" href="#types_bin64.htm#bin64">bin64</a></tt><tt><a class="type_no_ul" href="#types_bin32.htm#bin64">ビン32</a></tt>および<a class="link" href="#types_enumeration">列挙型</a>破棄操作は何も行いません。</p><p>次のようなタイプの場合<tt><a class="type_no_ul" href="#types_string">文字列</a></tt>および<tt><a class="type_no_ul" href="#types_bigInteger">bigInteger</a></tt>破棄操作はヒープ・データを解放します。</p><p>型式<tt><a class="type" href="#types_destroyer">破壊者</a></tt>は次のように定義され<tt><a class="type" href="#types_func">機能</a><span class="type">destroy_result</span></tt>型式<tt><a class="type" href="#types_destroyer">破壊者</a></tt>is similar to<tt><a class="type_no_ul" href="#types_proc">proc</a></tt>型式<tt><a class="type" href="#types_destroyer">破壊者</a></tt>ステートメントが必要な場所でのdestroy操作を禁止するために導入されました。 破棄操作を文として使用しようとすると、エラーが発生します。</p><pre class="indent">
***tst493.sd7(8):57:

destroy(number);
<a class="link" href="#errors_NO_MATCH">{GEN_DESTR({number destroy});{number writeln}}との一致は失敗しました</a></pre><p></p>
          <a name="types_type">
        <h3>5.42型</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_type">タイプ</a></tt>にすべてのタイプを示します。 型宣言の例は次のとおりです。</p><pre class="indent">;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:intArrayType<span class="keywd">は</span><a class="type" href="#types_array">配列</a><a class="type" href="#types_integer">整数</a>const<span class="keywd"></span>タイプ<a class="type" href="#types_type">:arrayIndexChar</a>は<span class="keywd"></span>配列<a class="type" href="#types_array">[</a>char<a class="type" href="#types_char">]</a>文字列<a class="type" href="#types_string">const</a><span class="keywd">タイプ</span>:hashType<a class="type" href="#types_type">は</a><span class="keywd">ハッシュ</span>[<a class="type" href="#types_hash">文字列</a>]<a class="type" href="#types_string">intArrayType</a>const<span class="type"></span>タイプ<span class="keywd">:setType</span>は<a class="type" href="#types_type"></a>設定する<span class="keywd"></span>の<a class="type" href="#types_set"></a>char<span class="type"></span><a class="type" href="#types_char"></a></pre><p>型宣言は常に最上位で行う必要があることに注意してください。 例:</p><pre class="indent">
$
;


;






[](1, 2);



(arr));

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>const<span class="keywd"></span>タイプ<a class="type" href="#types_type">:intArrayType</a>は<span class="keywd"></span>配列<a class="type" href="#types_array"></a>整数<a class="type" href="#types_integer">const</a><span class="keywd">proc</span>:main<a class="type" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">intArrayType</span>:arr<span class="keywd">は</span>begin<span class="type">writeln</span>(<span class="keywd">長さ</span>関数終了<span class="keywd"></span><span class="func"></span><span class="func"></span><span class="keywd"></span></pre><p>型宣言が<tt><span class="type">intArrayType</span></tt>の内側に配置されます。<tt><span class="keywd">地域の</span></tt>declaration blockを使用すると<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst249.sd7(6):57:

var intArrayType:arrは[](1, 2);
<a class="link" href="#errors_NO_MATCH">{var intArrayType:{arr}は{[]{1,2}}}に一致しませんでした</a></pre><p>A<tt><span class="keywd">地域の</span></tt>宣言ブロックは、実行前に完全に解析されます。 これにより<tt><span class="type">intArrayType</span></tt>が解析時に定義されていない。</p><pre class="tt">
値:





,
宣言されたすべてのタイプ
:.は値です
型式
空型として使用されます。
定数:

)
前置演算子:
func関数の型
(
)
varfunc Varfuncタイプ
(
変数)
ptr Pointer type
(
)
配列配列型
(
s)
set型のセット
(
)
subtype既存の型のサブタイプを作成します。
(
)
インフィックス演算子:
A
C三項演算子条件?thenValue:elseValue
(
a

b)
リレーション:
=、&lt;>
機能:


(結果の種類:
)

新しいタイプを作成する

タイプを生成する

(A)サブタイプの生成
typeof(A)式の型を取得します。
(引数Aの型:すべての型に対して定義されています。
typeof(1)

typeof(
)

タイプ
(結果の種類:

isFunc(

isFunc(
)
isFunc(
)

タイプ
(結果の種類:

isVarfunc(

isVarfunc(

isVarfunc(
)

タイプ
(resultType(

resultType(

resultType(
)

(A)このタイプは他のタイプから派生したものか
(結果の種類:

isDerived(
)

(A)A型の派生元の型を取得する
(メタ(
)
base_type(A)配列、ポインタ、構造体の基本型を取得します。
セットタイプ
(base_type(

base_type(

base_type(
)
typeNumber(A)型の一意の番号を取得する
(結果の種類:
)
typeObject(A)型の一意のオブジェクト(マッチオブジェクト)を取得します。
(結果の種類:
)

(A, B)比較関数
(結果の種類:
)

(ア)ハッシュ関数
(結果の種類:
)
ステートメント:
addInterface(A, B)インターフェイスタイプBを実装タイプAに追加します。

価値
定数「name」を「value」で宣言します

価値
変数&#39;name&#39;を&#39;value&#39;で宣言します

(A)値を無視(Ignore value)する
<a class="type" href="#types_void">無</a><a class="type" href="#types_boolean">ブール</a><a class="type" href="#types_integer">整数</a><a class="type" href="#types_rational">合理的な</a><a class="type" href="#types_float">浮かぶ</a><a class="type" href="#types_char">char</a>文字列<a class="type" href="#types_string"></a>参考<a class="type" href="#types_reference"></a>参照リスト<a class="type" href="#types_ref_list"></a>色<a class="type" href="#types_color"></a>時間<a class="type" href="#types_time"></a>持続時間<a class="type" href="#types_duration">ファイルする</a><a class="type" href="#types_file">proc</a><a class="type" href="#types_proc">タイプ</a>const<a class="type" href="#types_type"></a>タイプ<span class="keywd">無</span>タイプ<a class="type" href="#types_type"></a>価値<a class="type" href="#types_void">既定値</a>タイプ<a class="type" href="#types_type">(</a>無<span class="var">機能</span><a class="type" href="#types_type">char</a><a class="type" href="#types_void">⇒</a>を返す関数<a class="type" href="#types_func">char</a>varfunc<a class="type" href="#types_char"></a>char<b></b>⇒<a class="type" href="#types_char">を返す関数</a>char<a class="type" href="#types_varfunc">ptr</a><a class="type" href="#types_char">ビットセット</a><b>⇒</b>へのポインタ<a class="type" href="#types_char">ビットセット</a>配列<a class="type" href="#types_ptr"></a>文字列<a class="type" href="#types_set"></a>⇒<b>の配列</b>文字列<a class="type" href="#types_set">設定する</a><a class="type" href="#types_array">の</a><a class="type" href="#types_string">整数</a><b>⇒</b>のセット<a class="type" href="#types_string">整数</a>副型<a class="type" href="#types_set"></a>char<span class="type"></span>⇒<a class="type" href="#types_integer">のサブタイプ</a>char<b></b>B<a class="type" href="#types_integer">:</a>TRUE<font color="red">a:b</font>⇒<a class="type" href="#types_char">FALSE</a>a:b<b>⇒</b>str<a class="type" href="#types_char">(A)〜への変換</a>文字列<span class="op">文字列</span>新型<span class="op">gentype</span>亜種<span class="var">⇒</span><b>整数</b>「asdf」<span class="var">)</span>⇒<b></b>文字列<a name="types_str(in_type)">isFunc</a>(A)このタイプは<a class="type" href="#types_string">機能</a>ブール<a class="type" href="#types_string">機能</a><a name="types_newtype">char</a>)<a name="types_gentype">⇒</a><a name="types_gensub(in_type">TRUE</a>varfunc<b></b>char<a class="type" href="#types_integer">)</a>⇒<span class="stri"></span>FALSE<b>char</b>)<a class="type" href="#types_string">⇒</a><a name="types_isFunc(in_type)">FALSE</a>isVarfunc<a class="type" href="#types_func">(A)このタイプは</a>varfunc<a class="type" href="#types_boolean">ブール</a>機能<a class="type" href="#types_func"></a>char<a class="type" href="#types_char">)</a>⇒<b></b>FALSE<span class="var">varfunc</span><a class="type" href="#types_varfunc">char</a>)<a class="type" href="#types_char">⇒</a><b>TRUE</b>char<span class="var">)</span>⇒<a class="type" href="#types_char"></a>FALSE<b>結果の種類</b>(A)の結果の型を取得する。<span class="var">機能</span>または<a name="types_isVarfunc(in_type)">varfunc</a>機能<a class="type" href="#types_varfunc"></a>char<a class="type" href="#types_boolean">)</a>⇒<a class="type" href="#types_func"></a>char<a class="type" href="#types_char">proc</a>)<b>⇒</b><span class="var">無</span>整数<a class="type" href="#types_varfunc">)</a>⇒<a class="type" href="#types_char">例外</a>範囲エラー<b>isDerived</b>ブール<span class="var">副型</span><a class="type" href="#types_char">char</a>)<b>⇒</b><span class="var">TRUE</span>メタ<a name="types_resultType(in_type)">副型</a><a class="type" href="#types_func">char</a>)<a class="type" href="#types_varfunc">⇒</a><a class="type" href="#types_func">char</a>配列<a class="type" href="#types_char"></a>char<b>)</b>⇒<a class="type" href="#types_char"></a>char<a class="type" href="#types_proc">ptr</a><b>文字列</b>)<a class="type" href="#types_void">⇒</a><a class="type" href="#types_integer">文字列</a>設定する<b></b>の<a class="exception" href="#errors_RANGE_ERROR"></a>整数<a name="types_isDerived(in_type)">)</a>⇒<a class="type" href="#types_boolean"></a>整数<font color="red">整数</font>参考<a class="type" href="#types_char">比べる</a>整数<b>hashCode</b>整数<span class="var">const</span><a name="types_meta(in_type)">aType</a>:name<font color="red">は</font>var<a class="type" href="#types_char"></a>aType<b>:name</b>は<a class="type" href="#types_char">無視する</a><a class="type" href="#types_array"></a><a class="type" href="#types_char"></a><b></b><a class="type" href="#types_char"></a><a class="type" href="#types_ptr"></a><a class="type" href="#types_string"></a><b></b><a class="type" href="#types_string"></a><a class="type" href="#types_set"></a><span class="type"></span><a class="type" href="#types_integer"></a><b></b><a class="type" href="#types_integer"></a><a class="type" href="#types_integer"></a><a class="type" href="#types_reference"></a><a name="types_compare(in_type,in_type)"></a><a class="type" href="#types_integer"></a><a name="types_hashCode(in_type)"></a><a class="type" href="#types_integer"></a><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="func" href="#stats_Ignoring_values"></a></pre><p></p>
          <a name="types_object">
        <h3>5.43オブジェクト</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_object">物</a></tt>は、さまざまなタイプのメタ型として使用されます。 これにより、これらすべてのタイプに共通の操作を定義できます。 型式<tt><a class="type" href="#types_object">物</a></tt>は、コンテナクラスの要素型としては使用されません。これは、以下のような抽象データ型を使用すると、より適切にタイプセーフになるからです。<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_set">設定する</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt>など。</p><pre class="tt">機能:
TRACE_OBJ(A)内部情報の書き込み
</pre><p></p>
          <a name="types_expr">
        <h3>5.44 expr</h3>
          </a>
        <p>型式<tt><a class="type" href="#types_expr">expr</a></tt>は、マッチしない式を記述するときに使用します。 これらは、関数の認識と型チェックが完了していない式です。 これは、関数の本体の定義などに使用されます。</p><pre class="tt">機能:
WRITE_EXPR(A)
expr AをFILE OUTに書き込む
</pre><p></p>
          <a name="params_file_start"></a>
        <p></p>
          <a name="params_PARAMETERS">
        <h2>6. パラメータ</h2>
          </a>
        <p>次のサブチャプターでは、Seed7のパラメータタイプについて説明します。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>パラメータ</th><th>評価戦略</th><th>仮パラメータへの代入</th></tr>

  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_val_parameter">val</a><span class="type">aType</span>:name</tt>
        </td><td align="center">値渡し</td><td>禁じられた</td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_ref_parameter">参照</a><span class="type">aType</span>:name</tt>
        </td><td align="center">参照による呼び出し</td><td>禁じられた</td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><span class="type">aType</span>:name</tt>
        </td><td align="center">タイプによって異なる</td><td>禁じられた</td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_var_parameter">var内</a><span class="type">aType</span>:name</tt>
        </td><td align="center">値渡し</td><td>許可(実際のパラメータには影響しない)</td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><span class="type">aType</span>:name</tt>
        </td><td align="center">参照による呼び出し</td><td>allowed(実際のパラメータを変更します)</td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><span class="type">aType</span>:name</tt>
        </td><td align="center">
          <a class="link" href="#params_call_by_name_parameter">名指し呼称</a>
        </td><td>禁じられた</td></tr>

</table></dd></dl><p></p>
          <a name="params_val_parameter">
        <h3>6.1&#39;val&#39;パラメータ</h3>
          </a>
        <p>値パラメータはキーワードとともに導入されます。<tt>&#39;<span class="keywd">val</span>&#39;</tt>(例:<tt><span class="keywd">val</span><a class="type" href="#types_string">文字列</a>:stri</tt>値パラメータは、実パラメータの値をコピーします。 正式な<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメータを関数内で変更できません。 値パラメータは、コピーが安価である場合、またはコピーが正しい動作に必要な場合に使用されます。 次の関数は、カンマと文字列を変数に追加します。<tt>&#39;globalStri&#39;</tt>:</p><pre class="indent">


globalStri&amp;:=
;
globalStri&amp;:=stri;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:PSltri(<span class="keywd">val</span><a class="type" href="#types_string">文字列</a>:stri)<span class="keywd">is func</span>begin<span class="keywd">&quot;、&quot;</span>関数終了<span class="stri"></span><span class="keywd"></span></pre><p>実行後</p><pre class="indent">
globalStri&amp;:=
;
pSlTri(globalStri);
<span class="stri">「a」</span></pre><p>変数globalStriには次の値が入ります。<tt><span class="stri">「a、a」</span></tt>関数ヘッダーが</p><pre class="indent"><span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:PSltri(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:stri)<span class="keywd">is func</span></pre><p>変数globalStriには次の値が入ります。<tt><span class="stri">&quot;あ、あ、&quot;</span></tt>この違いは、次の理由によるものです。</p><p>配列の場合<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータが等しい<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータ。 PLastiがglobalStriをパラメータとして呼び出されると、望ましくない副作用が発生します。globalStriを変更するたびに<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータstri. への変更<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータもグローバル変数を変更します。 このような望ましくない副作用は、パラメータ間でも発生する可能性がある(少なくとも1つのパラメータが<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>パラメータ)。</p><p>ほとんどの場合、そのような望ましくない副作用は不可能であるか、容易に回避することができます。 An<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータは<tt>&#39;<span class="keywd">val</span>&#39;</tt>可能であればパラメータを使用する。</p><dl><dt>セマンティクス:</dt><dd>関数を形式的に呼び出す場合<tt>&#39;<span class="keywd">val</span>&#39;</tt>parameterは、対応する実パラメータから値を取得します。 これにはcreate procedure(::=)を使用します。 その関数の内部では、形式的なものしか読むことができない<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメータを使用します。 フォーマルを変える<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメータを使用できません。 関数が残っている場合<tt>&#39;detr&#39;</tt>プロシージャが呼び出される間隔<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメータを使用します。 フォーマル<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメータにはアクセス権があります。<tt>&#39;<span class="keywd">const</span>&#39;</tt></dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>val_parameter::=</dt><dd>&#39;<span class="keywd">val</span>&#39;type_expression&#39;:&#39;identifier_declaration<br />&#39;<span class="keywd">val</span>&#39;type_expression&#39;<span class="keywd">param</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>宣言:</p><pre class="indent">
$
->40;
$
->40;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.val.().param<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.val.().:.(</a>expr<a class="type" href="#types_expr">)</a>は<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">f_param</a>:val(<span class="type">参照</span><span class="keywd">タイプ</span><a class="type" href="#types_type">param</a>)param<span class="keywd">はアクションです</span><span class="keywd">&quot;DCL_VAL1&quot;</span>const<span class="stri"></span>機能<span class="keywd"></span>f_param<a class="type" href="#types_func">:val(</a>参照<span class="type"></span>タイプ<span class="keywd"></span>param<a class="type" href="#types_type">):(</a>参照<span class="keywd"></span>expr<span class="keywd"></span>param<a class="type" href="#types_expr">)</a>はアクションです<span class="keywd"></span>&quot;DCL_VAL2&quot;<span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="params_ref_parameter">
        <h3>6.2&#39;ref&#39;パラメータ</h3>
          </a>
        <p>参照パラメータはキーワードで始まります。<tt>&#39;<span class="keywd">参照</span>&#39;</tt>(例:<tt><span class="keywd">参照</span><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:arr</tt>)。 参照パラメータは、実パラメータの値を参照します。 正式な<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータを関数内で変更できません。 参照パラメータは、コピーにコストがかかり、値を参照しても正しい動作が変わらない場合に使用します。 次の関数は、セミコロン演算子のプリミティブ・アクションを定義します:</p><pre class="indent">noop;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:(<span class="keywd">参照</span><a class="type" href="#types_void">無</a>:statement1);(<span class="keywd">参照</span><a class="type" href="#types_void">無</a>:statement2)<span class="keywd">は</span></pre><p>本定義および他のプリミティブアクションの定義において<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータを使用する。 通常の機能については、通常<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータが代わりに使用されます。<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータ:</p><pre class="indent">



0;



0;




lengthSum+:=length(arr[index]);

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:total_length(<span class="keywd">で</span><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:arr)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">整数</span>:lengthSum<a class="type" href="#types_integer">は</a>地域の<span class="keywd">var</span><span class="keywd">整数</span>:index<span class="keywd">は</span>begin<a class="type" href="#types_integer">の</a>索引<span class="keywd">範囲</span>1<span class="keywd">へ</span>長さ(arr)<span class="keywd">do</span>終わる<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>上記の関数は、次の関数ヘッドで定義することもできる。</p><pre class="indent"><span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:total_length(<span class="keywd">参照</span><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:arr)<span class="keywd">is func</span></pre><p>Since for array types(and for struct types)<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータは、次のように動作するように定義され<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータは両方の定義が等しいです。 An<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータは<tt>&#39;<span class="keywd">参照</span>&#39;</tt>可能であればパラメータを使用する。</p><dl><dt>セマンティクス:</dt><dd>関数を形式的に呼び出す場合<tt>&#39;<span class="keywd">参照</span>&#39;</tt>parameterは、対応する実パラメータを参照するように設定されます。 その関数の内部では、形式的なものしか読むことができない<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータを使用します。 フォーマルを変える<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータを使用できません。 フォーマル<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータにはアクセス権があります。<tt>&#39;<span class="keywd">const</span>&#39;</tt></dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>ref_parameter::=</dt><dd>&#39;<span class="keywd">参照</span>&#39;type_expression&#39;:&#39;identifier_declaration<br />&#39;<span class="keywd">参照</span>&#39;type_expression&#39;<span class="keywd">param</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>宣言:</p><pre class="indent">
$
->40;
$
->40;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.ref.().param<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.ref.().:.(</a>expr<a class="type" href="#types_expr">)</a>は<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">f_param</a>:ref(<span class="type">参照</span><span class="keywd">タイプ</span><a class="type" href="#types_type">param</a>)param<span class="keywd">はアクションです</span><span class="keywd">&quot;DCL_REF1&quot;</span>const<span class="stri"></span>機能<span class="keywd"></span>f_param<a class="type" href="#types_func">:ref(</a>参照<span class="type"></span>タイプ<span class="keywd"></span>param<a class="type" href="#types_type">):(</a>参照<span class="keywd"></span>expr<span class="keywd"></span>param<a class="type" href="#types_expr">)</a>はアクションです<span class="keywd"></span>&quot;DCL_REF2&quot;<span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="params_in_parameter">
        <h3>6.3&#39;in&#39;パラメータ</h3>
          </a>
        <p>入力パラメータはキーワードで始まります。<tt>&#39;<span class="keywd">で</span>&#39;</tt>(例:<tt><span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:数</tt>)。 タイプに応じて、入力パラメータは値または参照パラメータのいずれかになります。 正式な<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータを関数内で変更できません。 以下の関数は、指定した数値が素数かどうかを調べます。</p><pre class="indent">



FALSE;



2;




prime:=TRUE;




incr(count);

;
prime:=数
count&lt;>0;

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:is_prime(<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:番号)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">ブール</span>:prime<a class="type" href="#types_boolean">は</a>地域の<span class="keywd">var</span><span class="keywd">整数</span>:count<span class="keywd">は</span>begin<a class="type" href="#types_integer">if</a>数値=2<span class="keywd">その時</span>elsif<span class="keywd">3以上</span>その時<span class="keywd">一方で</span>数<span class="keywd">レム</span>count&lt;>0<span class="keywd">および</span>count*count&lt;=number<span class="keywd">do</span>whileを終了する<span class="keywd">レム</span>if終了<span class="op">関数終了</span><span class="op"></span><span class="keywd"></span><span class="keywd"></span><span class="op"></span><span class="keywd"></span><span class="keywd"></span></pre><p>次の関数は、外積を定義します。</p><pre class="indent">:
(




0;



1;


積:=長さ(a)
0;




product[index1][index2]:=a[index1]*b[index2];

;

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_integer">整数</a>で<span class="keywd"></span>配列<a class="type" href="#types_array"></a>整数<a class="type" href="#types_integer">:a)ex(</a>で<span class="keywd"></span>配列<a class="type" href="#types_array"></a>整数<a class="type" href="#types_integer">:b)</a>is func<span class="keywd">結果</span>var<span class="keywd"></span>配列<span class="keywd"></span>配列<a class="type" href="#types_array"></a>整数<a class="type" href="#types_array">:product</a>は<a class="type" href="#types_integer">0</a>回<span class="keywd">0</span>回<span class="op">地域の</span>var<span class="op"></span>整数<span class="keywd">:index1</span>は<span class="keywd">begin</span>回<a class="type" href="#types_integer">長さ(b)</a>回<span class="keywd">の</span>インデックス1<span class="keywd">範囲</span>1<span class="op">へ</span>長さ(a)<span class="op">do</span>の<span class="keywd">インデックス2</span>範囲<span class="keywd">1</span>へ<span class="keywd">長さ(b)</span>do<span class="keywd">終わる</span>終わる<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>どちらの例でも<tt>&#39;<span class="keywd">で</span>&#39;</tt>最初の例のパラメータは、実際には<tt>&#39;<span class="keywd">val</span>&#39;</tt>パラメーターを指定します。2番目の例のパラメーターは実際には<tt>&#39;<span class="keywd">参照</span>&#39;</tt>パラメータ。 で新しいタイプが作成されたとき<tt>&#39;newtype&#39;</tt>関数では、その意味を指定する必要があります。<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータを使用します。 これは、パラメータとして新しく生成されたタイプのあるIN_PARAM_IS_VALUEまたはIN_PARAM_IS_REFERENCE関数のコールで実行されます。 で新しいタイプが作成された場合<tt>&#39;サブタイプ&#39;</tt>関数で使用される場合、基本型にはすでに<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータを使用します。</p><dl><dt>セマンティクス:</dt><dd>タイプに応じて<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータは<tt>&#39;<span class="keywd">val</span>&#39;</tt>(値渡し)パラメータまたは<tt>&#39;<span class="keywd">参照</span>&#39;</tt>(参照渡し)パラメータを使用します。 フォーマル<tt>&#39;<span class="keywd">で</span>&#39;</tt>パラメータにはアクセス権があります。<tt>&#39;<span class="keywd">const</span>&#39;</tt></dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>in_parameter::=</dt><dd>&#39;<span class="keywd">で</span>&#39;type_expression&#39;:&#39;identifier_declaration.</dd>
</dl>
          </tt>
        </dd></dl><p>宣言:</p><pre class="indent">
$
->40;
$
->40;


;

;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.in.().param<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.in.().:.(</a>expr<a class="type" href="#types_expr">)</a>は<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">f_param</a>:in(<span class="type">参照</span><span class="keywd">タイプ</span><a class="type" href="#types_type">param</a>)<span class="keywd">param</span><span class="keywd">はアクションです</span><span class="keywd">&quot;DCL_IN1&quot;</span>const<span class="stri"></span>機能<span class="keywd"></span>f_param<a class="type" href="#types_func">:in(</a>参照<span class="type"></span>タイプ<span class="keywd"></span>param<a class="type" href="#types_type">):(</a>参照<span class="keywd"></span>expr<span class="keywd"></span>param<a class="type" href="#types_expr">)</a>はアクションです<span class="keywd"></span>&quot;DCL_IN2&quot;<span class="keywd">const</span><span class="stri">proc</span>:IN_PARAM_IS_VALUE(<span class="keywd">参照</span><a class="type" href="#types_proc">タイプ</a>:aType)<span class="keywd">はアクションです</span><a class="type" href="#types_type">&quot;TYP_SET_IN_PARAM_VALUE&quot;</a>const<span class="keywd"></span>proc<span class="stri">:IN_PARAM_IS_REFERENCE(</span>参照<span class="keywd"></span>タイプ<a class="type" href="#types_proc">:aType)</a>はアクションです<span class="keywd"></span>&quot;TYP_SET_IN_PARAM_REF&quot;<a class="type" href="#types_type"></a><span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="params_in_var_parameter">
        <h3>6.4&#39;in var&#39;パラメータ</h3>
          </a>
        <p>関数内で変更可能な値パラメータは、キーワードで始まります。<tt>&#39;<span class="keywd">var内</span>&#39;</tt>(例:<tt><span class="keywd">var内</span><a class="type" href="#types_integer">整数</a>:a</tt>)。 実パラメタの値をコピーする。 フォーマルへの変更<tt>&#39;<span class="keywd">var内</span>&#39;</tt>パラメータは関数の外では効果を持ちません。 以下の関数は、最大公約数を計算します。</p><pre class="indent">



0;



0;




help:=b
a;
b:=a;
a:=help;

;
gcd:=b;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:gcd(<span class="keywd">var内</span><a class="type" href="#types_integer">整数</a>:a<span class="keywd">var内</span><a class="type" href="#types_integer">整数</a>:b)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">整数</span>:gcd<a class="type" href="#types_integer">は</a>地域の<span class="keywd">var</span><span class="keywd">整数</span>:help<span class="keywd">は</span>begin<a class="type" href="#types_integer">一方で</a>a&lt;>0<span class="keywd">do</span>レム<span class="keywd">whileを終了する</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="op"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>関数を形式的に呼び出す場合<tt><span class="keywd">var内</span></tt>parameterは、対応する実パラメータから値を取得します。 これにはcreate procedure(::=)を使用します。 その関数の内部では、形式的なものを読んだり変更したりすることができる<tt><span class="keywd">var内</span></tt>パラメータを使用します。 フォーマルを変える<tt><span class="keywd">var内</span></tt>パラメータは実パラメータに影響を与えません。 関数が残っている場合<tt>&#39;detr&#39;</tt>プロシージャが呼び出される間隔<tt><span class="keywd">var内</span></tt>パラメータを使用します。 フォーマル<tt><span class="keywd">var内</span></tt>パラメータにはアクセス権があります。<tt><span class="keywd">var</span></tt></dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>in_var_parameter::=</dt><dd>&#39;<span class="keywd">var内</span>&#39;type-expression&#39;:&#39;identifier_declaration.</dd>
</dl>
          </tt>
        </dd></dl><p>宣言:</p><pre class="indent">
$
->40;
$
->40;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:in.var.().param<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:in.var.().:.(</a>expr<a class="type" href="#types_expr">)</a>は<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">f_param</a>:var(<span class="type">参照</span><span class="keywd">タイプ</span><a class="type" href="#types_type">param</a>)<span class="keywd">param</span><span class="keywd">はアクションです</span><span class="keywd">&quot;DCL_IN1VAR&quot;</span>const<span class="stri"></span>機能<span class="keywd"></span>f_param<a class="type" href="#types_func">:var(</a>参照<span class="type"></span>タイプ<span class="keywd"></span>param<a class="type" href="#types_type">):(</a>参照<span class="keywd"></span>expr<span class="keywd"></span>param<a class="type" href="#types_expr">)</a>はアクションです<span class="keywd"></span>&quot;DCL_IN2VAR&quot;<span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="params_inout_parameter">
        <h3>6.5&#39;inout&#39;パラメータ</h3>
          </a>
        <p>関数内部で変更可能な参照パラメータは、キーワードで始まります。<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>(例:<tt><span class="keywd">入力する</span><a class="type" href="#types_integer">整数</a>:数</tt>)。 参照パラメータは、実パラメータの値を参照します。 フォーマルへの変更<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>パラメーターは実引数にも影響します。 次のプロシージャは、指定したパラメータ&#39;number&#39;を2倍にします。</p><pre class="indent">


number:=2*number;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:double(<span class="keywd">入力する</span><a class="type" href="#types_integer">整数</a>:番号)<span class="keywd">is func</span>begin<span class="keywd">関数終了</span><span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>関数を形式的に呼び出す場合<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>parameterは、対応する実パラメータを参照するように設定されます。 その関数の内部では、形式的なものを読んだり変更したりすることができる<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>パラメータを使用します。 フォーマルを変える<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>parameterは、実引数も変更します。 フォーマル<tt>&#39;<span class="keywd">入力する</span>&#39;</tt>パラメータにはアクセス権があります。<tt>&#39;<span class="keywd">var</span>&#39;</tt></dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>inout_parameter::=</dt><dd>&#39;<span class="keywd">入力する</span>&#39;type_expression&#39;:&#39;identifier_declaration.</dd>
</dl>
          </tt>
        </dd></dl><p>宣言:</p><pre class="indent">
$
->40;
$
->40;


;

;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.inout.().param<span class="keywd">は</span>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.inout.().:.(expr)</a>は<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">f_param</a>:inout(<span class="type">参照</span><span class="keywd">タイプ</span><a class="type" href="#types_type">param</a>)param<span class="keywd">はアクションです</span><span class="keywd">&quot;DCL_INOUT1&quot;</span>const<span class="stri"></span>機能<span class="keywd"></span>f_param<a class="type" href="#types_func">:inout(</a>参照<span class="type"></span>タイプ<span class="keywd"></span>param<a class="type" href="#types_type">):(</a>参照<span class="keywd"></span>expr<span class="keywd"></span>param<a class="type" href="#types_expr">)</a>はアクションです<span class="keywd"></span>&quot;DCL_INOUT2&quot;<span class="keywd"></span><span class="stri"></span></pre><p></p>
          <a name="params_call_by_name_parameter">
        <h3>6.6名前によるコール・パラメータ</h3>
          </a>
        <p>名前渡しは、パラメータの評価戦略の1つです。 名前渡しパラメータはキーワードでは導入されません。 以下のような関数型を持つすべてのパラメータ<tt><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a></tt>または<tt><a class="type_no_ul" href="#types_proc">proc</a></tt>は名前による呼び出しのパラメータである。 実際の名前による呼び出しパラメータは、関数が呼び出される前に評価されません。 関数の実行時に、名前による呼び出しパラメータは1回だけ実行される場合もあれば、何度も実行される場合や、まったく実行されない場合があります。</p><p>通常の(名前による呼び出しではない)パラメータの場合、次のことが当てはまります。 関数が呼び出されると、実パラメータ式が評価され、評価結果が関数に転送されます。 想定<tt>数</tt>次の値を持つ<tt>12</tt>次の文が実行されます。</p><pre class="indent">5);
<span class="func_no_ul">シークする</span>(aFile, number<span class="op_no_ul">+</span></pre><p>式<tt>数<span class="op_no_ul">+</span>5</tt>は<tt>17</tt>前<tt><span class="func_no_ul">シークする</span></tt>が呼び出されます。 実際に実行される文は次のとおりです。</p><pre class="indent">(aFile, 17);
<span class="func_no_ul">シークする</span></pre><p>の定義<tt><span class="func_no_ul">シークする</span></tt>の第2パラメータを<tt><a class="type" href="#types_integer">整数</a></tt>次のような整数式ではありません:</p><pre class="indent">
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:seek(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a><a class="type_no_ul" href="#types_file">ファイルする</a>:aFile<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:位置)<span class="keywd">は</span></pre><p>これにより、の評価がトリガーされます<tt>数<span class="op_no_ul">+</span>5</tt>これを次と比較してください。</p><pre class="indent">
数
5;

;
<a class="keywd_no_ul" href="#stats_while-statement">一方で</a>数<span class="op_no_ul">></span>0<a class="keywd_no_ul" href="#stats_while-statement">do</a>-:=<span class="op_no_ul">終わり</span><a class="keywd_no_ul" href="#stats_while-statement">一方で</a><a class="keywd_no_ul" href="#stats_while-statement"></a></pre><p>その<a class="link" href="#stats_while-statement">while文</a>が結果とともに呼び出されない<tt>数<span class="op_no_ul">></span>0</tt>これはループ条件では動作しません。 その<a class="link" href="#stats_while-statement">while文</a>表現を受け取る<tt>数<span class="op_no_ul">></span>0</tt>で行ないます。 このようにして<a class="link" href="#stats_while-statement">while文</a>どのくらいの頻度で行うかを決めることが<tt>数<span class="op_no_ul">></span>0</tt>が評価されます。 これは、関数が呼び出される前に実パラメータ式が評価されるという上記の主張と矛盾します。 明らかに条件パラメータの動作が異なります。 この動作は<a class="link" href="#stats_while-statement">while文</a>:</p><pre class="indent">
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:while(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:condition)do(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_proc">proc</a>:statement)end while<span class="keywd">は</span></pre><p>パラメータ<tt>状態</tt>タイプを持つ<tt><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a></tt>これは、次の式の型とまったく同じです。<tt>数<span class="op_no_ul">></span>0</tt>このため<tt>数<span class="op_no_ul">></span>0</tt>に転送されます。<a class="link" href="#stats_while-statement">while文</a>評価せずに。 すべてのパラメータには<tt><a class="type" href="#types_func">機能</a></tt>このような振る舞いをします。 それらすべての共通の名前は、名前による呼出しパラメーターです。 すべての名前による呼び出しパラメータは、関数が呼び出される前に評価されません。</p><p>ノーマルパラメータと名前による呼び出しパラメータの例:</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>正規パラメータ</th><th>Call-by-nameパラメータ</th></tr>

  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_boolean">ブール</a>:name</tt>
        </td><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_boolean">ブール</a>:name</tt>
        </td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_integer">整数</a>:name</tt>
        </td><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_integer">整数</a>:name</tt>
        </td></tr>
  <tr><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_string">文字列</a>:name</tt>
        </td><td>
          <tt><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_string">文字列</a>:name</tt>
        </td></tr>

</table></dd></dl><p>型式<tt><a class="type_no_ul" href="#types_proc">proc</a></tt>は、名前による呼び出しパラメータを定義するためにも使用できます。</p><pre class="indent">




文;

;

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_proc">proc</a>:possiblyDo(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type_no_ul" href="#types_proc">proc</a>:statement)<span class="keywd">is func</span>begin<span class="keywd">if</span>flipCoin<a class="keywd_no_ul" href="#stats_if-statement">その時</a>if終了<a class="keywd_no_ul" href="#stats_if-statement">関数終了</a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span></pre><p>機能<tt>おそらくDo</tt>任意の文(プロシージャ)で呼び出すことができます。</p><pre class="indent">
おそらくDo(
));
<span class="func_no_ul">writeln</span>(<a class="stri" href="#tokens_String_literals">&quot;hello world&quot;</a></pre></p>
          <a name="params_Symbol_parameter">
        <h3>6.7シンボルパラメータ</h3>
          </a>
        <p>一部の機能では、パラメータ・リスト内の固定位置でキーワードを使用します。 パラメータ・リストのこれらのキーワードは、シンボル・パラメータです。 シンボルパラメータを使用して、2つのバージョンの関数を区別できます。 例:</p><ul>
<li>機能<tt><span class="func">getc</span>(aFile)</tt>は1文字を読めるようになるまで待つ。</li>
<li>機能<tt><span class="func">getc</span>(KEYBOARD, NO_WAIT)</tt>は待ちません。</li>
</ul><p>機能<tt><span class="func">getc</span>(KEYBOARD, NO_WAIT)</tt>は次のように宣言されます。</p><pre class="indent">

;
<span class="keywd">const</span><a class="type_no_ul" href="#types_func">機能</a><a class="type_no_ul" href="#types_char">char</a>:getc(<a class="keywd_no_ul" href="#params_inout_parameter">入力する</a></tt><a class="type_no_ul" href="#types_file">ファイルする</a>:inFile, NO_WAIT)<span class="keywd">は</span>リターン<span class="keywd"></span>inputReady<span class="func_no_ul">(inFile)?</span>getc<span class="func_no_ul">(inFile):</span>KEY_NONE<a class="var_no_ul" href="#file_KEY_NONE"></a></pre><p>この場合<tt>NO_WAIT</tt>はシンボルパラメータです。 シンボルパラメータは、文の中でもキーワードとして使用できます。 次のIF文は、キーワードを要求します。<tt>&#39;<span class="keywd">THEN</span>&#39;</tt><tt>&#39;<span class="keywd">以上</span>&#39;</tt>および<tt>&#39;<span class="keywd">IF</span>&#39;</tt>特定の場所で:</p><pre class="indent">声明

;
<span class="keywd">IF</span>状態<span class="keywd">THEN</span>END IF<span class="keywd"></span></pre><p>このIF文の構文をで定義した後</p><pre class="indent">
$
->25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.IF.().THEN.().END.IF<span class="keywd">は</span></pre><p>意味論は次のように定義できます。</p><pre class="indent">:条件) THEN
(
:statement)
END IF







{TRUE}:文;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:IF(<span class="keywd">で</span><a class="type" href="#types_boolean">ブール</a>で<span class="keywd"></span>proc<a class="type" href="#types_proc">is func</a>begin<span class="keywd">ケース</span>状態<span class="keywd">の</span>いつ<span class="keywd">格を終わらせる</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>シンボルパラメータは括弧の外に記述します。 この文を呼び出すと、次のようになります。</p><pre class="indent">write(value)

;
<span class="keywd">IF</span>値&lt;最大値<span class="keywd">THEN</span>END IF<span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>シンボルパラメータが関数呼び出しの一部である場合は、意味的な定義のみが必要です。 シンボルパラメータが関数呼び出しの一部でない場合は、構文定義および対応する意味定義で定義する必要があります。 実際のパラメータリストには、仮パラメータリストの対応するシンボルを記述する必要があります。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>symbol_parameter::=</dt><dd>name_identifier special_identifier.</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="params_attr_parameter">
        <h3>6.8&#39;attr&#39;パラメータ</h3>
          </a>
        <p>この宣言は、タイプに名前を関連付ける。<tt>&#39;<a class="type" href="#types_char">char</a>&#39;</tt>:</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_string">文字列</a>:name(<span class="keywd">attr</span><a class="type" href="#types_char">char</a>)<span class="keywd">は</span><span class="stri">&quot;char&quot;</span></pre><p>これは<tt>&#39;name&#39;</tt>は、次のように使用できます。</p><pre class="indent">
writeln(name(
));
<a class="type" href="#types_char">char</a></pre><p>このような宣言は多重定義することができます。</p><pre class="indent">;

;
<span class="keywd">const</span><a class="type" href="#types_string">文字列</a>:name(<span class="keywd">attr</span><a class="type" href="#types_boolean">ブール</a>)<span class="keywd">は</span><span class="stri">&quot;ブール&quot;</span>const<span class="keywd"></span>文字列<a class="type" href="#types_string">:name(</a>attr<span class="keywd"></span>浮かぶ<a class="type" href="#types_float">)</a>は<span class="keywd"></span>&quot;float&quot;<span class="stri"></span></pre><p>An<tt>&#39;<span class="keywd">attr</span>&#39;</tt>パラメータは関数内でも使用できます。</p><pre class="indent">

stri[1];
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_char">char</a>:(<span class="keywd">attr</span><a class="type" href="#types_char">char</a>)parse(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:stri)<span class="keywd">は</span>リターン<span class="keywd"></span></pre><p></p><dl><dt>セマンティクス:</dt><dd>実パラメータで<tt>&#39;<span class="keywd">attr</span>&#39;</tt>パラメータは<tt>&#39;<span class="keywd">attr</span>&#39;</tt>パラメータを使用します。 An<tt>&#39;<span class="keywd">attr</span>&#39;</tt>parameterが関数内部で使えるような仮パラメータ変数を宣言していません。</dd></dl>
<dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>attr_parameter::=</dt><dd>&#39;<span class="keywd">attr</span>&#39;type_expression.</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="objects_file_start"></a>
        <p></p>
          <a name="objects_OBJECT_ORIENTATION">
        <h2>7. オブジェクトのオリエンテーション</h2>
          </a>
        <p>多くの人は、C++、Smalltalk、Javaなどの言語のオブジェクト指向に精通しているでしょう。 Seed7は、「インタフェース」を宣言するルートに従います。 インタフェースは、オブジェクトがサポートする操作の共通集合です。 例えば、自動車、オートバイ、トラック、バンはすべて、加速したりブレーキをかけたりすることができ、道路を運転することが合法であれば、すべて左右を表示することができます。</p><p>この見方は新しいものではない。 C言語は原始的なインタフェースを提供します。 Write to a<tt>&#39;file&#39;</tt>Cでは、同じインターフェース(<tt>&#39;fprintf&#39;</tt>)ハードディスクファイル,コンソール出力,プリンタ出力のためのものです. これらのファイルに対して、実装はまったく異なることを行います。 Unixは長い間「すべてが1つのファイル」という考え方を使ってきました(ネットワーク通信でさえ<tt>&#39;file&#39;</tt>インタフェース(参照<tt><a class="type" href="#file_Sockets">ソケット</a></tt>)))。</p><p>簡単に言えば、インターフェースはどのメソッドがサポートされるかを定義し、実装はその方法を記述します。 異なるメソッド実装を持ついくつかの型は、同じインタフェースを共有できます。</p>
          <a name="objects_interface_and_implementation">
        <h3>7.1インターフェースおよび実装</h3>
          </a>
        <p>Seed7は、インタフェース型と実装型を使用します。 インタフェース型で宣言されたオブジェクトは、実装型を持つ値を参照します。 この状況を次の図で説明します。</p><pre class="box">+----------------+
宣言されたインタフェース&lt;---interface type
object:object(コンパイル時に認識されます)
+----------------+

価値を参照する
V
+----------------+
value:implementation&lt;---implementation type
object(コンパイル時には不明)
+----------------+
</pre><p>オブジェクトのインタフェースタイプは、コンパイル時に常に決定できます。 複数の実装タイプが1つのインタフェース型に属することができます(インタフェース型を実装します)。 例:タイプ<tt><span class="type">空ファイル</span></tt><tt><span class="type">外部ファイル</span></tt>および<tt><span class="type">ソケット</span></tt>を実装する<tt><a class="type" href="#types_file">ファイルする</a></tt>インタフェース。 他方では: 実装型は、複数のインタフェース型を実装することもできます。 インタフェースオブジェクトは、インタフェースを実装する実装型を持つ値のみを参照できます。 例:A<tt><span class="type">形</span></tt>変数は<tt><span class="type">ソケット</span></tt></p><p>新しいインタフェース型は次のように宣言されます。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:shape<span class="keywd">は</span><span class="keywd">新しいインターフェース</span></pre><p>インタフェース(動的)関数は、インタフェース型のオブジェクトで何ができるかを記述します。 のためのインタフェース関数。<tt><span class="type">形</span></tt>次のようになります。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:draw(<span class="keywd">で</span><span class="type">形</span>:aShape<span class="keywd">入力する</span><span class="type">窓</span>:aWindow)<span class="keywd">は動的である</span></pre><p>今では、次のことが可能であることがわかっています。<tt>&#39;draw&#39;</tt>a<tt><span class="type">形</span></tt>に<tt><span class="type">窓</span></tt>この描画をどのように行うかは実装型で記述されています。 の実装タイプ。<tt><span class="type">形</span></tt>は:</p><pre class="indent">

0;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:円<span class="keywd">は</span><span class="keywd">new struct</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:半径</a>は<span class="keywd">構造体を終了する</span><span class="keywd"></span></pre><p>当該型式<tt><span class="type">円</span></tt>はの実装タイプです。<tt><span class="type">形</span></tt>は次のように記述されている。</p><pre class="indent">
type_implements_interface(
);
<span class="type">円</span><span class="type">形</span></pre><p>実装する機能<tt>&#39;draw&#39;</tt>の<tt><span class="type">円</span>s</tt>は:</p><pre class="indent">


circle(aWindow.win, aWindow.currX, aWindow.CuRIE
aCircle.radius, aWindow.foreground);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:draw(<span class="keywd">で</span><span class="type">円</span>:aCircle<span class="keywd">入力する</span><span class="type">窓</span>:aWindow)<span class="keywd">is func</span>begin<span class="keywd">関数終了</span><span class="keywd"></span></pre><p>古典的なOOP哲学では、メッセージはオブジェクトに送信されます。 この状況を表現するために、古典的なオブジェクト指向言語では、次のメソッド呼び出し構文を使用します。</p><pre class="indent">param1.method(param2, param3)
</pre><p>その方法では、受信側オブジェクトは以下で参照される。<tt>「自分」</tt>または<tt>「this」</tt>その他のパラメータは、手続き型プログラミング言語と同じメカニズムを使用します(valueまたはreference parameter)。 Seed7では別のアプローチを使用しています。<tt>「自分」</tt>または<tt>「this」</tt>パラメータを使用すると、すべての仮パラメータはユーザ定義名を取得します。 この対称的なアプローチを反映するために、Seed7のメソッド呼び出しは通常の関数呼び出しのように見えます。</p><pre class="indent">method(param1, param2, param3)
</pre><p>の定義<tt>&#39;draw&#39;</tt>上記の関数は仮パラメータを使用する<tt>「aCircle」</tt>の役割で<tt>「自分」</tt>または<tt>「this」</tt>パラメータを使用します。 実装型を持つ仮パラメータは、自動的に<tt>「自分」</tt>または<tt>「this」</tt>パラメータを使用します。</p><p>円オブジェクトを新しく作成する機能も役に立ちます。</p><pre class="indent">



value;


aCircle.radius:=radius;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">円</span>:円(<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:半径)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">円</span>:aCircle<span class="type">は</span><span class="keywd">円</span>begin<span class="type">関数終了</span><span class="keywd"></span><span class="keywd"></span></pre><p>これで<tt><span class="type">円</span></tt>以下のオブジェクト:</p><pre class="indent">draw(circle(50),aWindow);
</pre><p>上記の文はまさにそれがすべきことをしており、インターフェースと実装の間の分離は明らかですが、ほとんどのOO愛好家は興奮しないでしょう。 どの実装関数をコールするかは、コンパイル時にすべて決定できます。 OOファンを喜ばせるためには、このような決定を実行時に行う必要があります。 この決定過程を動的ディスパッチと呼びます。</p>
          <a name="objects_dynamic_dispatch">
        <h3>7.2動的ディスパッチ</h3>
          </a>
        <p>実装タイプが同じ機能(メソッド)の異なる実装を持っている場合、動的ディスパッチが必要である。 インタフェースオブジェクトによって参照される値の型は、コンパイル時には不明です。 この場合、プログラムは、実行時にどの機能の実装を呼び出すかを決定する必要があります。 値の実装タイプに基づいて決定します(値はインタフェース・オブジェクトによって参照されます)。 動的ディスパッチは、DYNAMIC(またはインタフェース)関数が呼び出されたときにのみ発生します。 プログラムが(インタプリタまたはコンパイラで)解析される場合、インタフェース関数と通常の関数の両方を考慮すると、インタフェース関数が優先されます。</p><p>動的ディスパッチを示すために、タイプを定義します。<tt><span class="type">線</span></tt>も実装している。<tt><span class="type">形</span></tt>:</p><pre class="indent">

0.0;

0.0;

;

type_implements_interface(
);





line(aWindow.win, aWindow.currX, aWindow.CuRIE
aLine.xLen, aLine.yLen, aWindow.foreground);

;






value;


aLine.xLen:=xLen;
aLine.yLen:=yLen;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:line<span class="keywd">は</span><span class="keywd">new struct</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:xLen</a>は<span class="keywd">var</span><span class="keywd">整数</span>:yLen<a class="type" href="#types_integer">は</a>関数終了<span class="keywd">線</span><span class="keywd">形</span>const<span class="type"></span>proc<span class="type">:draw(</span>で<span class="keywd"></span>線<a class="type" href="#types_proc">:aLine</a>で<span class="keywd"></span>窓<span class="type">:aWindow)</span>is func<span class="keywd">begin</span>関数終了<span class="type">const</span><span class="keywd">機能</span><span class="keywd">線</span>:line(<span class="keywd">で</span><span class="keywd">整数</span>:xLen<a class="type" href="#types_func">で</a><span class="type">整数</span>:yLen)<span class="keywd">is func</span>結果<a class="type" href="#types_integer">var</a><span class="keywd">線</span>:aLine<a class="type" href="#types_integer">は</a><span class="keywd">線</span>begin<span class="keywd">関数終了</span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span></pre><p>さらに、通常の(DYNAMICではない)関数を定義します。この関数は<tt><span class="type">形</span>s</tt>へ<tt>&#39;currWindow&#39;</tt>:</p><pre class="indent">


draw(aShape, currWindow);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:draw(<span class="keywd">で</span><span class="type">形</span>:aShape)<span class="keywd">is func</span>begin<span class="keywd">関数終了</span><span class="keywd"></span></pre><p>上記の例では、(DYNAMIC)インタフェース関数の呼び出しは次のようになります。<tt>&#39;draw(aShape, currWindow)&#39;</tt>で宣言されたインターフェース関数</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:draw(<span class="keywd">で</span><span class="type">形</span>:aShape<span class="keywd">入力する</span><span class="type">窓</span>:aWindow)<span class="keywd">は動的である</span></pre><p>どの実装関数を呼び出さなければいけないか決定します。 動的ディスパッチは次のように動作します。</p><ul>
<li>インタフェース型を持つすべてのパラメータは、パラメータが値に置き換えられます。 この場合、パラメータ<tt>&#39;aShape&#39;</tt>タイプの値で置き換えられます。<tt><span class="type">円</span></tt>または<tt><span class="type">線</span></tt></li>

<li>コンパイラの解析部分と同じロジックを使用して、一致する関数を見つける。 この検索では、通常関数がインタフェース関数よりも優先されます。</li>

<li>マッチする関数が見つかると、それが呼び出されます。</li>
</ul><p>ここでは、ダイナミックディスパッチの原理について説明します。 実際には、ランタイム中にコンパイラの分析部分を実行する必要はありません。 テーブルと関数ポインタを使用すると、この処理を簡略化できます。</p>
          <a name="objects_inheritance">
        <h3>7.3継承</h3>
          </a>
        <p>新しい<tt><a class="type" href="#types_struct">構造体</a></tt>タイプが定義される既存のものから継承することが可能である<tt><a class="type" href="#types_struct">構造体</a></tt>も参照してください。 例:</p><pre class="indent">

PR IMERIC_NULL_FILE;

;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:external_file<span class="keywd">は</span><span class="keywd">サブ</span><span class="type">空ファイル</span><span class="keywd">構造体</span>var<span class="keywd"></span>clib_file<span class="type">:ext_file</span>は<span class="keywd">var</span><span class="keywd">文字列</span>:name<a class="type" href="#types_string">は</a><span class="keywd">&quot;&quot;</span>構造体を終了する<span class="stri"></span><span class="keywd"></span></pre><p>そのようにタイプは<tt><span class="type">外部ファイル</span></tt>の分野と方法を継承する<tt><span class="type">空ファイル</span></tt>これは次のように宣言されています。</p><pre class="indent">

&#39;\n&#39;;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:null_file<span class="keywd">は</span><span class="keywd">new struct</span>var<span class="keywd"></span>char<a class="type" href="#types_char">:bufferChar</a>は<span class="keywd">構造体を終了する</span><span class="keywd"></span></pre><p>ほとんどの場合、実装タイプが次のような基本的な実装タイプを継承する場合に意味があります。<tt><span class="type">空ファイル</span></tt>そうすることで、すべての派生実装タイプに継承される関数を定義できます。 標準ライブラリに<tt><span class="func">getln</span></tt>は次のような関数です。<p><pre class="indent">



&quot;&quot;;



&quot;&quot;;


buffer:=gets(aFile, 1);


stri&amp;:=buffer;
buffer:=gets(aFile, 1);

;
aFile.bufferChar:=buffer[1];

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getln(<span class="keywd">入力する</span><span class="type">空ファイル</span>:aFile)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">文字列</span>:stri<a class="type" href="#types_string">は</a>地域の<span class="keywd">var</span><span class="keywd">文字列</span>:buffer<span class="keywd">は</span>begin<a class="type" href="#types_string">一方で</a>バッファ&lt;><span class="keywd">&quot;\n&quot;</span><span class="keywd">および</span>バッファ&lt;><span class="keywd">&quot;&quot;</span><span class="stri">do</span>whileを終了する<span class="op">関数終了</span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>すべての継承タイプ<tt><span class="type">空ファイル</span></tt>機能を継承する<tt><span class="func">getln</span></tt>しかし、それを再定義することも自由です。 ウィンドウの<tt><span class="func">getln</span></tt>関数呼び出しの上の関数<tt>&#39;<span class="func">取得</span>(aFile, 1)&#39;</tt>は、(動的)インタフェース関数を使用します。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:gets(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:inFile<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:maxLength)<span class="keywd">は動的である</span></pre><p>他のオブジェクト指向言語では、インタフェース型と基本実装型の区別は行われません。 このような言語では、すべてのメソッド呼び出しに対して動的ディスパッチを使用するか(Javaの場合)、動的ディスパッチを要求するためのキーワードを必要とする(C++の場合<tt>「仮想」</tt>キーワード)。</p><p>継承された実装タイプ間で割当てが行われる場合、構造体の割当ては(ディープ)コピーで行われることに注意することが重要です。 当然ながら、このような割り当ては両方の構造に存在する要素をコピーすることしかできません。 次の例では<tt><span class="type">空ファイル</span></tt>要素は、からコピーされる<tt>&#39;anExternalFile&#39;</tt>へ<tt>&#39;aNullFile&#39;</tt>:</p><pre class="indent">



value;

value;


aNullFile:=anExternalFile;
write(aNullFile, &quot;hello&quot;);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:例<span class="keywd">is func</span>地域の<span class="keywd">var</span><span class="keywd">空ファイル</span>:aNullFile<span class="type">は</span><span class="keywd">空ファイル</span>var<span class="type"></span>外部ファイル<span class="keywd">:anExternalFile</span>は<span class="type"></span>外部ファイル<span class="keywd">begin</span>関数終了<span class="type"></span><span class="keywd"></span><span class="keywd"></span></pre><p>変数ではあるが<tt>&#39;anExternalFile&#39;</tt>に割り当てられる<tt>&#39;aNullFile&#39;</tt>、文<tt>&#39;<span class="func">書く</span>(aNullFile, &quot;hello&quot;)&#39;</tt>が<tt><span class="func">書く</span></tt>タイプの機能(メソッド)<tt><span class="type">空ファイル</span></tt></p><p>新しいインタフェース型は、既存のインタフェース型から継承することもできます。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:shape<span class="keywd">は</span><span class="keywd">サブ</span><span class="type">物</span><span class="keywd">インターフェース</span></pre><p>継承は非常に強力な機能ですが、注意して使用する必要があります。 多くの場合、新しい型がその型から継承する(いわゆる-aリレーション)のではなく、別の型の要素を持つ(いわゆるhas-aリレーション)方が理にかなっています。</p>
          <a name="objects_class_methods">
        <h3>7.4クラスメソッド</h3>
          </a>
        <p>多くのオブジェクト指向プログラミング言語は、インスタンス化されたオブジェクトではなく、クラスに関連付けられたメソッドをサポートします。 このようなメソッドをクラスメソッドまたは静的メソッドと呼びます。 Seed7は、属性(<tt>&#39;<a class="keywd_no_ul" href="#params_attr_parameter">attr</a>&#39;</tt>)パラメータを使用して、関数を<tt><a class="type" href="#types_type">タイプ</a></tt>:</p><pre class="indent">

円(半径);
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">円</span>:create(<a class="keywd_no_ul" href="#params_attr_parameter">attr</a><span class="type">円</span><span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:半径)<span class="keywd">は</span>リターン<span class="keywd"></span></pre><p>これは<tt>&#39;create&#39;</tt>機能がタイプに付随する<tt><span class="type">円</span></tt>で呼び出され</p><pre class="indent">
作成(
,10)
<span class="type">円</span></pre><p>多くの言語では、クラスメソッドを呼び出すときにクラス名をメソッド名の前に置く必要があります(例:<tt>&#39;circle::create(10)&#39;</tt>(C++の場合)。 それとは対照的に<tt>&#39;<a class="keywd_no_ul" href="#params_attr_parameter">attr</a>&#39;</tt>パラメータは特定のパラメータ位置に限定されません。 次の例のように、任意のパラメータ位置で使用できます。</p><pre class="indent">

円(半径);
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">円</span>:create(<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:半径<a class="keywd_no_ul" href="#params_attr_parameter">attr</a><span class="type">円</span>)<span class="keywd">は</span>リターン<span class="keywd"></span></pre><p>この関数は、以下のように呼び出します。</p><pre class="indent">
create(10
)
<span class="type">円</span></pre><p>属性パラメータは、インタフェース型や実装型だけでなく、あらゆる型で使用できます。 文字定数などの関数型を持たないオブジェクトも、型に付加することができます。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_char">char</a>:(<a class="keywd_no_ul" href="#params_attr_parameter">attr</a><a class="type" href="#types_char">char</a>)。 価値<span class="keywd">は</span><span class="stri">「」</span></pre><p>このようにして、属性を使用して、デフォルトなどのタイプのプロパティを指定できます。<tt>&#39;value&#39;</tt>クラス外で関数定義をサポートするSeed7などのプログラミング言語も、クラスメソッドの代わりに通常の関数を使用できます。 関数を型にグループ化すべきか、それとも独立して存在させ、次のように呼び出すべきかは、好みの問題です。</p><pre class="indent">丸(10)
</pre><p></p>
          <a name="objects_multiple_dispatch">
        <h3>7.5複数発報</h3>
          </a>
        <p>Seed7オブジェクト・システムは多重ディスパッチを可能にします(多重継承と混同しないでください)。 メソッドが1つのタイプ(クラス)に割り当てられていません。 実行時にどの関数(メソッド)を呼び出すかは、複数の引数の型によって決まります。 従来のオブジェクト指向は、メソッドが1つのクラスに接続され、ディスパッチの決定が<tt>「自分」</tt>または<tt>「this」</tt>パラメータを使用します。 古典的なオブジェクト指向は単一ディスパッチ方式である。</p><p>以下の例では、type<tt><span class="type">番号</span></tt>数値型の統一が可能なを導入した。 型式<tt><span class="type">番号</span></tt>は、インターフェイス関数を定義するインターフェイスタイプです。<tt>&#39;+&#39;</tt>操作:</p><pre class="indent">;


;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:番号<span class="keywd">は</span><span class="keywd">サブ</span><span class="type">物</span><span class="keywd">インターフェース</span>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>番号<span class="type">:(</span>で<span class="keywd"></span>番号<span class="type">:a)+(</span>で<span class="keywd"></span>番号<span class="type">:b)</span>は動的である<span class="keywd"></span></pre><p>インターフェイスタイプ<tt><span class="type">番号</span></tt>を表すことができる<tt>&#39;<span class="type">整数</span>&#39;</tt>または<tt>&#39;<span class="type">実数</span>&#39;</tt>:</p><pre class="indent">

0;

;

type_implements_interface(
);




0.0;

;

type_implements_interface(
);
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:整数<span class="keywd">は</span><span class="keywd">new struct</span>var<span class="keywd"></span>整数<a class="type" href="#types_integer">:data</a>は<span class="keywd">構造体を終了する</span>整数<span class="keywd"></span>番号<span class="type">const</span><span class="type">タイプ</span>:実数<span class="keywd">は</span><a class="type" href="#types_type">new struct</a>var<span class="keywd"></span>浮かぶ<span class="keywd">:data</span>は<span class="keywd">構造体を終了する</span>実数<a class="type" href="#types_float"></a>番号<span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="type"></span></pre><p>改宗の宣言<tt>&#39;+&#39;</tt>演算子は次のとおりです。</p><pre class="indent">



value;


sum.data:=float(a.data)+b.data;

;






value;


sum.data:=a.data+float(b.data);

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">実数</span>:(<span class="keywd">で</span><span class="type">整数</span>:a)+(<span class="keywd">で</span><span class="type">実数</span>:b)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">実数</span>:sum<span class="type">は</span><span class="keywd">実数</span>begin<span class="type">関数終了</span>const<span class="keywd"></span>機能<span class="keywd"></span>実数<span class="keywd">:(</span>で<a class="type" href="#types_func"></a>実数<span class="type">:a)+(</span>で<span class="keywd"></span>整数<span class="type">:b)</span>is func<span class="keywd">結果</span>var<span class="type"></span>実数<span class="keywd">:sum</span>は<span class="keywd"></span>実数<span class="keywd">begin</span>関数終了<span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span></pre><p>法線の宣言<tt>&#39;+&#39;</tt>(変換しない)演算子は次のとおりです。</p><pre class="indent">



value;


sum.data:=a.data+b.data;

;






value;


sum.data:=a.data+b.data;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">整数</span>:(<span class="keywd">で</span><span class="type">整数</span>:a)+(<span class="keywd">で</span><span class="type">整数</span>:b)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">整数</span>:sum<span class="type">は</span><span class="keywd">整数</span>begin<span class="type">関数終了</span>const<span class="keywd"></span>機能<span class="keywd"></span>実数<span class="keywd">:(</span>で<a class="type" href="#types_func"></a>実数<span class="type">:a)+(</span>で<span class="keywd"></span>実数<span class="type">:b)</span>is func<span class="keywd">結果</span>var<span class="type"></span>実数<span class="keywd">:sum</span>は<span class="keywd"></span>実数<span class="keywd">begin</span>関数終了<span class="type"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span></pre><p>型式<tt><span class="type">番号</span></tt>他のオペレータをサポートするように拡張することができ、を使用した実装も可能です。<tt><a class="type" href="#types_complex">複雑なさま</a></tt><tt><a class="type" href="#types_bigInteger">bigInteger</a></tt><tt><a class="type" href="#types_bigRational">bigRational</a></tt>など。 そうすれば<tt><span class="type">番号</span></tt>数学計算の汎用タイプとして使用できます。 さらに延長すると、汎用型になります。 このような汎用型は、動的型付け言語の支持者に好まれていますが、異なる目的のために別個の型を持つことにも十分な理由があります。</p>
          <a name="objects_replacing_pointers">
        <h3>7.6ポインタのインタフェース型への置換</h3>
          </a>
        <p>多くの言語にはポインタの概念がある。 リストやツリーなどのデータ構造をポインタで実装することができます。 Seed7はポインタの概念をサポートしますが、それらはそのようなデータ構造を記述するのにはあまり適していません。 ポインタのかわりに、インタフェース型を使用できます。 このようにして、リスト、ツリー、およびその他の高度なデータ構造を定義できます。</p><p>次の例は、その方法を示しています。 インターフェイスタイプ<tt><span class="type">要素</span></tt>は「ポインタ」として使用されます。</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:要素<span class="keywd">は</span><span class="keywd">新しいインターフェース</span></pre><p>空の実装タイプ。<tt><span class="type">要素</span></tt>(emptyElement)は、他の実装型が継承できる基本実装型として使用できます。</p><pre class="indent">

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:emptyElement<span class="keywd">は</span><span class="keywd">new struct</span>構造体を終了する<span class="keywd"></span></pre><p>当該実施の種類<tt><span class="type">emptyElement</span></tt>インタフェース型を実装する<tt><span class="type">要素</span></tt>は次のように記述されている。</p><pre class="indent">
type_implements_interface(
);
<span class="type">emptyElement</span><span class="type">要素</span></pre><p>すべてのSeed7式は正確に1つの型を持っているので、特別な<tt>&#39;NIL&#39;</tt>value(と一緒に使用)<tt>&#39;<span class="type">要素</span>NIL&#39;</tt>)を入力します。<tt><span class="type">要素</span></tt>:</p><pre class="indent">value;
<span class="keywd">const</span><span class="type">要素</span>:(<a class="keywd_no_ul" href="#params_attr_parameter">attr</a>要素)。 NIL<span class="keywd">は</span><span class="type">emptyElement</span></pre><p>構造体は2つの「ポインタ」と1つの<tt><a class="type" href="#types_integer">整数</a></tt>次のように宣言できます。</p><pre class="indent">

NIL;

NIL;

0;

;
<span class="keywd">const</span><a class="type" href="#types_type">タイプ</a>:treeElement<span class="keywd">は</span><span class="keywd">サブ</span><span class="type">emptyElement</span><span class="keywd">構造体</span>var<span class="keywd"></span>要素<span class="type">:left</span>は<span class="keywd"></span>要素<span class="type">var</span><span class="keywd">要素</span>:right<span class="type">は</span><span class="keywd">要素</span>var<span class="type"></span>整数<span class="keywd">:item</span>は<a class="type" href="#types_integer">構造体を終了する</a><span class="keywd"></span><span class="keywd"></span></pre><p>最後に<tt><span class="type">treeElement</span></tt>はその型の実装として定義されます。<tt><span class="type">要素</span></tt>:</p><pre class="indent">
type_implements_interface(
);
<span class="type">treeElement</span><span class="type">要素</span></pre><p>構造体への直接アクセスを可能にします。<tt>「左」</tt><tt>「右」</tt>および<tt>&#39;アイテム&#39;</tt>タイプのオブジェクト用<tt><span class="type">要素</span></tt>以下の宣言が必要です。</p><pre class="indent">;

;

;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">要素</span>:(<span class="keywd">参照</span><span class="type">要素</span>:anElem).left<span class="keywd">は動的である</span>const<span class="keywd"></span>varfunc<a class="type" href="#types_varfunc"></a>要素<span class="type">:(</span>入力する<span class="keywd"></span>要素<span class="type">:anElem).left</span>は動的である<span class="keywd">const</span><span class="keywd">機能</span><a class="type" href="#types_func">要素</a>:(<span class="type">参照</span><span class="keywd">要素</span>:anElem).right<span class="type">は動的である</span>const<span class="keywd"></span>varfunc<span class="keywd"></span>要素<a class="type" href="#types_varfunc">:(</a>入力する<span class="type"></span>要素<span class="keywd">:anElem).right</span>は動的である<span class="type">const</span><span class="keywd">機能</span><span class="keywd">整数</span>:(<a class="type" href="#types_func">参照</a><a class="type" href="#types_integer">要素</a>:anElem).item<span class="keywd">は動的である</span>const<span class="type"></span>varfunc<span class="keywd"></span>整数<span class="keywd">:(</span>入力する<a class="type" href="#types_varfunc"></a>要素<a class="type" href="#types_integer">:anElem).item</a>は動的である<span class="keywd"></span><span class="type"></span><span class="keywd"></span></pre><p>これらすべてが宣言されると、次のコードが可能になります。</p><pre class="indent">




anElem:=xalloc(
value);
anElem.item:=item;


addItem(anElem.left, item);


addItem(anElem.right, item);

;

;







listItems(anElem.left);
write(
&lt;&amp;anElem.item);
listItems(anElem.right);

;

;






0;




sum:=anElem.item+sum(anElem.left)+sum(anElem.right);

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:addItem(<span class="keywd">入力する</span><span class="type">要素</span>:anElem<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:item)<span class="keywd">is func</span>begin<span class="keywd">if</span>anElem=<span class="keywd">要素</span>NIL<span class="type">その時</span>treeElement<span class="keywd">elsif</span>項目&lt;anElem.item<span class="type">その時</span>elsif<span class="keywd">item>anElem.item</span>その時<span class="keywd">if終了</span>関数終了<span class="keywd">const</span><span class="keywd">proc</span>:listItems(<span class="keywd">で</span><span class="keywd">要素</span>:anElem)<span class="keywd">is func</span>begin<a class="type" href="#types_proc">if</a>anElem&lt;><span class="keywd">要素</span>NIL<span class="type">その時</span>&quot;&quot;<span class="keywd">if終了</span>関数終了<span class="keywd">const</span><span class="keywd">機能</span><span class="type">整数</span>:sum(<span class="keywd">で</span><span class="stri">要素</span>:anElem)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">整数</span>:sum<a class="type" href="#types_func">は</a>begin<a class="type" href="#types_integer">if</a>anElem&lt;><span class="keywd">要素</span>NIL<span class="type">その時</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>新しい要素は関数&#39;xalloc&#39;で作成することができます。 このように、インタフェースと実装タイプは、ポインタ機能を提供するのに役立ちます。</p><p>ポインタとインタフェース型が常に最善の解決策とは限りません。 動的配列、ハッシュテーブル、構造体型、セット型などの抽象データ型もデータ構造の宣言に使用できる。</p>
          <a name="file_file_start"></a>
        <p></p>
          <a name="file_FILE_INPUT_AND_OUTPUT">
        <h2>8. ファイルの入出力</h2>
          </a>
        <p>ファイルは様々な通信に利用されています。 例:画面上に文字列を書き込むには、次のステートメントを使用します。</p><pre class="indent">);

;
<span class="func">書く</span>(<span class="stri">&quot;hello world&quot;</span>writeln<span class="func"></span></pre><p>手順<tt><span class="func">書く</span></tt>与えられた文字列を書き込み<tt><span class="func">writeln</span></tt>意味:改行復帰します。 また、さまざまなタイプのデータを書き込むことができます。<tt>&#39;write&#39;</tt>:</p><pre class="indent">
write(
);
write(number
5);
write(
);
writeln(
error);
<span class="stri">&quot;result=&quot;</span>div<span class="keywd">&quot;&quot;</span>ない<span class="stri"></span><span class="keywd"></span></pre><p>その<tt>&#39;writeln&#39;</tt>はデータを書き込んでから行を終了する。 これは<tt>&#39;write&#39;</tt>続いて<tt>&#39;writeln&#39;</tt>複数のwriteステートメントの代わりに<tt><span class="keywd">&lt;&amp;</span></tt>演算子を使用して、次のように要素を連結できます。</p><pre class="indent">error);
<span class="func">writeln</span>(<span class="stri">&quot;result=&quot;</span><span class="keywd">&lt;&amp;</span>数<span class="keywd">div</span>5<span class="keywd">&lt;&amp;</span><span class="stri">&quot;&quot;</span><span class="keywd">&lt;&amp;</span><span class="keywd">ない</span></pre><p>その<tt><span class="keywd">&lt;&amp;</span></tt>オペレータは、さまざまなタイプで多重定義されており、次の3つのバリエーションがあります。</p><ul>
    <li><tt><a class="type" href="#types_string">文字列</a><span class="keywd">&lt;&amp;</span><span class="type">otherType</span></tt>: この場合、右オペランドは<tt><a class="type" href="#types_string">文字列</a></tt>と入力します。</li>
    <li><tt><span class="type">otherType</span><span class="keywd">&lt;&amp;</span><a class="type" href="#types_string">文字列</a></tt>: この場合、左オペランドは<tt><a class="type" href="#types_string">文字列</a></tt>と入力します。</li>
    <li><tt><a class="type" href="#types_string">文字列</a><span class="keywd">&lt;&amp;</span><a class="type" href="#types_string">文字列</a></tt>: この場合、2つのオペランドは連結されています。</li>
</ul><p>これにより、以下のように連結を連鎖させることができる。</p><pre class="indent">
write(next_time
booleanExpression);
<span class="keywd">&lt;&amp;</span><span class="stri">「は」</span><span class="keywd">&lt;&amp;</span></pre><p>複数のオブジェクトを鎖状に連結できるのは、第1のオブジェクトまたは第2のオブジェクトが<tt><a class="type" href="#types_string">文字列</a></tt></p><p>キーボードからデータを読み込むこともできます。</p><pre class="indent">
write(
);
read(amount);
<span class="stri">「量?」</span></pre><p>ユーザーは使用を許可されています。<span class="box">バックスペース</span>で上書きし、入力を<span class="box">リターン</span>キーを押します。 ユーザーが<span class="box">リターン</span>キー次のように書くことができます:</p><pre class="indent">
writeln(
);
readln;
<span class="stri">&quot;Type RETURN&quot;</span></pre><p>データ行の読み取りには、次のコマンドを使用できます。<tt>&#39;readln&#39;</tt>:</p><pre class="indent">
write(
);
readln(user_comment_string);
<span class="stri">「コメントは?」</span></pre><p>これまでの例では<tt>「既読」</tt>ファイルから読み込まれる文<tt><span class="var">IN</span></tt>およびすべて<tt>&#39;write&#39;</tt>ファイルに書き込む文<tt><span class="var">OUT</span></tt>・ファイル<tt><span class="var">IN</span></tt>および<tt><span class="var">OUT</span></tt>で初期化される<tt><span class="var">STD_IN</span></tt>および<tt><span class="var">標準出力</span></tt>これらはオペレーティングシステムのstdinファイルとstdoutファイルです。 (通常はキーボードと画面)。 他のファイルに書き込む場合は、そのファイルを最初のパラメータとするwriteステートメントを使用します。 ファイルにテキスト行を書き込むには<tt><span class="stri">&quot;info.fil&quot;</span></tt>以下のステートメントを使用する。</p><pre class="indent">
info_file:=
);
writeln(info_file
);
close(info_file);
<span class="func">開いたさま</span>(<span class="stri">&quot;info.fil&quot;</span><span class="stri">「w」</span>&quot;これはinfoファイルの最初の行です。&quot;<span class="stri"></span></pre><p>まず外部ファイルを書き込み用に開いてから使用します。 文字列でファイルを読み戻すには、次の手順に従います。<tt>「stri」</tt>本文:</p><pre class="indent">
info_file:=
);
readln(info_file, stri);
close(info_file);
<span class="func">開いたさま</span>(<span class="stri">&quot;info.fil&quot;</span><span class="stri">「r」</span></pre><p>他の型の値を書き込むこともできます。<tt>&#39;info_file&#39;</tt>:</p><pre class="indent">writeln(info_file, number);
</pre><p>こちら<tt>&#39;数&#39;</tt>はファイルに書き込まれる文字列に変換される。 A<tt>&#39;数&#39;</tt>次のように読み戻されます。</p><pre class="indent">readln(info_file, number);
</pre><p>画面上のウィンドウに対してI/Oを行うには、次のように記述します。</p><pre class="indent">
window1:=openWindow(screen, 10, 10, 5, 60);
box(window1);
setPos(window1, 3, 1);
write(window1
);
<span class="stri">&quot;こんにちは&quot;</span></pre><p>これは窓を開く<tt>&#39;window1&#39;</tt>で<tt>&#39;screen&#39;</tt>10、10の位置で。 このウィンドウは5行あり、60列あります。 ボックス(文字:-+)で囲み<tt>&#39;window1&#39;</tt>そして最後に<tt><span class="stri">&quot;こんにちは&quot;</span></tt>窓に書いてある<tt>&#39;window1&#39;</tt>位置3で、1。 If we want to clear the<tt>&#39;window1&#39;</tt>本文:</p><pre class="indent">clear(window1);
</pre><p>ファイルはさらに多くのことに使用できます。 以下に、入出力システムの目標を示します。</p><ul>
    <li>任意の型から文字列への変換およびその逆の変換を提供する概念です。</li>

    <li>ファイルを文字単位、単語単位、または行単位で処理するための基本的な入出力操作。</li>

    <li>入出力文は、入力と変換をそれぞれ変換と出力に結合します。</li>

    <li>任意のタイプの標準入力および出力用の単純な読み書き文。</li>

    <li>標準入出力ファイルと、標準入出力を任意のファイルにルーティングする機能。</li>

    <li>オペレーティング・システムのファイルおよびデバイスにアクセスします。</li>

    <li>ユーザが独自のファイルタイプを定義できるようにするインタフェース。</li>
</ul><p>以下のサブチャプターでは、これらの目標のそれぞれについて議論する。</p>
          <a name="file_Conversion_to_strings_and_back">
        <h3>8.1文字列への変換とその逆の変換</h3>
          </a>
        <p>2つの変換関数を持つ任意の型に対してI/Oを行うという目標をアーカイブします。 タイプでI/Oを行うには<tt><span class="func">str</span></tt>および<tt><span class="op">解析する</span></tt>関数をその型用に定義する必要があります。 例として、以下の型の変換関数を示します。<tt><a class="type" href="#types_boolean">ブール</a></tt>:</p><pre class="indent">



;




stri:=
;


stri:=
;

;

;






;




aBoolean:=
;


aBoolean:=
;


上げる
;

;

;
<span class="keywd">const</span><span class="type">機能文字列</span>:str(<span class="keywd">で</span><span class="type">ブール</span>:aBool)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">文字列</span>:stri<span class="type">は</span><span class="keywd">&quot;&quot;</span>begin<span class="stri">if</span>aBool<span class="keywd">その時</span>&quot;TRUE&quot;<span class="keywd">else</span>「間違い」<span class="keywd">if終了</span>関数終了<span class="stri">const</span><span class="keywd">機能ブール</span>:(<span class="stri">attr</span><span class="keywd">ブール</span>)parse(<span class="keywd">で</span><span class="keywd">文字列</span>:stri)<span class="type">is func</span>結果<a class="keywd_no_ul" href="#params_attr_parameter">var</a><span class="type">ブール</span>:aBoolean<span class="keywd">は</span><span class="type">FALSE</span>begin<span class="keywd">if</span>stri=<span class="keywd">&quot;TRUE&quot;</span><span class="keywd">その時</span>TRUE<span class="type">elsif</span>stri=<span class="keywd">「間違い」</span><span class="var">その時</span>FALSE<span class="keywd">else</span>範囲エラー<span class="keywd">if終了</span>関数終了<span class="stri"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><a class="exception" href="#errors_RANGE_ERROR"></a><span class="keywd"></span><span class="keywd"></span></pre><p>その<tt><span class="func">str</span></tt>関数は、型の値毎に対応する文字列を渡さなければなりません。 その<tt><span class="keywd">解析する</span></tt>演算子は文字列を解析し、変換値を結果として返します。 変換が成功しなかった場合、例外が発生します。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>を上げます。 で使用される属性です。<tt><span class="op">解析する</span></tt>様々なタイプに対してオーバーロードすることができます。</p><p>を定義した後<tt><span class="func">str</span></tt>および<tt><span class="op">解析する</span></tt>タイプの関数<tt><span class="func">enable_io</span></tt>関数は、この型に対して次のように呼び出すことができます。</p><pre class="indent">
enable_io(
);
<span class="type">ブール</span></pre><p>その<tt><span class="func">enable_io</span></tt>テンプレートは以下のような様々なio関数を宣言します<tt>「既読」</tt><tt>&#39;write&#39;</tt>その他は提供されたタイプ(この例では<tt><a class="type" href="#types_boolean">ブール</a></tt>)。 出力のみ(または入力のみ)が型に必要な場合は<tt><span class="func">str</span></tt>(または<tt><span class="op">解析する</span></tt>)をクリックして<tt><span class="func">出力有効化</span></tt>(または<tt><span class="func">入力可能</span></tt>)。</p><p>という書式設定演算子もあります。<tt><span class="keywd">パッド</span></tt>これは<tt><span class="func">str</span></tt>関数を使用します。 声明</p><pre class="indent">
write(12
6);
write(3
6);
writeln(45
6);
write(678
6);
write(98765
6);
writeln(4321
6);
<span class="keywd">パッド</span>パッド<span class="keywd">パッド</span>パッド<span class="keywd">パッド</span>パッド<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>結果は次のようになります。</p><pre class="indent">12 3 45
678 98765 4321
</pre><p>私たちが見るように<tt><span class="keywd">パッド</span></tt>演算子を使用して、右揃えの出力を生成できます。 ほかにも<tt><span class="keywd">パッド</span></tt>演算子を使用して、左揃えの出力を生成します。 の基本的な定義は<tt><span class="keywd">パッド</span></tt>および<tt><span class="keywd">パッド</span></tt>演算子は、文字列で次のように動作します。</p><pre class="indent">



;




padded:=
(stri)&amp;stri;


padded:=stri;

;

;






;




padded:=stri&amp;
(stri);


padded:=stri;

;

;
<span class="keywd">const</span><span class="type">機能文字列</span>:(<span class="keywd">参照</span><span class="type">文字列</span>:stri)lpad(<span class="keywd">で</span><span class="type">整数</span>:leng)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">文字列</span>:padded<span class="type">は</span><span class="keywd">&quot;&quot;</span>begin<span class="stri">if</span>leng><span class="keywd">長さ</span>(stri)<span class="keywd">その時</span>&quot;&quot;<span class="func"></span>mult<span class="keywd">leng-</span>長さ<span class="stri">else</span>if終了<span class="op">関数終了</span>const<span class="func"></span>機能文字列<span class="keywd">:(</span>参照<span class="keywd"></span>文字列<span class="keywd">:stri)rpad(</span>で<span class="keywd"></span>整数<span class="type">:leng)</span>is func<span class="keywd">結果</span>var<span class="type"></span>文字列<span class="keywd">:padded</span>は<span class="type"></span>&quot;&quot;<span class="keywd">begin</span>if<span class="keywd">leng></span>長さ<span class="keywd">(stri)</span>その時<span class="type">&quot;&quot;</span><span class="keywd">mult</span>leng-<span class="stri">長さ</span>else<span class="keywd">if終了</span>関数終了<span class="keywd"></span><span class="func"></span><span class="keywd"></span><span class="stri"></span><span class="op"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>その<tt><span class="func">enable_io</span></tt>テンプレートは、の定義を含む<tt><span class="keywd">パッド</span></tt>および<tt><span class="keywd">パッド</span></tt>で指定されたタイプで作業する<tt><span class="func">enable_io</span></tt>:</p><pre class="indent">

leng;




leng;
<span class="keywd">const</span><span class="type">機能文字列</span>:(<span class="keywd">で</span><span class="type">aType</span>:aValue)lpad(<span class="keywd">で</span><span class="type">整数</span>:leng)<span class="keywd">は</span>リターン<span class="keywd">str(aValue)</span>パッド<span class="op">const</span><span class="keywd">機能文字列</span>:(<span class="type">で</span><span class="keywd">aType</span>:aValue)rpad(<span class="type">で</span><span class="keywd">整数</span>:leng)<span class="type">は</span>リターン<span class="keywd">str(aValue)</span>パッド<span class="keywd"></span><span class="op"></span></pre><p>値のタイプ<tt><a class="type" href="#types_integer">整数</a></tt>および<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>10以外の基数(基数)を持つ記数法で書くことができます。 オペレーターは<tt><span class="keywd">基数</span></tt>および<tt><span class="keywd">RADIX</span></tt>は、この目的に使用できます。 例えば、以下のステートメント</p><pre class="indent">
writeln(48879
16);
writeln(3735928559_
16);
<span class="keywd">基数</span>RADIX<span class="keywd"></span></pre><p>結果は次のようになります。</p><pre class="indent">牛肉
DEADBEEF
</pre><p>対象<tt><a class="type" href="#types_float">浮かぶ</a></tt>値を文字列に変換する方法は他にもあります。 その<tt><span class="keywd">指</span></tt>演算子で精度を指定できます。 例えば、以下のステートメント</p><pre class="indent">
writeln(3.1415
2);
writeln(4.0
2);
<span class="keywd">指</span>指<span class="keywd"></span></pre><p>結果は次のようになります。</p><pre class="indent">3.14
4.00
</pre><p>との組み合わせ<tt><span class="keywd">パッド</span></tt>のような演算子</p><pre class="indent">
writeln(3.1415
6);
writeln(99.9
6);
<span class="keywd">指</span>2<span class="keywd">パッド</span>指<span class="keywd">2</span>パッド<span class="keywd"></span></pre><p>も可能で、以下の出力を生成する:</p><pre class="indent">3.14
99.90
</pre><p>科学的表記<tt><a class="type" href="#types_float">浮かぶ</a></tt>変換演算子でサポートされています。<tt><span class="keywd">sci</span></tt>ステートメント</p><pre class="indent">
writeln(0.012345
4);
writeln(1.2468
2);
writeln(3.1415
0);
writeln(0.125
1);
writeln(0.375
1);
<span class="keywd">sci</span>sci<span class="keywd">sci</span>sci<span class="keywd">sci</span><span class="keywd"></span><span class="keywd"></span></pre><p>結果は次のようになります。</p><pre class="indent">1.2345e-2
1.25e+0
3e+0
1.2e-1
3.8e-1
</pre><p>オペレータは<tt><span class="keywd">exp</span></tt>指数部の桁数を指定する。 声明</p><pre class="indent">
writeln(0.012345
2);
writeln(1.2468e15
1);
writeln(3.1415
3);
writeln(0.125
2);
writeln(0.375
2);
<span class="keywd">sci</span>4<span class="keywd">exp</span>sci<span class="keywd">2</span>exp<span class="keywd">sci</span>0<span class="keywd">exp</span>sci<span class="keywd">1</span>exp<span class="keywd">sci</span>1<span class="keywd">exp</span><span class="keywd"></span><span class="keywd"></span></pre><p>結果は次のようになります。</p><pre class="indent">1.2345e-02
1.25e+15
3e+000
1.2e-01
3.8e-01
</pre><p></p>
          <a name="file_Basic_input_and_output_operations">
        <h3>8.2基本的な入出力操作</h3>
          </a>
        <p>オペレーティングシステムファイル以外に任意のユーザ定義ファイルタイプを許可するために、I/Oメソッドがファイル変数のタイプではなくファイル値のタイプに割り当てられるモデルを選択しました。 これにより、ファイル変数は任意のファイル値を指すことができます。 ファイル変数の型は<tt><a class="type" href="#types_file">ファイルする</a></tt>これは順編成ファイルのインタフェースタイプです。 オペレーティングシステムのファイルおよびユーザ定義ファイルそれぞれに対して、入出力方式を定義したファイルタイプを宣言する必要があります。 これらのファイルタイプは、タイプから(直接または間接)派生したものです。<tt><span class="type">空ファイル</span></tt>すべての入出力方式が基本ストリング入出力方式に基づいて定義されています。 したがって、新しいユーザ定義のファイルタイプに対しては、基本的な文字列入出力方法のみを定義する必要があります。</p><p>に定義されている2つの基本入出力方式<tt><span class="type">空ファイル</span></tt>は</p><pre class="indent">noop;






;





;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:write(<span class="keywd">で</span><span class="type">空ファイル</span>:aFile<span class="keywd">で</span><span class="type">文字列</span>:stri)<span class="keywd">は</span>const<span class="keywd"></span>機能文字列<span class="type">:gets(</span>で<span class="keywd"></span>空ファイル<span class="type">:inFile</span>で<span class="keywd"></span>整数<span class="type">:maxLength)</span>is func<span class="keywd">結果</span>var<span class="keywd"></span>文字列<span class="keywd">:striRead</span>は<span class="type"></span>&quot;&quot;<span class="keywd">begin</span>if<span class="stri">maxLength&lt;0</span>その時<span class="keywd">上げる</span><span class="keywd">範囲エラー</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><a class="exception" href="#errors_RANGE_ERROR"></a><span class="keywd"></span><span class="keywd"></span></pre><p>A<tt><span class="func">書く</span></tt>へ<tt><span class="type">空ファイル</span></tt>で任意の数の文字を読み取っても効果はありません。<tt><span class="func">取得</span></tt>から<tt><span class="type">空ファイル</span></tt>は空の文字列を返す。 ユーザ定義のファイルタイプが宣言されると、これらは2つのメソッドになり、新しいファイルタイプ用に再定義する必要があります。 これらの2つの方法に基づいて、さらに3つの方法が定義されます。<tt><span class="type">空ファイル</span></tt>,named<tt><span class="func">getc</span></tt><tt><span class="func">getwd</span></tt>および<tt><span class="func">getln</span></tt>これらのメソッドは、それぞれ文字、単語、行を取得します。 ワードはスペース、タブ、改行で終了します。 行は改行で終了します。 このメソッドは、ユーザ定義のファイルタイプに対して再定義する必要はありませんが、パフォーマンス上の理由から再定義できます。 の定義<tt><span class="func">getc</span></tt><tt><span class="func">getwd</span></tt>および<tt><span class="func">getln</span></tt>の<tt><span class="type">空ファイル</span></tt>は</p><pre class="indent">



;



;


buffer:=
(aFile, 1);


ch:=
;


ch:=buffer[1];

;

;






;



;




buffer:=
(aFile, 1);

;


バッファ&lt;>

stri&amp;:=buffer;
buffer:=
(aFile, 1);

;


aFile.bufferChar:=
;


aFile.bufferChar:=buffer[1];

;

;






;



;


buffer:=
(aFile, 1);


stri&amp;:=buffer;
buffer:=
(aFile, 1);

;


aFile.bufferChar:=
;


aFile.bufferChar:=buffer[1];

;

;
<span class="keywd">const</span><span class="type">func char</span>:getc(<span class="keywd">入力する</span><span class="type">空ファイル</span>:aFile)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">char</span>:ch<span class="type">は</span><span class="keywd">「」</span>地域の<span class="stri">var</span><span class="keywd">文字列</span>:buffer<span class="keywd">は</span><span class="type">&quot;&quot;</span>begin<span class="keywd">取得</span>if<span class="stri">バッファ=</span>&quot;&quot;<span class="keywd"></span>その時<span class="func">ファイルの終り</span>else<span class="keywd">if終了</span>関数終了<span class="stri">const</span><span class="keywd">機能文字列</span>:getwd(<span class="var">入力する</span><span class="keywd">空ファイル</span>:aFile)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">文字列</span>:stri<span class="type">は</span><span class="keywd">&quot;&quot;</span>地域の<span class="type">var</span><span class="keywd">文字列</span>:buffer<span class="keywd">は</span><span class="keywd">&quot;&quot;</span>begin<span class="type">繰り返す</span>取得<span class="keywd">まで</span>バッファ&lt;><span class="stri">&quot;&quot;</span><span class="keywd">および</span>バッファ&lt;><span class="keywd">&quot;\t&quot;</span>一方で<span class="type">バッファ&lt;></span>&quot;&quot;<span class="keywd"></span>および<span class="stri">バッファ&lt;></span>&quot;\t&quot;<span class="keywd"></span>および<span class="keywd">&quot;\n&quot;</span><span class="func">および</span>バッファ&lt;><span class="keywd">&quot;&quot;</span><span class="stri">do</span>取得<span class="keywd">whileを終了する</span>if<span class="stri">バッファ=</span>&quot;&quot;<span class="keywd"></span>その時<span class="stri">ファイルの終り</span>else<span class="keywd">if終了</span>関数終了<span class="stri">const</span><span class="keywd">機能文字列</span>:getln(<span class="stri">入力する</span><span class="keywd">空ファイル</span>:aFile)<span class="stri">is func</span>結果<span class="keywd">var</span><span class="func">文字列</span>:stri<span class="keywd">は</span><span class="keywd">&quot;&quot;</span>地域の<span class="stri">var</span><span class="keywd">文字列</span>:buffer<span class="var">は</span><span class="keywd">&quot;&quot;</span>begin<span class="keywd">取得</span>一方で<span class="keywd">バッファ&lt;></span>&quot;\n&quot;<span class="keywd"></span>および<span class="type">バッファ&lt;></span>&quot;&quot;<span class="keywd"></span>do<span class="type">取得</span>whileを終了する<span class="keywd">if</span>バッファ=<span class="keywd">&quot;&quot;</span><span class="keywd">その時</span>ファイルの終り<span class="type">else</span>if終了<span class="keywd">関数終了</span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="func"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>に注意してください。<tt><span class="func">getwd</span></tt>は先頭のスペースとタブをスキップする。<tt><span class="func">getc</span></tt>および<tt><span class="func">getln</span></tt>しない。もし<tt><span class="func">getc</span></tt><tt><span class="func">getwd</span></tt>または<tt><span class="func">getln</span></tt>が新しいユーザ定義ファイルタイプに対して定義されていない場合<tt><span class="type">空ファイル</span></tt>が使用されます。 これらの宣言は、メソッドに基づいています。<tt><span class="func">取得</span></tt>ユーザ定義のファイルタイプごとに定義する必要があります。</p><p>変数への代入があることに注意してください。<tt>&#39;bufferChar&#39;</tt>この変数は<tt><span class="type">空ファイル</span></tt>派生するすべてのファイルタイプの要素にもなります。 これにより<tt>&#39;eoln&#39;</tt>最後かどうかをテストする関数<tt><span class="func">getwd</span></tt>または<tt><span class="func">getln</span></tt>行末に達する。 以下にの定義を示します。<tt>&#39;eoln&#39;</tt>機能:</p><pre class="indent">

inFile.bufferChar=&#39;\n&#39;;
<span class="keywd">const</span><span class="type">機能ブール</span>:eoln(<span class="keywd">で</span><span class="type">空ファイル</span>:inFile)<span class="keywd">は</span>リターン<span class="keywd"></span></pre><p>値を割り当てる以外に<tt>&#39;bufferChar&#39;</tt>で<tt><span class="func">getwd</span></tt>および<tt><span class="func">getln</span></tt>それを使って<tt>&#39;eoln&#39;</tt>標準<tt><a class="type" href="#types_file">ファイルする</a></tt>関数は何の関係もない<tt>&#39;bufferChar&#39;</tt>の機能は<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリの使用<tt>&#39;bufferChar&#39;</tt>変数をスキャンプロセスの現在の文字として設定します。 そのため<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリでは、処理される最初の文字が常に<tt>&#39;bufferChar&#39;</tt>標準<tt><a class="type" href="#types_file">ファイルする</a></tt>関数にこの振舞いがないため、スキャナ関数とファイル関数を混在させる場合は注意が必要である。</p><p>型式<tt><span class="type">空ファイル</span></tt>には、行末を記述するためのデフォルト関数が用意されています。</p><pre class="indent">


write(outFile
);

;





write(outFile, stri);
writeln(outFile);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:writeln(<span class="keywd">入力する</span><span class="type">空ファイル</span>:outFile)<span class="keywd">is func</span>begin<span class="keywd">&quot;\n&quot;</span>関数終了<span class="stri">const</span><span class="keywd">proc</span>:writeln(<span class="keywd">入力する</span><a class="type" href="#types_proc">空ファイル</a>:outFile<span class="keywd">で</span><span class="type">文字列</span>:stri)<span class="keywd">is func</span>begin<span class="type">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>次の宣言では、文字列に対してさまざまな入出力操作を実行できます。</p><pre class="indent">


stri:=getwd(aFile);

;





stri:=getln(aFile);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:read(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:aFile<span class="keywd">入力する</span><span class="type">文字列</span>:stri)<span class="keywd">is func</span>begin<span class="keywd">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:readln(</span>入力する<a class="type" href="#types_proc"></a>ファイルする<span class="keywd">:aFile</span>入力する<a class="type" href="#types_file"></a>文字列<span class="keywd">:stri)</span>is func<span class="type">begin</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p>
          <a name="file_Input_and_output_with_conversion">
        <h3>8.3変換を伴う入出力</h3>
          </a>
        <p>通常は、入出力操作と変換操作を組み合わせる必要があります。 に基づいたいくつかの関数があります。<tt><span class="func">str</span></tt>および<tt><span class="op">解析する</span></tt>基本入出力機能に基づいている。 この関数の宣言は<tt><span class="func">enable_io</span></tt><tt><span class="func">入力可能</span></tt>および<tt><span class="func">出力有効化</span></tt>・テンプレート<tt><span class="func">enable_io</span></tt>および<tt><span class="func">出力有効化</span></tt>以下を定義する<tt><span class="func">書く</span></tt>機能:</p><pre class="indent">


write(aFile, str(aValue));

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:write(<span class="keywd">で</span><a class="type" href="#types_file">ファイルする</a>:aFile<span class="keywd">で</span><span class="type">aType</span>:aValue)<span class="keywd">is func</span>begin<span class="keywd">関数終了</span><span class="keywd"></span></pre><p>テンプレート<tt><span class="func">enable_io</span></tt>および<tt><span class="func">入力可能</span></tt>以下を定義する<tt><span class="func">読む</span></tt>および<tt><span class="func">readln</span></tt>関数:</p><pre class="indent">


aValue:=
(aFile);

;





aValue:=
(aFile));

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:read(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:aFile<span class="keywd">入力する</span><span class="type">aType</span>:aValue)<span class="keywd">is func</span>begin<span class="keywd">aType</span><span class="type">解析する</span><span class="op">getwd</span>関数終了<span class="func">const</span><span class="keywd">proc</span>:readln(<span class="keywd">入力する</span><a class="type" href="#types_proc">ファイルする</a>:aFile<span class="keywd">入力する</span><a class="type" href="#types_file">aType</a>:aValue)<span class="keywd">is func</span>begin<span class="type">aType</span><span class="keywd">解析する</span>trimValue(aType<span class="keywd">getln</span>関数終了<span class="type"></span><span class="op"></span><span class="func"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">trimValue</span></tt>を使用して<tt><a class="type" href="#types_string">文字列</a></tt>によって回収される<tt><span class="func">getln</span></tt>これにより<tt><a class="type" href="#types_string">文字列</a></tt>の前<tt><span class="op">解析する</span></tt>演算子が適用されます。 次の3つのケースがあります。</p><ul>
    <li>のトリミング<tt><a class="type" href="#types_string">文字列</a></tt>で<tt><span class="func">trimValue</span>(<a class="type" href="#types_string">文字列</a>,String)</tt>:文字列を変更しないで残します。</li>
    <li>のトリミング<tt><a class="type" href="#types_char">char</a></tt>で<tt><span class="func">trimValue</span>(<a class="type" href="#types_char">char</a>,String)</tt>::<span class="stri">&quot;&quot;</span>が返されます。<span class="stri">&quot;&quot;</span>それ以外の場合は、トリムされた長さ1の文字列を返す。</li>
    <li>他のすべてのタイプのトリミング<tt><span class="func">trimValue</span>(<span class="type">aType</span>,String)</tt>:先頭と末尾のスペースを削除します。</li>
</ul><p>次の宣言は<tt>&#39;backSpace&#39;</tt>:</p><pre class="indent">


write(aFile
);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:backSpace(<span class="keywd">参照</span><span class="type">外部ファイル</span>:aFile)<span class="keywd">is func</span>begin<span class="keywd">&quot;\b\b&quot;</span>関数終了<span class="stri"></span><span class="keywd"></span></pre><p></p>
          <a name="file_Simple_read_and_write_statements">
        <h3>8.4単純な読取り文と書込み文</h3>
          </a>
        <p>標準入出力ファイルの簡単な入出力は以下の通りです。<tt>「既読」</tt>および<tt>&#39;write&#39;</tt>で定義されています。<tt><span class="func">enable_io</span></tt>単純I/Oは次のようになります。</p><pre class="indent">
write(
);
read(amount);
<span class="stri">「量?」</span></pre><p><tt>「既読」</tt>および<tt>&#39;write&#39;</tt>ファイルを使用する<tt><span class="var">IN</span></tt>および<tt><span class="var">OUT</span></tt>これについては、次の章で説明します。 これがその定義です。<tt>「既読」</tt>および<tt>&#39;write&#39;</tt>完了した手順<tt><span class="func">enable_io</span></tt>:</p><pre class="indent">


読み込み(
,aValue);

;





readln(
,aValue);

;





write(
,aValue);

;





writeln(
,aValue);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:read(<span class="keywd">入力する</span><span class="type">aType</span>:aValue)<span class="keywd">is func</span>begin<span class="keywd">IN</span>関数終了<span class="var">const</span><span class="keywd">proc</span>:readln(<span class="keywd">入力する</span><a class="type" href="#types_proc">aType</a>:aValue)<span class="keywd">is func</span>begin<span class="type">IN</span>関数終了<span class="keywd">const</span><span class="keywd">proc</span>:write(<span class="var">で</span><span class="keywd">aType</span>:aValue)<span class="keywd">is func</span>begin<a class="type" href="#types_proc">OUT</a>関数終了<span class="keywd">const</span><span class="type">proc</span>:writeln(<span class="keywd">で</span><span class="keywd">aType</span>:aValue)<span class="var">is func</span>begin<span class="keywd">OUT</span>関数終了<span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span></pre><p>の外部で定義された追加手順<tt><span class="func">enable_io</span></tt>は:</p><pre class="indent">



;


stri:=getln(
);

;





writeln(
);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:readln<span class="keywd">is func</span>地域の<span class="keywd">var</span><span class="keywd">文字列</span>:stri<span class="type">は</span><span class="keywd">&quot;&quot;</span>begin<span class="stri">IN</span>関数終了<span class="keywd">const</span><span class="var">proc</span>:writeln<span class="keywd">is func</span>begin<span class="keywd">OUT</span>関数終了<a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span></pre><p>たとえば</p><pre class="indent">(数)
<span class="func">readln</span></pre><p>その<tt>readln(number)</tt>タイプの関数<tt><a class="type" href="#types_integer">整数</a></tt>電話</p><pre class="indent">,数);
<span class="func">readln</span>(<span class="var">IN</span></pre><p>それは実行する</p><pre class="indent">
数:=
));
<a class="type" href="#types_integer">整数</a><span class="op">解析する</span><span class="func">trimValue</span>(<a class="type" href="#types_integer">整数</a><span class="func">getln</span>(<span class="var">IN</span></pre><p>ファイル<tt><span class="var">IN</span></tt>独自の実装を持つことがある<tt><span class="func">getln</span></tt>(例:<tt><span class="func">getln</span></tt>の<tt><span class="type">外部ファイル</span></tt>)。 のデフォルトの実装は<tt><span class="func">getln</span></tt>(in<tt><span class="type">空ファイル</span></tt>)コール<tt><span class="func">取得</span>(<span class="var">IN</span>,1)</tt>ループになっています。 型について<tt><a class="type" href="#types_integer">整数</a></tt>その機能<tt><span class="func">trimValue</span></tt>先頭および末尾のスペースを削除します。 最後に<tt><span class="op">解析する</span></tt>演算子は、読み込まれた文字列を<tt><a class="type" href="#types_integer">整数</a></tt>割り当てられる<tt>&#39;数&#39;</tt></p>
          <a name="file_Standard_input_and_output_files">
        <h3>8.5標準入出力ファイル</h3>
          </a>
        <p>標準入出力ファイルは次のとおりです。<tt><span class="var">IN</span></tt>入力用<tt><span class="var">OUT</span></tt>出力用。<tt><span class="var">IN</span></tt>および<tt><span class="var">OUT</span></tt>は<tt><a class="type" href="#types_file">ファイルする</a></tt>変数は以下のように定義される:</p><pre class="indent">;

;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:<span class="var">IN</span><span class="keywd">は</span><span class="var">STD_IN</span>var<span class="keywd"></span>ファイルする<a class="type" href="#types_file">:</a>OUT<span class="var"></span>は<span class="keywd"></span>標準出力<span class="var"></span></pre><p>ファイル<tt><span class="var">STD_IN</span></tt>および<tt><span class="var">標準出力</span></tt>はオペレーティングシステムの標準的な入出力ファイルです(通常はキーボードと画面)。 なぜなら<tt><span class="var">IN</span></tt>および<tt><span class="var">OUT</span></tt>は変数です。標準入力または標準出力のリダイレクトは、それらに新しい値を割り当てることで簡単に行うことができます。</p><pre class="indent">:=OTHER_FILE;
<span class="var">IN</span></pre><p>その後は<tt>「既読」</tt>言及する声明<tt>OTHER_FILE</tt>ほとんどのオペレーティングシステムにはstderrファイルもあり<tt><span class="var">標準偏差</span></tt>標準出力が他の場所にリダイレクトされても画面にエラーメッセージを表示したい場合は、次のように記述します。</p><pre class="indent">
writeln(
);
<span class="var">標準偏差</span><span class="stri">「エラーメッセージ」</span></pre><p>標準出力をリダイレクトするには<tt><span class="var">標準偏差</span></tt>次のように書くことができます。</p><pre class="indent">;
<span class="var">OUT</span>:=<span class="var">標準偏差</span></pre><p>ファイルもあります。<tt><span class="var">STD_NULL</span></tt>が定義されました そこに書き込まれたものはすべて無視されます。そこから読み取ると空の文字列が返されます。 このファイルは、次のようにファイル変数の初期化に使用できます。</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:MY_FILE<span class="keywd">は</span><span class="var">STD_NULL</span></pre><p>また、次のような場合には、不正なファイル値を表すためにも使用されます。<tt><span class="func">開いたさま</span></tt>a<tt><a class="type" href="#types_file">ファイルする</a></tt>が失敗した場合に</p>
          <a name="file_Access_to_operating_system_files">
        <h3>8.6オペレーティング・システム・ファイルへのアクセス</h3>
          </a>
        <p>インターフェイスタイプ<tt><a class="type" href="#types_file">ファイルする</a></tt>は、オペレーティングシステムファイルへのアクセスにも使用されます。 通常はファイル変数が定義されます。</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:my_out<span class="keywd">は</span><span class="var">STD_NULL</span></pre><p>と<tt><span class="func">開いたさま</span></tt>機能がこのファイル変数に割り当てられる</p><pre class="indent">
my_out:=open(
);
<span class="stri">&quot;my_file&quot;</span><span class="stri">「w」</span></pre><p>の第1引数<tt><span class="func">開いたさま</span></tt>は開くファイルのパスです。 このパスは<a class="link" href="#os_Standard_path_representation">標準経路表現</a>これは、スラッシュ(<tt>「/」</tt>)をパスの区切り文字として使用します。 バックスラッシュまたはドライブ文字を含むパスは、例外が発生する場合があります。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>の第2引数。<tt><span class="func">開いたさま</span></tt>モードを指定します。</p><dl><dd><dl>
    <dt>バイナリモード:</dt><dd><table border="0" cellspacing="0">
      <tr><td>
          <span class="stri">「r」</span>
        </td>   <td> </td><td>読み込みのためにファイルを開きます。</td></tr>
      <tr><td>
          <span class="stri">「w」</span>
        </td>   <td> </td><td>書き込むためにファイルを開くか作成し、長さを0に切り捨ててください。</td></tr>
      <tr><td>
          <span class="stri">「a」</span>
        </td>   <td> </td><td>追加(ファイルの終わりへの書き込み)のためにファイルを開くか作成します。</td></tr>
      <tr><td>
          <span class="stri">「r+」</span>
        </td>  <td> </td><td>更新(読み込みと書き込み)のためにファイルを開きます。</td></tr>
      <tr><td>
          <span class="stri">「w+」</span>
        </td>  <td> </td><td>更新して長さを0にするためにファイルを開くか作成してください。</td></tr>
      <tr><td>
          <span class="stri">「a+」</span>
        </td>  <td> </td><td>追加および読み込みのためにファイルを開くか作成してください。</td></tr></table>
    <dt>テキストモード:</dt><dd><table border="0" cellspacing="0">
      <tr><td>
          <span class="stri">「rt」</span>
        </td>  <td> </td><td>読み込みのためにファイルを開きます。</td></tr>
      <tr><td>
          <span class="stri">&quot;wt&quot;</span>
        </td>  <td> </td><td>書き込むためにファイルを開くか作成し、長さを0に切り捨ててください。</td></tr>
      <tr><td>
          <span class="stri">&quot;at&quot;</span>
        </td>  <td> </td><td>追加(ファイルの終わりへの書き込み)のためにファイルを開くか作成します。</td></tr>
      <tr><td>
          <span class="stri">「rt+」</span>
        </td> <td> </td><td>更新(読み込みと書き込み)のためにファイルを開きます。</td></tr>
      <tr><td>
          <span class="stri">&quot;wt+&quot;</span>
        </td> <td> </td><td>更新して長さを0にするためにファイルを開くか作成してください。</td></tr>
      <tr><td>
          <span class="stri">「at+」</span>
        </td> <td> </td><td>追加および読み込みのためにファイルを開くか作成してください。</td></tr></table>
</dl></dd></dl><p>Seed7はモードを定義することに注意してください。<tt><span class="stri">「r」</span></tt><tt><span class="stri">「w」</span></tt><tt><span class="stri">「a」</span></tt><tt><span class="stri">「r+」</span></tt><tt><span class="stri">「w+」</span></tt>および<tt><span class="stri">「a+」</span></tt>バイナリモードとして もし<tt><span class="func">開いたさま</span></tt>が呼び出されたときに、上記のテーブルにないモードで<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>を上げます。 変換するためのメモリが不足している場合<tt>&#39;path&#39;</tt>例外をシステム・パス・タイプに<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt>を上げます。 もし<tt><span class="func">開いたさま</span></tt>その他の理由で失敗した場合は<tt><span class="var">STD_NULL</span></tt>例:許可されていない<tt><span class="func">開いたさま</span></tt>ディレクトリ。 の試みは<tt><span class="func">開いたさま</span></tt>ディレクトリが戻る<tt><span class="var">STD_NULL</span></tt>ファイルを開いた後にファイル変数を確認することをお勧めします。</p><pre class="indent"><span class="keywd">if</span>my_out&lt;><span class="var">STD_NULL</span><span class="keywd">その時</span></pre><p>その出力の後<tt>&#39;my_out&#39;</tt>で可能である</p><pre class="indent">
writeln(my_out
);
<span class="stri">&quot;こんにちは&quot;</span></pre><p>ファイルの処理が終了したら、ファイルを閉じる必要があります</p><pre class="indent">close(my_out);
</pre><p>ファイルを閉じた後でそのファイルに書き込むと例外が発生する<tt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></tt>次のプログラムは<tt><span class="stri">&quot;こんにちは&quot;</span></tt>ファイルに<tt><span class="stri">&quot;my_file&quot;</span></tt>:</p><pre class="indent">
$
;






;


my_out:=
);


writeln(my_out
);
close(my_out);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:main</a>is func<span class="keywd">地域の</span>var<span class="keywd"></span>ファイルする<span class="keywd">:my_out</span>は<a class="type" href="#types_file"></a>STD_NULL<span class="keywd">begin</span>開いたさま<span class="var">(</span>&quot;my_file&quot;<span class="keywd"></span>「w」<span class="func">if</span>my_out&lt;><span class="stri">STD_NULL</span><span class="stri">その時</span>&quot;こんにちは&quot;<span class="keywd">if終了</span>関数終了<span class="var"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span></pre><p>に注意してください。<tt><span class="func">開いたさま</span></tt>はBYTE型ファイルを開く。 次のように256以上の序数を持つ文字を記述します。</p><pre class="indent">
writeln(my_out
);
<span class="stri">&quot;不正な文字:\256;&quot;</span></pre><p>例外の結果<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>Unicode文字を書き込むには、他のファイルタイプを使用する必要があります。 図書館<span class="stri">&quot;<span class="lib">utf8.s7i</span>&quot;</span>および<span class="stri">&quot;<span class="lib">utf16.s7i</span>&quot;</span>では、UTF-8およびUTF-16ファイルにアクセスできます。 機能<tt><span class="func">openUtf8</span></tt>と同じように使用できます。<tt><span class="func">開いたさま</span></tt>:</p><pre class="indent">
my_out:=
);
<span class="func">openUtf8</span>(<span class="stri">&quot;utf8_file&quot;</span><span class="stri">「w」</span></pre><p>UTF-8ファイルは、すべてのユニコード文字を受け入れます。 そうすれば</p><pre class="indent">
writeln(my_out
);
<span class="stri">&quot;Unicode char:\256;&quot;</span></pre><p>問題なく動作します。 UTF-8ファイルはバイト順序に依存しません。 したがって、バイトオーダーマーク(BOM)は必要ありません。 BOMが必要な場合は、ユーザプログラムで次のように記述できます。</p><pre class="indent">
my_out:=
);
write(
);
<span class="func">openUtf8</span>(<span class="stri">&quot;utf8_file&quot;</span><span class="stri">「w」</span>&quot;\16#feff;&quot;<span class="stri"></span></pre><p>次の例では、UTF-8ファイルの先頭に必須BOMが要求されます。</p><pre class="indent">
my_out:=
);


writeln(
&quot;);




;
<span class="func">openUtf8</span>(<span class="stri">&quot;utf8_file&quot;</span><span class="stri">「r」</span>if<span class="keywd"></span>getc<span class="func">(my_file)&lt;></span>&#39;\16#feff;&#39;<span class="stri"></span>その時<span class="keywd">BOMがありません</span>else<span class="stri">if終了</span><span class="keywd"></span><span class="keywd"></span></pre><p>UTF-8ファイルの先頭にあるオプションのBOMを受け入れるには、次のようにします。</p><pre class="indent">
my_out:=
);





(my_file, 1);

;

<span class="func">openUtf8</span>(<span class="stri">&quot;utf8_file&quot;</span><span class="stri">「r」</span>if<span class="keywd"></span>getc<span class="func">(my_file)&lt;></span>&#39;\16#feff;&#39;<span class="stri"></span>その時<span class="keywd">#This is a file without BOM(the first character is been read later).</span>シークする<span class="comment">if終了</span><span class="func"></span><span class="keywd"></span></pre><p>UTF-16には、UTF-16LEとUTF-16BEという2つのフレーバーがあります。 両方のフレーバーをサポートするために<span class="stri">&quot;<span class="lib">utf16.s7i</span>&quot;</span>libraryには、いくつかの関数が定義され</p><p>機能<tt><span class="func">openUtf16</span></tt>はUTF-16LEまたはUTF-16BEエンコーディングを使用するUnicodeファイルを開きます。 機能<tt><span class="func">openUtf16</span></tt>はBOMをチェックし、それに応じてUTF-16LEまたはUTF-16BEファイルを開きます。</p><p>機能<tt><span class="func">openUtf16le</span></tt>および<tt><span class="func">openUtf16be</span></tt>それぞれUTF-16LEおよびUTF-16BEエンコーディングを使用してUnicodeファイルをオープンする。 ファイルがいずれかのモードで開かれている場合<tt><span class="stri">「w」</span></tt><tt><span class="stri">「w+」</span></tt><tt><span class="stri">&quot;wt&quot;</span></tt>または<tt><span class="stri">&quot;wt+&quot;</span></tt>適切な部品表が作成されます。 他のモードでファイルを開いた場合、そのアプリケーションプログラムがオプションのBOMマーカーの処理を担当します。 こうして<tt><span class="func">openUtf16le</span></tt>および<tt><span class="func">openUtf16be</span></tt>BOM無しで既存ファイルを開くことができます。</p><p>外部BYTEファイルは実装タイプを使用します。<tt><span class="type">外部ファイル</span></tt>型式<tt><span class="type">外部ファイル</span></tt>は次のように定義されます。</p><pre class="indent">

CLIB_NULL_FILE;

;

;
<span class="keywd">const</span><span class="type">タイプ</span>:external_file<span class="keywd">is sub</span><span class="type">空ファイル</span><span class="keywd">構造体</span>var<span class="keywd"></span>clib_file<span class="type">:ext_file</span>は<span class="keywd">var</span><span class="keywd">文字列</span>:name<span class="type">は</span><span class="keywd">&quot;&quot;</span>構造体を終了する<span class="stri"></span><span class="keywd"></span></pre><p>これは、タイプのすべてのデータ項目が<tt><span class="type">外部ファイル</span></tt>からの要素を持つ<tt><span class="type">空ファイル</span></tt>およびさらに要素<tt>&#39;ext_file&#39;</tt>および<tt>&#39;name&#39;</tt>型式<tt><span class="type">clib_file</span></tt>オペレーティング・システム・ファイルを直接指し示す。 オブジェクトの種類<tt><span class="type">clib_file</span></tt>タイプのオブジェクトは値としてオペレーティング・システム・ファイルのみを持つことができます。<tt><a class="type" href="#types_file">ファイルする</a></tt>は他のファイルを値として持つこともできる。 その型の実装を可能にするため<tt><span class="type">外部ファイル</span></tt>数種類のタイプの演算<tt><span class="type">clib_file</span></tt>が定義されている。 しかし外では<tt><span class="type">外部ファイル</span></tt>タイプ<tt><span class="type">clib_file</span></tt>その操作は使用しないでください。</p><p>次の3つの定義済み外部ファイルがあります。<tt><span class="var">STD_IN</span></tt><tt><span class="var">標準出力</span></tt>および<tt><span class="var">標準偏差</span></tt>これには次のような宣言があります。</p><pre class="indent">:primitive_file





value;


standardFile.ext_file:=primitive_file;
standardFile.name:=ファイル名;

;


);

);

);
<span class="keywd">const</span><span class="type">func external_file</span>:INIT_STD_FILE(<span class="keywd">参照</span><span class="type">clib_file</span>で<span class="keywd"></span>文字列<span class="type">:ファイル名)</span>is func<span class="keywd">結果</span>var<span class="keywd"></span>外部ファイル<span class="keywd">:standardFile</span>は<span class="type"></span>外部ファイル<span class="keywd">begin</span>関数終了<span class="type">var</span><span class="keywd">外部ファイル</span>:STD_IN<span class="keywd">は</span>INIT_STD_FILE(CLIB_INPUT<span class="keywd">&quot;STD_IN&quot;</span>var<span class="type"></span>外部ファイル<span class="keywd">:STD_OUT</span>は<span class="stri">INIT_STD_FILE(CLIB_OUTPUT</span>&quot;STD_OUT&quot;<span class="keywd">var</span><span class="type">外部ファイル</span>:STD_ERR<span class="keywd">は</span>INIT_STD_FILE(CLIB_ERROR<span class="stri">&quot;STD_ERR&quot;</span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="stri"></span></pre><p>これらを使用して直接I/Oを行うこともできますが、次のようにユーザ定義ファイル変数の初期化にのみ使用する方が賢明です。</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:err<span class="keywd">は</span><span class="var">標準偏差</span></pre><p>プログラムの残りの部分では、このような変数への参照を使用できます。</p><pre class="indent">
writeln(err
);
<span class="stri">&quot;エラーが発生しました&quot;</span></pre><p>この場合、ファイルのリダイレクト<tt>&#39;err&#39;</tt>とても簡単にできるのです 外部ファイルにアクセスするもう1つの方法は、関数を使用することです。<tt><span class="func">開いたさま</span></tt>で使用されるモードは<tt><span class="func">開いたさま</span></tt>で使用されるものとは異なる<tt>&#39;fopen&#39;</tt>関数で呼び出される。 次の表は、Seed7とCのファイルモードを比較したものです。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Seed7<tt>「開いている」</tt>モード</td>   <td>C<tt>&#39;fopen&#39;</tt>モード</td></tr>
    <tr><td>
          <span class="stri">「r」</span>
        </td>                 <td>
          <span class="stri">「rb」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「w」</span>
        </td>                 <td>
          <span class="stri">&quot;wb&quot;</span>
        </td></tr>
    <tr><td>
          <span class="stri">「a」</span>
        </td>                 <td>
          <span class="stri">「ab」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「r+」</span>
        </td>                <td>
          <span class="stri">「rb+」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「w+」</span>
        </td>                <td>
          <span class="stri">&quot;wb+&quot;</span>
        </td></tr>
    <tr><td>
          <span class="stri">「a+」</span>
        </td>                <td>
          <span class="stri">「ab+」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「rt」</span>
        </td>                <td>
          <span class="stri">「r」</span>
        </td></tr>
    <tr><td>
          <span class="stri">&quot;wt&quot;</span>
        </td>                <td>
          <span class="stri">「w」</span>
        </td></tr>
    <tr><td>
          <span class="stri">&quot;at&quot;</span>
        </td>                <td>
          <span class="stri">「a」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「rt+」</span>
        </td>               <td>
          <span class="stri">「r+」</span>
        </td></tr>
    <tr><td>
          <span class="stri">&quot;wt+&quot;</span>
        </td>               <td>
          <span class="stri">「w+」</span>
        </td></tr>
    <tr><td>
          <span class="stri">「at+」</span>
        </td>               <td>
          <span class="stri">「a+」</span>
        </td></tr>
</table></dd></dl><p>バイナリモードとテキストモードの違いは次のとおりです。</p><ul>
    <li>バイナリモードは全てのオペレーティングシステムで実装に依存しない動作を提供します。 バイナリモードでは、行末文字(<tt><span class="stri">&#39;\n&#39;</span></tt>)が行われます。 これには<tt><span class="type">外部ファイル</span></tt>バイナリモードで書かれたファイルは全てのオペレーティングシステムで同一です。<tt><span class="stri">&quot;\n&quot;</span></tt>および<tt><span class="stri">&quot;\r\n&quot;</span></tt>)は、すべての<tt><span class="type">外部ファイル</span></tt>:関数<tt><span class="func">getwd</span></tt><tt><span class="func">getln</span></tt><tt><span class="func">読む</span></tt>および<tt><span class="func">readln</span></tt>,の<tt><span class="type">外部ファイル</span></tt>復帰をスキップする(<tt><span class="stri">&#39;\r&#39;</span></tt>)改行の直前の場合(<tt><span class="stri">&#39;\n&#39;</span></tt>)。 残りの<tt><span class="type">外部ファイル</span></tt>のような関数<tt><span class="func">getc</span></tt>および<tt><span class="func">取得</span></tt>行末を変更しないようにしてください。</li>
    <li>の動作は<tt><span class="type">外部ファイル</span></tt>テキスト・モードでのは実装に依存します。 Unix/Linux/Bsdではテキストモードとバイナリモードはまったく同じです。 他のオペレーティングシステムでは、テキスト・モードで行末変換を行う方が好まれます。 ファイルを読み取るときに<tt><span class="stri">&quot;\r\n&quot;</span></tt>に変換されます。<tt><span class="stri">&#39;\n&#39;</span></tt>ファイルに書き込むときに<tt><span class="stri">&#39;\n&#39;</span></tt>に変換されます。<tt><span class="stri">&quot;\r\n&quot;</span></tt>でファイルを自動的に作成するためにテキストモードを使用することはできません。<tt><span class="stri">&quot;\r\n&quot;</span></tt>Unix/Linux/Bsdでの行末</li>
</ul><p>図書館<span class="stri">&quot;<span class="lib">utf8.s7i</span>&quot;</span>実装タイプを定義する。<tt><span class="type">utf 8ファイル</span></tt>as</p><pre class="indent">

;
<span class="keywd">const</span><span class="type">タイプ</span>:utf 8ファイル<span class="keywd">is sub</span><span class="type">外部ファイル</span><span class="keywd">構造体</span>構造体を終了する<span class="keywd"></span></pre><p></p>
          <a name="file_Keyboard_file">
        <h3>8.7キーボードファイル</h3>
          </a>
        <p>先に述べたように<tt><span class="var">STD_IN</span></tt>一行ごとにバッファされエコーされるキーボードへのインターフェイスを提供する<tt><span class="var">標準出力</span></tt>これは、入力したすべてを表示できることを意味します。 さらに、次のように入力を修正できます。<span class="box">バックスペース</span>を押すまで<span class="box">リターン</span>しかし、時にはバッファされずエコーされない入力が必要になります。 これはライブラリに用意されています。<span class="stri">&quot;<span class="lib">keybd.s7i</span>&quot;</span>:タイプを定義します。<tt><span class="type">キーボードファイル</span></tt>とファイル<tt><span class="var">キーボード</span></tt>キーボードでタイプした文字はキュー(先入れ先出し)に置かれ、直接読み出すことができます。<tt><span class="var">キーボード</span></tt>訂正する可能性なしで。 さらに<tt><span class="var">キーボード</span></tt>は文字をエコーしない。<tt><span class="var">キーボード</span></tt>は、ファンクションキーやカーソルキー用の通常のUnicode文字あるいは特別なコード(Unicode文字であるかもしれないし、そうでないかもしれない)を提供します。 Unicode文字と特殊コードはどちらも<tt><a class="type" href="#types_char">char</a></tt>値。 図書館<span class="stri">&quot;<span class="lib">keybd.s7i</span>&quot;</span>定義<tt><a class="type" href="#types_char">char</a></tt>さまざまなキーの定数:</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>キー文字定数</td>     <td>Description:説明</td></tr>
    <tr><td><tt><a name="file_KEY_CTL_A_TO_Z">KEY_CTL_A</a></tt>へ<tt>KEY_CTL_Z</tt></td>     <td>Ctrl-aからCtrl-zまでのコントロール・キー</td></tr>
    <tr><td><tt>KEY_ALT_A</tt>へ<tt>KEY_ALT_Z</tt></td>     <td>Alt-aからAlt-zまでの代替キー</td></tr>
    <tr><td><tt>KEY_CTL_0</tt>へ<tt>KEY_CTL_9</tt></td>     <td>Ctrl-0からCtrl-9までのコントロール・キー</td></tr>
    <tr><td><tt>KEY_ALT_0</tt>へ<tt>KEY_ALT_9</tt></td>     <td>Alt-0からAlt-9までのAltキー</td></tr>
    <tr><td><tt>KEY_F1</tt>へ<tt>KEY_F12</tt></td>          <td>ファンクションキーF1～F12</td></tr>
    <tr><td><tt>KEY_SFT_F1</tt>へ<tt>KEY_SFT_F12</tt></td>  <td>シフトキーF1～F12</td></tr>
    <tr><td><tt>KEY_CTL_F1</tt>へ<tt>KEY_CTL_F12</tt></td>  <td>制御機能キーF1からF12</td></tr>
    <tr><td><tt>KEY_ALT_F1</tt>へ<tt>KEY_ALT_F12</tt></td>  <td>ファンクションキー(F1～F12)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_LEFT">KEY_LEFT</a>
          </tt>
        </td>                   <td>カーソル左</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RIGHT">KEY_RIGHT</a>
          </tt>
        </td>                  <td>カーソル右</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_UP">KEY_UP</a>
          </tt>
        </td>                     <td>カーソル上</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_DOWN">KEY_DOWN</a>
          </tt>
        </td>                   <td>カーソル下</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_HOME">KEY_HOME</a>
          </tt>
        </td>                   <td>homeキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_END">KEY_END</a>
          </tt>
        </td>                    <td>Endキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_PGUP">KEY_PGUP</a>
          </tt>
        </td>                   <td>1ページ上へ</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_PGDN">KEY_PGDN</a>
          </tt>
        </td>                   <td>1ページ下へ</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_INS">KEY_INS</a>
          </tt>
        </td>                    <td>insertキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_DEL">KEY_DEL</a>
          </tt>
        </td>                    <td>Deleteキー</td></tr>
    <tr><td>
          <tt>KEY_PAD_CENTER</tt>
        </td>             <td>テンキーセンターキー</td></tr>
    <tr><td>
          <tt>KEY_SFT_LEFT</tt>
        </td>               <td>カーソルを左に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_RIGHT</tt>
        </td>              <td>カーソルを右に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_UP</tt>
        </td>                 <td>カーソルを上に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_DOWN</tt>
        </td>               <td>カーソルを下に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_HOME</tt>
        </td>               <td>シフトhomeキー</td></tr>
    <tr><td>
          <tt>KEY_SFT_END</tt>
        </td>                <td>Shifted end key</td></tr>
    <tr><td>
          <tt>KEY_SFT_PGUP</tt>
        </td>               <td>ページを上に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_PGDN</tt>
        </td>               <td>ページを下に移動</td></tr>
    <tr><td>
          <tt>KEY_SFT_INS</tt>
        </td>                <td>シフトinsertキー</td></tr>
    <tr><td>
          <tt>KEY_SFT_DEL</tt>
        </td>                <td>Shifted delete key</td></tr>
    <tr><td>
          <tt>KEY_SFT_PAD_CENTER</tt>
        </td>         <td>Shifted numeric keypad center key</td></tr>
    <tr><td>
          <tt>KEY_CTL_LEFT</tt>
        </td>               <td>コントロールカーソル左</td></tr>
    <tr><td>
          <tt>KEY_CTL_RIGHT</tt>
        </td>              <td>コントロールカーソル右</td></tr>
    <tr><td>
          <tt>KEY_CTL_UP</tt>
        </td>                 <td>コントロールカーソル上</td></tr>
    <tr><td>
          <tt>KEY_CTL_DOWN</tt>
        </td>               <td>コントロールカーソル下</td></tr>
    <tr><td>
          <tt>KEY_CTL_HOME</tt>
        </td>               <td>制御homeキー</td></tr>
    <tr><td>
          <tt>KEY_CTL_END</tt>
        </td>                <td>制御終了キー</td></tr>
    <tr><td>
          <tt>KEY_CTL_PGUP</tt>
        </td>               <td>ページアップの制御</td></tr>
    <tr><td>
          <tt>KEY_CTL_PGDN</tt>
        </td>               <td>コントロールページダウン</td></tr>
    <tr><td>
          <tt>KEY_CTL_INS</tt>
        </td>                <td>制御insertキー</td></tr>
    <tr><td>
          <tt>KEY_CTL_DEL</tt>
        </td>                <td>Control削除キー</td></tr>
    <tr><td>
          <tt>KEY_CTL_PAD_CENTER</tt>
        </td>         <td>テンキーセンターキーを制御する</td></tr>
    <tr><td>
          <tt>KEY_ALT_LEFT</tt>
        </td>               <td>Altカーソル左</td></tr>
    <tr><td>
          <tt>KEY_ALT_RIGHT</tt>
        </td>              <td>Altカーソル右</td></tr>
    <tr><td>
          <tt>KEY_ALT_UP</tt>
        </td>                 <td>Altカーソルを上に</td></tr>
    <tr><td>
          <tt>KEY_ALT_DOWN</tt>
        </td>               <td>Altカーソル下</td></tr>
    <tr><td>
          <tt>KEY_ALT_HOME</tt>
        </td>               <td>変換homeキー</td></tr>
    <tr><td>
          <tt>KEY_ALT_END</tt>
        </td>                <td>Alt終了キー</td></tr>
    <tr><td>
          <tt>KEY_ALT_PGUP</tt>
        </td>               <td>[Alt]を1ページ上へ</td></tr>
    <tr><td>
          <tt>KEY_ALT_PGDN</tt>
        </td>               <td>[Alt]キーを押しながら下へ</td></tr>
    <tr><td>
          <tt>KEY_ALT_INS</tt>
        </td>                <td>変換insertキー</td></tr>
    <tr><td>
          <tt>キー代替削除</tt>
        </td>                <td>Alt削除キー</td></tr>
    <tr><td>
          <tt>KEY_ALT_PAD_CENTER</tt>
        </td>         <td>Altテンキーセンターキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_NL">KEY_NL</a>
          </tt>
        </td>                     <td>改行/入力/リターンキー(KEY_CTL_Jと同じ)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_BS">KEY_BS</a>
          </tt>
        </td>                     <td>バックスペース(KEY_CTL_Hと同じ)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_TAB">KEY_TAB</a>
          </tt>
        </td>                    <td>水平タブ(KEY_CTL_Hと同じ)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_CR">KEY_CR</a>
          </tt>
        </td>                     <td>復帰(KEY_CTL_Mと同じ)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_ESC">KEY_ESC</a>
          </tt>
        </td>                    <td>エスケープ・キー</td></tr>
    <tr><td>
          <tt>KEY_MENU</tt>
        </td>                   <td>メニューキー</td></tr>
    <tr><td>
          <tt>KEY_PRINT</tt>
        </td>                  <td>印刷キー</td></tr>
    <tr><td>
          <tt>KEY_PAUSE</tt>
        </td>                  <td>Pauseキー</td></tr>
    <tr><td>
          <tt>KEY_SFT_NL</tt>
        </td>                 <td>Shift改行/Enter/Returnキー</td></tr>
    <tr><td>
          <tt>KEY_SFT_BS</tt>
        </td>                 <td>Shiftバックスペース</td></tr>
    <tr><td>
          <tt>KEY_SFT_TAB</tt>
        </td>                <td>Shiftタブ(<tt>KEY_BACKTAB</tt>)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_BACKTAB">KEY_BACKTAB</a>
          </tt>
        </td>                <td>Shiftタブ(<tt>KEY_SFT_TAB</tt>)</td></tr>
    <tr><td>
          <tt>KEY_SFT_ESC</tt>
        </td>                <td>Shiftエスケープ</td></tr>
    <tr><td>
          <tt>KEY_SFT_MENU</tt>
        </td>               <td>Shiftメニュー</td></tr>
    <tr><td>
          <tt>KEY_SFT_PRINT</tt>
        </td>              <td>Shift印刷</td></tr>
    <tr><td>
          <tt>KEY_SFT_PAUSE</tt>
        </td>              <td>Shift一時停止</td></tr>
    <tr><td>
          <tt>KEY_CTL_NL</tt>
        </td>                 <td>制御改行/入力/リターンキー</td></tr>
    <tr><td>
          <tt>KEY_CTL_BS</tt>
        </td>                 <td>Ctrl後退</td></tr>
    <tr><td>
          <tt>KEY_CTL_TAB</tt>
        </td>                <td>[制御]タブ</td></tr>
    <tr><td>
          <tt>KEY_CTL_ESC</tt>
        </td>                <td>制御エスケープ</td></tr>
    <tr><td>
          <tt>KEY_CTL_MENU</tt>
        </td>               <td>コントロールメニュー</td></tr>
    <tr><td>
          <tt>KEY_CTL_PRINT</tt>
        </td>              <td>印刷の制御</td></tr>
    <tr><td>
          <tt>KEY_CTL_PAUSE</tt>
        </td>              <td>制御一時停止</td></tr>
    <tr><td>
          <tt>KEY_ALT_NL</tt>
        </td>                 <td>Alt改行/Enter/Returnキー</td></tr>
    <tr><td>
          <tt>KEY_ALT_BS</tt>
        </td>                 <td>Altバックスペース</td></tr>
    <tr><td>
          <tt>キー代替タブ</tt>
        </td>                <td>Altタブ</td></tr>
    <tr><td>
          <tt>KEY_ALT_ESC</tt>
        </td>                <td>Altエスケープ</td></tr>
    <tr><td>
          <tt>KEY_ALT_MENU</tt>
        </td>               <td>Altメニュー</td></tr>
    <tr><td>
          <tt>キー代替印刷</tt>
        </td>              <td>代替印刷</td></tr>
    <tr><td>
          <tt>KEY_ALT_PAUSE</tt>
        </td>              <td>Alt一時停止</td></tr>
    <tr><td>
          <tt>KEY_SCRLUP</tt>
        </td>                 <td>スクロールアップキー</td></tr>
    <tr><td>
          <tt>KEY_SCRLDN</tt>
        </td>                 <td>スクロールダウンキー</td></tr>
    <tr><td>
          <tt>KEY_INSLN</tt>
        </td>                  <td>行挿入キー</td></tr>
    <tr><td>
          <tt>キー_DELLN</tt>
        </td>                  <td>行キーの削除</td></tr>
    <tr><td>
          <tt>KEY_ERASE</tt>
        </td>                  <td>Eraseキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_NULCHAR">KEY_NULCHAR</a>
          </tt>
        </td>                <td>空文字キー</td></tr>
    <tr><td>
          <tt>KEY_NULLCMD</tt>
        </td>                <td>ウィンドウマネージャのヌルコマンド</td></tr>
    <tr><td>
          <tt>KEY_REDRAW</tt>
        </td>                 <td>ウィンドウマネージャの再描画コマンド</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE1">KEY_MOUSE1</a>
          </tt>
        </td>                 <td>マウスボタン1(左から数えて)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE2">KEY_MOUSE2</a>
          </tt>
        </td>                 <td>マウスボタン2(左から数えて)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE3">KEY_MOUSE3</a>
          </tt>
        </td>                 <td>マウスボタン3(左から数えて)</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE4">KEY_MOUSE4</a>
          </tt>
        </td>                 <td>マウスホイールでスクロールアップ</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE5">KEY_MOUSE5</a>
          </tt>
        </td>                 <td>マウスホイールスクロールダウン</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE_FWD">KEY_MOUSE_FWD</a>
          </tt>
        </td>              <td>マウス前進ボタン</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_MOUSE_BACK">KEY_MOUSE_BACK</a>
          </tt>
        </td>             <td>マウスバックボタン</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE1</tt>
        </td>             <td>Shift mouse button 1(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE2</tt>
        </td>             <td>Shift mouse button 2(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE3</tt>
        </td>             <td>Shift mouse button 3(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE4</tt>
        </td>             <td>マウスホイールを上にスクロール</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE5</tt>
        </td>             <td>Shiftマウスホイールスクロールダウン</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE_FWD</tt>
        </td>          <td>Shift mouse forward button</td></tr>
    <tr><td>
          <tt>KEY_SFT_MOUSE_BACK</tt>
        </td>         <td>Shift mouse back button</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE1</tt>
        </td>             <td>コントロールマウスボタン1(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE2</tt>
        </td>             <td>コントロールマウスボタン2(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE3</tt>
        </td>             <td>コントロールマウスボタン3(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE4</tt>
        </td>             <td>マウスホイールスクロールアップを制御する</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE5</tt>
        </td>             <td>マウスホイールスクロールダウンを制御する</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE_FWD</tt>
        </td>          <td>マウスフォワードボタンを制御します</td></tr>
    <tr><td>
          <tt>KEY_CTL_MOUSE_BACK</tt>
        </td>         <td>コントロールマウスの戻るボタン</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE1</tt>
        </td>             <td>Altマウスボタン1(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE2</tt>
        </td>             <td>Altマウスボタン2(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE3</tt>
        </td>             <td>Altマウスボタン3(左から数えて)</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE4</tt>
        </td>             <td>Altマウスホイールスクロールアップ</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE5</tt>
        </td>             <td>Altマウスホイールスクロールダウン</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE_FWD</tt>
        </td>          <td>Altマウス前進ボタン</td></tr>
    <tr><td>
          <tt>KEY_ALT_MOUSE_BACK</tt>
        </td>         <td>Altマウスの戻るボタン</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_CLOSE">KEY_CLOSE</a>
          </tt>
        </td>                  <td>ウィンドウの閉じるボタンが押されました</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RESIZE">KEY_RESIZE</a>
          </tt>
        </td>                 <td>ウィンドウのサイズが変更されました</td></tr>
    <tr><td>
          <tt>KEY_UNDEF</tt>
        </td>                  <td>未定義のキー</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_NONE">KEY_NONE</a>
          </tt>
        </td>                   <td>キーが押されていません(から戻りました<tt><span class="func">getc</span>(<span class="var">キーボード</span><span class="var">NO_WAIT</span>)</tt>)</td></tr>
</table></dd></dl><p>次の例では<tt><a class="type" href="#types_char">char</a></tt>一定した<tt><a class="var" href="#file_KEY_UP">KEY_UP</a></tt>:</p><pre class="indent">
$
;

;





writeln(
);


writeln(
);

;
writeln(
);

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>const</span><span class="keywd">proc</span>:main<a class="type" href="#types_proc">is func</a>begin<span class="keywd">&quot;カーソルを上に押してください&quot;</span>一方で<span class="keywd"></span>getc<span class="stri">(</span>キーボード<span class="keywd">)&lt;></span>KEY_UP<span class="func"></span>do<span class="var">「これはカーソルアップではありませんでした」</span>whileを終了する<tt><a class="var" href="#file_KEY_UP">&quot;カーソルアップが押されました&quot;</a></tt>関数終了<span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre><p>プログラムでは<tt><a class="type" href="#types_char">char</a></tt>定義された定数<span class="stri">&quot;<span class="lib">keybd.s7i</span>&quot;</span>ファンクションキーとカーソルキーに対応するためです。特殊キーコードはSeed7の将来のバージョンで変更される可能性があります。</p><p>に注意してください。<tt><span class="func">getc</span>(<span class="var">キーボード</span>)</tt>は同期で動作します。 これは、キーが押されるまで待機(ブロック)することを意味します。 ブロッキングは、次の関数で回避できます。</p><ul>
    <li><tt><span class="func">inputReady</span></tt>が返り<tt><span class="var">TRUE</span></tt>文字がブロックせずに読むことができ<tt><span class="var">FALSE</span></tt>そうでなければ。</li>
    <li><tt><span class="func">getc</span>(<span class="var">キーボード</span><span class="var">NO_WAIT</span>)</tt>は、次の文字をキーボードから配信します。<tt><a class="var" href="#file_KEY_NONE">KEY_NONE</a></tt>キーが押されていない場合に表示されます。</li>
</ul><p>に注意してください。<tt><span class="func">inputReady</span></tt>は実際には文字を読み込みません。読み込むには、別の関数(たとえば<tt><span class="func">getc</span></tt>)後<tt><span class="func">inputReady</span></tt>戻り値<tt><span class="var">TRUE</span></tt>以下のプログラムは<tt>#</tt>文字。 何かキーを押すと改行されます。 プレス<span class="box">リターン</span>(または<span class="box">Enter</span>)はプログラムを終了させます。</p><pre class="indent">
$
;

;

;









write(
);

);

(30000. MICRO_SECONDS);

;
writeln;

getc(KEYBOARD)=KEY_NL;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>duration.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">begin</a>繰り返す<span class="keywd">一方で</span>ない<span class="keywd">inputReady</span>(<span class="keywd">キーボード</span>)<span class="keywd">do</span>「#」<span class="func">フラッシュ</span>(<span class="var">OUT</span>待つ<span class="keywd">whileを終了する</span>まで<span class="stri">関数終了</span><span class="func"></span><span class="var"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>両方の関数(<tt><span class="func">getc</span>(<span class="var">キーボード</span><span class="var">NO_WAIT</span>)</tt>および<tt><span class="func">inputReady</span></tt>)は、一部の処理が行われている間にユーザ入力が許可される場合に便利です。 以下のプログラムは<tt><span class="func">getc</span>(<span class="var">キーボード</span><span class="var">NO_WAIT</span>)</tt>キーを押すまでの時間を表示します。</p><pre class="indent">
$
;

;

;





writeln;


write(time(NOW)&lt;&amp;
);

);

;
writeln;
writeln;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">時間.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">begin</a>一方で<span class="keywd"></span>getc<span class="keywd">(</span>キーボード<span class="keywd"></span>NO_WAIT<span class="func">)=</span>KEY_NONE<span class="var"></span>do<span class="var">&quot;\r&quot;</span>フラッシュ<a class="var" href="#file_KEY_NONE">(</a>OUT<span class="keywd">whileを終了する</span>関数終了<span class="stri"></span><span class="func"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>Seed7プログラムは、次の2つのモードで実行できます。</p><ul>
    <li>コンソールモード。プログラムはコンソール/端末ウィンドウで実行されます(デフォルト)。</li>
    <li>グラフィックモード。プログラムが独自のグラフィックウィンドウを持ちます。</li>
</ul><p>これらの2つのモードは、次の2つの基本的なキーボードファイルでサポートされています。</p><ul>
    <li><tt><span class="var">コンソール_キーボード</span></tt>これはterminfoやコンソールドライバを使います。</li>
    <li><tt><span class="var">グラフ_キーボード</span></tt>これはX11またはGDIドライバを使用する。</li>
</ul><p>ファイル<tt><span class="var">キーボード</span></tt>は、2つの基本的なキーボードファイルの1つを参照する変数です。 型の宣言<tt><span class="type">キーボードファイル</span></tt>とファイル<tt><span class="var">キーボード</span></tt>で<span class="stri">&quot;<span class="lib">keybd.s7i</span>&quot;</span>は:</p><pre class="indent">;


CONSOLE_KEYBOARD;
<span class="keywd">const</span><span class="type">タイプ</span>:keyboard_file<span class="keywd">は</span><span class="type">サブタイプファイル</span>var<span class="keywd"></span>キーボードファイル<span class="type">:KEYBOARD</span>は<span class="keywd"></span></pre><p>グラフィックプログラムは<tt><span class="var">グラフ_キーボード</span></tt>ドライバー:</p><pre class="indent">;
<span class="var">キーボード</span>:=<span class="var">グラフ_キーボード</span></pre><p>A<tt><span class="var">グラフ_キーボード</span></tt>さらに、次の機能も提供します。</p><ul>
    <li><tt><span class="func">buttonPressed</span></tt>これは、特定のボタンが現在押されているかどうかを判別します。</li>
    <li><tt><span class="func">clickedXPos</span></tt>これは、ボタンが押されたときのマウスカーソルのX位置を返します。</li>
    <li><tt><span class="func">clickedYPos</span></tt>これは、ボタンが押されたときのマウスカーソルのY位置を返します。</li>
</ul><p>次のような修飾キー<span class="box">交替する</span><span class="box">制御</span><span class="box">素晴らしい</span>および<span class="box">alt</span>キー/ボタンのダウン/アップイベントを送信しません。 機能<tt><span class="func">buttonPressed</span></tt>を使用すると、修飾語が押されたかどうかを判断できます。 以下のプログラムは、左右の状態に応じて青と赤の四角形を表示します。<span class="box">交替する</span>キー。 プログラムは、任意の非修飾キーを押すことで終了します。</p><pre class="indent">
$
;

;

;

;





スクリーン(640、480);

;


rect(85, 190, 100, 100
)?light_blue:light_red);
rect(270, 190, 100, 100
)?light_blue:light_red);
rect(455, 190, 100, 100
)?light_blue:light_red);

;

(30000. MICRO_SECONDS);

);

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>draw.s7i<span class="lib">&quot;<span class="lib">含む</span></span>&quot;<span class="keywd">duration.s7i</span>&quot;<span class="lib">const<span class="lib"></span>proc</span>:main<span class="keywd">is func</span>begin<a class="type" href="#types_proc">キーボード</a>:=<span class="keywd">グラフ_キーボード</span>繰り返す<span class="keywd">buttonPressed</span>(<span class="var">キーボード</span><span class="var">KEY_LEFT_SHIFT</span>buttonPressed<span class="keywd">(</span>キーボード<span class="func"></span>KEY_SHIFT<span class="var">buttonPressed</span>(<a class="var" href="#file_KEY_LEFT_SHIFT">キーボード</a><span class="func">KEY_RIGHT_SHIFT</span>flushGraphic<span class="var">待つ</span>まで<a class="var" href="#file_KEY_SHIFT"></a>inputReady<span class="func">(</span>キーボード<span class="var">関数終了</span><a class="var" href="#file_KEY_RIGHT_SHIFT"></a><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="func"></span><span class="var"></span><span class="keywd"></span></pre><p>に注意してください。<tt><span class="func">buttonPressed</span></tt>キー/ボタン・イベントを処理しません。 これを行う必要があります。<tt><span class="func">inputReady</span></tt>または<tt><span class="func">getc</span></tt></p><p>図書館<span class="stri">&quot;<span class="lib">keybd.s7i</span>&quot;</span>にモディファイア・キーの定義を示します。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>キー文字定数</td>     <td>Description:説明</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SHIFT">KEY_SHIFT</a>
          </tt>
        </td>                  <td>左または右Shiftキーが押された。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_LEFT_SHIFT">KEY_LEFT_SHIFT</a>
          </tt>
        </td>             <td>左シフトが押された。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RIGHT_SHIFT">KEY_RIGHT_SHIFT</a>
          </tt>
        </td>            <td>右Shiftキーが押されました</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_CONTROL">KEY_CONTROL</a>
          </tt>
        </td>                <td>左または右コントロールを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_LEFT_CONTROL">KEY_LEFT_CONTROL</a>
          </tt>
        </td>           <td>左コントロールを押す</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RIGHT_CONTROL">KEY_RIGHT_CONTROL</a>
          </tt>
        </td>          <td>右コントロールを押す</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_ALT">KEY_ALT</a>
          </tt>
        </td>                    <td>左または右Altを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_LEFT_ALT">KEY_LEFT_ALT</a>
          </tt>
        </td>               <td>左Altを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RIGHT_ALT">KEY_RIGHT_ALT</a>
          </tt>
        </td>              <td>右Altを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SUPER">KEY_SUPER</a>
          </tt>
        </td>                  <td>左右いずれかのスーパーキーを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_LEFT_SUPER">KEY_LEFT_SUPER</a>
          </tt>
        </td>             <td>左辺スーパーを押す</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_RIGHT_SUPER">KEY_RIGHT_SUPER</a>
          </tt>
        </td>            <td>右スーパーを押す。</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SHIFT_LOCK">KEY_SHIFT_LOCK</a>
          </tt>
        </td>             <td>シフトロックが押された</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SHIFT_LOCK_ON">KEY_SHIFT_LOCK_ON</a>
          </tt>
        </td>          <td>シフトロックは現在オンです</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_NUM_LOCK">KEY_NUM_LOCK</a>
          </tt>
        </td>               <td>Num Lockを押す</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_NUM_LOCK_ON">KEY_NUM_LOCK_ON</a>
          </tt>
        </td>            <td>Num lockは現在オンです</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SCROLL_LOCK">KEY_SCROLL_LOCK</a>
          </tt>
        </td>            <td>スクロールロックを押す</td></tr>
    <tr><td>
          <tt>
            <a name="file_KEY_SCROLL_LOCK_ON">KEY_SCROLL_LOCK_ON</a>
          </tt>
        </td>         <td>スクロールロックは現在オンです</td></tr>
</table></dd></dl><p>機能<tt><span class="func">clickedXPos</span></tt>および<tt><span class="func">clickedYPos</span></tt>どの位置が「クリックされた」かを決定するために使用することができる。 以下のプログラムは<tt><span class="func">clickedXPos</span></tt>および<tt><span class="func">clickedYPos</span></tt>キーを押すごとにドットが生成されます。</p><pre class="indent">
$
;

;

;






;


スクリーン(640、480);

;
command:=
);


fcircle(
),4, light_red);
command:=
);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>draw.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>char<span class="keywd">:command</span>は<span class="keywd"></span>「」<a class="type" href="#types_char">begin</a>キーボード<span class="keywd">:=</span>グラフ_キーボード<span class="stri">getc</span>(<span class="keywd">キーボード</span>一方で<span class="var">コマンド=</span>KEY_MOUSE1<span class="var"></span>do<span class="func">clickedXPos</span>(<span class="var">キーボード</span>)<span class="keywd">clickedYPos</span>(<a class="var" href="#file_KEY_MOUSE1">キーボード</a>getc<span class="keywd">(</span>キーボード<span class="func">whileを終了する</span>関数終了<span class="var"></span><span class="func"></span><span class="var"></span><span class="func"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>キー押下とは独立したマウスカーソルの現在位置は、以下の関数で取得することができます。</p><ul>
    <li><tt><span class="func">pointerXPos</span></tt>これはマウスポインタの実際のX位置を返します。</li>
    <li><tt><span class="func">pointerYPos</span></tt>これはマウスポインタの実際のY位置を返します。</li>
</ul><p>機能<tt><span class="func">pointerXPos</span></tt>および<tt><span class="func">pointerYPos</span></tt>を使用して、カーソルで何かを移動できます(例:ドラッグ&amp;ドロップ)。 以下のプログラムは<tt><span class="func">buttonPressed</span></tt>を使用してマウスボタンが押される時間を決定します。 以下と一緒に使用します。<tt><span class="func">pointerXPos</span></tt>および<tt><span class="func">pointerYPos</span></tt>マウスボタンが押されている間、マウスカーソルに沿って描画します。</p><pre class="indent">
$
;

;

;






;


スクリーン(640、480);

;
command:=
);




fcircle(
(curr_win),4, light_red);

;
command:=
);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>draw.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>char<span class="keywd">:command</span>は<span class="keywd"></span>「」<a class="type" href="#types_char">begin</a>キーボード<span class="keywd">:=</span>グラフ_キーボード<span class="stri">getc</span>(<span class="keywd">キーボード</span>一方で<span class="var">コマンド=</span>KEY_MOUSE1<span class="var"></span>do<span class="func">一方で</span><span class="var">buttonPressed</span>(<span class="keywd">キーボード</span><a class="var" href="#file_KEY_MOUSE1">KEY_MOUSE1</a>)<span class="keywd">do</span>pointerXPos<span class="keywd">(curr_win)</span>pointerYPos<span class="func">whileを終了する</span>getc<span class="var">(</span>キーボード<a class="var" href="#file_KEY_MOUSE1">whileを終了する</a>関数終了<span class="keywd"></span><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="func"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>デフォルトでは、一部のキーはプログラムに配信されません。 デフォルトでは、ウィンドウの閉じるボタン(多くの場合<tt><span class="box">×</span></tt>)はプログラムを終了します。 デフォルトでは、ウィンドウのサイズ変更もプログラムに通知されません。 これら2つのイベントは<tt><span class="func">selectInput</span></tt>このようにして、プログラムは<tt><span class="var">KEY_CLOSE</span></tt>および<tt><span class="var">KEY_RESIZE</span></tt>:</p><pre class="indent">
$
;

;

;






;


スクリーン(640、480);

;




command:=
);





(curr_win),white);

;
command:=
);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>draw.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>char<span class="keywd">:command</span>は<span class="keywd"></span>「」<a class="type" href="#types_char">begin</a>キーボード<span class="keywd">:=</span>グラフ_キーボード<span class="stri">selectInput</span>(curr_win<span class="keywd">KEY_CLOSE</span><span class="var">TRUE</span>);<span class="var">#ウィンドウを閉じずにKEY_CLOSEを取得するプログラムを有効にします。</span>selectInput<span class="func">(curr_win</span>KEY_RESIZE<span class="var"></span>TRUE<span class="var">);</span>#KEY_RESIZEを取得するためプログラムを有効にします。<span class="comment">getc</span>(<span class="func">キーボード</span>一方で<span class="var">コマンド&lt;></span>KEY_CLOSE<span class="var"></span>do<span class="comment">if</span>コマンド=<span class="func">KEY_RESIZE</span><span class="var">その時</span>lineTo<span class="keywd">(0, 0</span>横<a class="var" href="#file_KEY_CLOSE">(curr_win)</a>高さ<span class="keywd">if終了</span>getc<span class="keywd">(</span>キーボード<a class="var" href="#file_KEY_RESIZE">whileを終了する</a>関数終了<span class="keywd"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="func"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span></pre><p>一部のファイルタイプは<tt><span class="var">キーボード</span></tt>そのようなファイルタイプの1つは<tt><span class="type">echoFile</span></tt>は、ライブラリで定義されています。<span class="stri">&quot;<span class="lib">echo.s7i</span>&quot;</span>An<tt><span class="type">echoFile</span></tt>ファイルを使用して、入力文字を出力ファイルに書き込むことができます。 これは便利です。<tt><span class="var">キーボード</span></tt>は入力をエコーしない。<tt><span class="type">echoFile</span></tt>サポートに制限されない<tt><span class="var">キーボード</span></tt>以下のプログラムは、入力されたキーのエコーを書き込み<tt><span class="stri">&#39;!&#39;</span></tt>以下に遭遇した場合:</p><pre class="indent">
$
;

;

;






;



);


ch:=getc(
);

;
writeln;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>echo.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<span class="keywd">:main</span>is func<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>char<span class="keywd">:ch</span>は<span class="keywd"></span>「」<a class="type" href="#types_char">begin</a>IN<span class="keywd">:=</span>openEcho<span class="stri">(</span>キーボード<span class="keywd"></span>OUT<span class="var">繰り返す</span>IN<span class="func">まで</span>ch=<span class="var">&#39;!&#39;</span>関数終了<span class="var"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre><p>An<tt><span class="type">echoFile</span></tt>もチェックする<span class="box">control-C</span>(<tt><a class="var" href="#file_KEY_CTL_A_TO_Z">KEY_CTL_C</a></tt>)。 もし<span class="box">control-C</span>と入力すると<tt><span class="type">echoFile</span></tt>プログラムを終了するかどうかたずねてきます。</p><pre class="indent">終了しますか(y/n)?
</pre><p>回答<tt>&#39;y&#39;</tt>または<tt>&#39;Y&#39;</tt>は次のように解釈され<tt>「はい」</tt>プログラムが次のメッセージで終了します。</p><pre class="indent">***ユーザーによりプログラムが中止されました
</pre><p>その他の入力はすべて質問を削除し、プログラムは入力の読み取りを続行します。</p><p>もう1つの便利なファイルタイプは<tt><span class="type">lineFile</span></tt>は、ライブラリで定義されています。<span class="stri">&quot;<span class="lib">行.s7i</span>&quot;</span>A<tt><span class="type">lineFile</span></tt>入力を修正することを可能にする<span class="box">バックスペース</span>まで<span class="box">リターン</span>(で表される<tt><span class="stri">&#39;\n&#39;</span></tt>)に遭遇した場合。 この編集機能とは対照的に、次の行を編集できます。<tt><span class="var">STD_IN</span></tt>オペレーティング・システムによって提供されます。 以下のプログラムは<tt><span class="type">echoFile</span></tt>および<tt><span class="type">lineFile</span></tt>入力行の編集をシミュレートします。</p><pre class="indent">
$
;

;

;

;






;



);

);


ch:=getc(
);
write(ch);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>echo.s7i<span class="lib">&quot;<span class="lib">含む</span></span>&quot;<span class="keywd">行.s7i</span>&quot;<span class="lib">const<span class="lib"></span>proc</span>:main<span class="keywd">is func</span>地域の<a class="type" href="#types_proc">var</a><span class="keywd">char</span>:ch<span class="keywd">は</span><span class="keywd">「」</span>begin<a class="type" href="#types_char">IN</a>:=<span class="keywd">openEcho</span>(<span class="stri">キーボード</span><span class="keywd">OUT</span>IN<span class="var">:=</span>openLine<span class="func">(</span>IN<span class="var">繰り返す</span>IN<span class="var">まで</span>ch=<span class="var">&#39;!&#39;</span>関数終了<span class="func"></span><span class="var"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre><p>次の行が含まれている場合、このプログラムは終了します。<tt><span class="stri">&#39;!&#39;</span></tt>で確認される<span class="box">リターン</span></p><p>また<tt><span class="type">editLineFile</span></tt>は、ライブラリで定義されています。<span class="stri">&quot;<span class="lib">editline.s7i</span>&quot;</span>An<tt><span class="type">editLineFile</span></tt>の組み合わせ以上のものを提供します。<tt><span class="type">echoFile</span></tt>で<tt><span class="type">lineFile</span></tt>An<tt><span class="type">editLineFile</span></tt>での編集を許可する<span class="box">バックスペース</span><span class="box">削除</span><!--(*--><span class="box">←</span><!--*)--><!--(*--><span class="box">→</span><!--*)--><span class="box">ホーム</span>および<span class="box">以上</span>垂直方向のカーソル・キーを使用して、前の入力行を取得できます。 のように<tt><span class="type">echoFile</span></tt>また、次のこともチェックします。<span class="box">control-C</span>(<tt><a class="var" href="#file_KEY_CTL_A_TO_Z">KEY_CTL_C</a></tt>)。</p><pre class="indent">
$
;

;

;

;






;



;

);
writeln(
);


write(&quot;command>&quot;);
readln(コマンド);

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">keybd.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>s7iコンソール<span class="lib">&quot;<span class="lib">含む</span></span>&quot;<span class="keywd">editline.s7i</span>&quot;<span class="lib">const<span class="lib"></span>proc</span>:main<span class="keywd">is func</span>地域の<a class="type" href="#types_proc">var</a><span class="keywd">文字列</span>:command<span class="keywd">は</span><span class="keywd">&quot;&quot;</span>begin<a class="type" href="#types_string">OUT</a>:=<span class="keywd">STD_CONSOLE</span>IN<span class="stri">:=</span>openEditLine<span class="keywd">(</span>キーボード<span class="var"></span>OUT<span class="var">「プログラムを終了するには、quitコマンドを使用してください。」</span>繰り返す<span class="var">まで</span>コマンド=<span class="func">&quot;quit&quot;</span>関数終了<span class="var"></span><span class="var"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre>
          <a name="file_Files_with_line_structure">
        <h3>8.8行構造のファイル</h3>
          </a>
        <p>図書館<span class="stri">&quot;<span class="lib">テキスト.s7i</span>&quot;</span>タイプを定義する<tt><a class="type" href="#types_text">テキスト</a></tt>は、のサブタイプです。<tt><a class="type" href="#types_file">ファイルする</a></tt>型式<tt><a class="type" href="#types_text">テキスト</a></tt>に、行構造や、スクロール、色付けなどの機能を追加します。<tt><a class="type" href="#types_file">ファイルする</a></tt>の行と列は<tt><a class="type" href="#types_text">テキスト</a></tt>左上隅の1から開始して、右下に向かって増加します。 機能<tt><span class="func">setPos</span></tt>の現在の行と列を<tt><a class="type" href="#types_text">テキスト</a></tt>:</p><pre class="indent">setPos(aText, 10, 20);
</pre><p>機能<tt><span class="func">setLine</span></tt>および<tt><span class="func">setColumn</span></tt>行と列のみをそれぞれ設定します。</p><pre class="indent">setLine(aText, 2);
setColumn(aText, 72);
</pre><p>の現在の行と列<tt><a class="type" href="#types_text">テキスト</a></tt>ファイルは、で取得できる<tt><span class="func">線</span></tt>および<tt><span class="func">列</span></tt>:</p><pre class="indent">
writeln(
&lt;&amp;line(aText));
writeln(
&lt;&amp;column(aText));
<span class="stri">現行行:</span>&quot;現在のカラム:&quot;<span class="stri"></span></pre><p>の現在の高さと幅<tt><a class="type" href="#types_text">テキスト</a></tt>ファイルは、で取得できる<tt><span class="func">高さ</span></tt>および<tt><span class="func">横</span></tt>:</p><pre class="indent">
writeln(
&lt;&amp;height(aText));
writeln(
&lt;&amp;width(aText));
<span class="stri">&quot;高さ:&quot;</span>&quot;幅:&quot;<span class="stri"></span></pre><p>テキストコンソール(またはテキストウィンドウ)へのランダムアクセス出力を許可するにはライブラリ<span class="stri">&quot;<span class="lib">s7iコンソール</span>&quot;</span>タイプを定義する<tt><span class="type">コンソールファイル</span></tt>・機能</p><pre class="indent">開いている(CONSOLE)
</pre><p>は<tt><span class="type">コンソールファイル</span></tt></p>
          <a name="file_Sockets">
        <h3>8.9ソケット</h3>
          </a>
        <p>図書館<span class="stri">&quot;<span class="lib">ソケット.s7i</span>&quot;</span>ソケットにアクセスするための型と関数を定義する。 ソケットの実装タイプは次のとおりです。<tt><span class="type">ソケット</span></tt>As interface type<tt><a class="type" href="#types_file">ファイルする</a></tt>を使用する場合:</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:clientSocket<span class="keywd">は</span><span class="var">STD_NULL</span></pre><p>有<tt><span class="func">openInetSocket</span></tt>インターネットクライアントソケットを開くことができます。</p><pre class="indent">
clientSocket:=
,80);
<span class="func">openInetSocket</span>(<span class="stri">&quot;www.google.com&quot;</span></pre><p>機能<tt><span class="func">openInetSocket</span></tt>ソケットを作成して接続します。 ローカルホストでインターネットソケットを開くには、次のようなコマンドを使います。<tt><span class="func">openInetSocket</span></tt>:</p><pre class="indent">
clientSocket:=
(1080);
<span class="func">openInetSocket</span></pre><p>ソケットでは<tt><a class="type" href="#types_file">ファイルする</a></tt>のようなインタフェース関数<tt><span class="func">writeln</span></tt>および<tt><span class="func">getln</span></tt>を使用することができる。</p><pre class="indent">
$
;

;






;

;


aSocket:=
(serverName, 80);



);

&lt;&amp;serverName);

);

(aSocket);
writeln(
(aSocket));

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;socket.s7i&quot;<span class="stri">const</span><span class="keywd">proc</span>:main<a class="type" href="#types_proc">is func</a>地域の<span class="keywd">const</span><span class="keywd">文字列</span>:serverName<span class="keywd">は</span><a class="type" href="#types_string">&quot;www.google.com&quot;</a>var<span class="keywd"></span>ファイルする<span class="stri">:aSocket</span>は<span class="keywd"></span>STD_NULL<a class="type" href="#types_file">begin</a>openInetSocket<span class="keywd">if</span>aSocket&lt;><span class="var">STD_NULL</span><span class="keywd">その時</span>writeln<span class="func">(aSocket</span>&quot;GET/HTTP/1.1&quot;<span class="keywd">writeln</span>(aSocket<span class="var">&quot;主催:&quot;</span>writeln<span class="keywd">(aSocket</span>&quot;User-Agent:BlackHole&quot;<span class="func">writeln</span>getln<span class="stri">if終了</span>関数終了<span class="func"></span><span class="stri"></span><span class="func"></span><span class="stri"></span><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span></pre><p>上記の例では、サーバーにHTTPリクエストを送信し、そのレスポンスからステータス・コードを取得しています。 上記の例は、ライブラリのコードで構成されています。<span class="stri">&quot;<span class="lib">gethttp.s7i</span>&quot;</span></p><p>サーバー・ソケットは以下のタイプでサポートされます。<tt><span class="type">聞き手</span></tt>リスナーは次のように定義します。</p><pre class="indent">value;
<span class="keywd">var</span><span class="type">聞き手</span>:myListener<span class="keywd">は</span><span class="type">聞き手</span></pre><p>図書館<span class="stri">&quot;<span class="lib">listener.s7i</span>&quot;</span>関数を定義する<tt><span class="func">openInetListener</span></tt>これにより<tt><span class="type">聞き手</span></tt>:</p><pre class="indent">
aListener:=
(1080);
<span class="func">openInetListener</span></pre><p>機能<tt><span class="func">耳を傾ける</span></tt>のソケット接続をlistenするために使用される。<tt><span class="type">聞き手</span></tt>そして、受信キューを制限します。</p><pre class="indent">(aListener, 10);
<span class="func">耳を傾ける</span></pre><p>機能<tt><span class="func">受理する</span></tt>最初に接続されたソケットを<tt><span class="type">聞き手</span></tt>:</p><pre class="indent">
serverSocket:=
(aListener);
<span class="func">受理する</span></pre><p>上記の機能を組み合わせることで、セッションを使用せずに要求を処理できます。</p><pre class="indent">
aListener:=
(1080);

(aListener, 10);


sock:=
(aListener);


close(sock);

;
<span class="func">openInetListener</span>耳を傾ける<span class="func">一方で</span><span class="keywd">TRUE</span><span class="var">do</span>受理する<span class="keywd">#sockからのリクエストを読み取り、処理します。</span>whileを終了する<span class="func"></span><span class="comment"></span><span class="keywd"></span></pre><p>同様のループが<span class="link">コマンチ</span>ウェブサーバー(メイン機能を参照)。 機能<tt><span class="func">waitForRequest</span></tt>を使用すると、セッションで要求を処理できます。</p><pre class="indent">
aListener:=
(2021);
listen(aListener, 10);



(aListener, existingConnection, newConnection);





;





;

;
<span class="func">openInetListener</span>一方で<span class="keywd"></span>TRUE<span class="var"></span>do<span class="keywd">waitForRequest</span>if<span class="func">existingConnection&lt;></span>STD_NULL<span class="keywd"></span>その時<span class="var">#existingConnectionからリクエストを読み取り、処理します。</span>if終了<span class="keywd">if</span>newConnection&lt;><span class="comment">STD_NULL</span><span class="keywd">その時</span>#welcomeメッセージをnewConnectionに送信する。<span class="keywd">if終了</span>whileを終了する<span class="var"></span><span class="keywd"></span><span class="comment"></span><span class="keywd"></span><span class="keywd"></span></pre><p>類似のコードがプログラムで使用されています。<span class="stri">&quot;ftpserv.sd7&quot;</span>の実施<tt><span class="func">waitForRequest</span></tt>基づいている<tt><span class="type">pollData</span></tt>これは<span class="stri">&quot;<span class="lib">poll.s7i</span>&quot;</span></p>
          <a name="file_Transport_layer_security">
        <h3>8.10トランスポート層セキュリティ</h3>
          </a>
        <p>Transport Layer Security(TLS)は、Secure Sockets Layer(SSL)の後継プロトコルです。 コンピュータ・ネットワーク上で安全な通信を提供します。 図書館<span class="stri">&quot;<span class="lib">tls.s7i</span>&quot;</span>では、TLSソケットのタイプと関数を定義しています。 ソケットの実装タイプは次のとおりです。<tt><span class="type">tlsFile</span></tt>As interface type<tt><a class="type" href="#types_file">ファイルする</a></tt>を使用する場合:</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:aTlsSocket<span class="keywd">は</span><span class="var">STD_NULL</span></pre><p>有<tt><span class="func">openTlsSocket</span></tt>TLSソケットを開くことができます。</p><pre class="indent">
aTlsSocket:=
,443);
<span class="func">openTlsSocket</span>(<span class="stri">&quot;www.google.com&quot;</span></pre><p>機能<tt><span class="func">openTlsSocket</span></tt>はTLSソケットをオープンする。 TLSソケットは<tt><a class="type" href="#types_file">ファイルする</a></tt>のようなインタフェース関数<tt><span class="func">writeln</span></tt>および<tt><span class="func">getln</span></tt>を使用することができる。</p><pre class="indent">
$
;

;






;

;


aTlsSocket:=
(serverName, 443);



);

&lt;&amp;serverName);

);

(aTlsSocket);
writeln(
(aTlsSocket));

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;tls.s7i&quot;<span class="stri">const</span><span class="keywd">proc</span>:main<a class="type" href="#types_proc">is func</a>地域の<span class="keywd">const</span><span class="keywd">文字列</span>:serverName<span class="keywd">は</span><a class="type" href="#types_string">&quot;www.google.com&quot;</a>var<span class="keywd"></span>ファイルする<span class="stri">:aTlsSocket</span>は<span class="keywd"></span>STD_NULL<a class="type" href="#types_file">begin</a>openTlsSocket<span class="keywd">if</span>aTlsSocket&lt;><span class="var">STD_NULL</span><span class="keywd">その時</span>writeln<span class="func">(aTlsSocket</span>&quot;GET/HTTP/1.1&quot;<span class="keywd">writeln</span>(aTlsSocket<span class="var">&quot;主催:&quot;</span>writeln<span class="keywd">(aTlsSocket</span>&quot;User-Agent:BlackHole&quot;<span class="func">writeln</span>getln<span class="stri">if終了</span>関数終了<span class="func"></span><span class="stri"></span><span class="func"></span><span class="stri"></span><span class="func"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span></pre><p>上記の例では、HTTPS要求をサーバに送信し、その応答からステータスコードを取得しています。 上記の例は、ライブラリのコードで構成されています。<span class="stri">&quot;<span class="lib">gethttps.s7i</span>&quot;</span></p><p>機能<tt><span class="func">openServerTls</span></tt>を使用して、サーバ側でTLSソケットを開くことができます。 図書館<span class="stri">&quot;<span class="lib">x 509証明書.s7i</span>&quot;</span>自己署名証明書を定義する<tt><span class="var">stdCertificate</span></tt>この証明書は、TLSサーバーソケットを開くために使用できます。</p><pre class="indent">
$
;

;

;

;






value;

;

;

;


aListener:=
(11111);

(aListener, 10);


sock:=
(aListener);
tlsSock:=
);



);


line:=
(tlsSock);

);

;

(tlsSock);



);

;

;

end func;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;socket.s7i&quot;<span class="stri">含む</span><span class="keywd">&quot;listener.s7i&quot;</span>含む<span class="stri"></span>&quot;tls.s7i&quot;<span class="keywd">const</span><span class="stri">proc</span>:main<span class="keywd">is func</span>地域の<a class="type" href="#types_proc">var</a><span class="keywd">聞き手</span>:aListener<span class="keywd">は</span><span class="keywd">聞き手</span>var<span class="type"></span>ファイルする<span class="keywd">:靴下</span>は<span class="type"></span>STD_NULL<span class="keywd">var</span><a class="type" href="#types_file">ファイルする</a>:tlsSock<span class="keywd">は</span><span class="var">STD_NULL</span>var<span class="keywd"></span>文字列<a class="type" href="#types_file">:line</a>は<span class="keywd"></span>&quot;&quot;<span class="var">begin</span>openInetListener<span class="keywd">耳を傾ける</span>一方で<a class="type" href="#types_string"></a>TRUE<span class="keywd"></span>do<span class="stri">受理する</span>openServerTls<span class="keywd">(靴下</span>stdCertificate<span class="func">if</span>tlsSock&lt;><span class="func">STD_NULL</span><span class="keywd">その時</span>writeln<span class="var">(</span>「成功」<span class="keywd">繰り返す</span>getln<span class="func">writeln</span>(line&lt;&amp;<span class="func">&quot;received&quot;</span>まで<span class="var">行=</span>&quot;&quot;<span class="keywd">クローズ</span>else<span class="var">writeln</span>(<span class="keywd">&quot;***TLS接続を開くことができません。&quot;</span>if終了<span class="func">whileを終了する</span><span class="stri"></span><span class="keywd"></span><span class="func"></span><span class="func"></span><span class="stri"></span><span class="keywd"></span><span class="stri"></span><span class="func"></span><span class="keywd"></span><span class="func"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></pre>
          <a name="file_User_defined_file_types">
        <h3>8.11ユーザ定義のファイルタイプ</h3>
          </a>
        <p>定義済みのファイルタイプに加えて、新しいタイプのファイルを定義しなければならないこともよくあります。 このような新しいファイルにはいくつかの可能性があります。</p><ul>
    <li>その内容を文字列に格納することもできます(高速化のためだけでなく、追加のファイル操作を提供するためにも)。</li>

    <li>その情報は、処理して(大文字などに)別のファイルに送ることができます。</li>

    <li>これはUnixのユーティリティのように動作するでしょう(more, sort, tee, uniq.などを考えてみてください)。</li>

    <li>別のインターフェースを持つものに対して、ファイルのようなインターフェースを提供できます。 (例:ディレクトリの内容、または画面へのランダムアクセスI/O)</li>
</ul><p>次の宣言で、新しいファイルタイプを定義します。</p><pre class="indent">





;
<span class="keywd">const</span><span class="type">タイプ</span>:my_file_type<span class="keywd">is sub</span><span class="type">空ファイル</span><span class="keywd">構造体</span>(*現地データ*)<span class="comment">構造体を終了する</span><span class="keywd"></span></pre><p>タイプを導出する必要はありません。<tt><span class="type">ファイルの種類</span></tt>から直接<tt><span class="type">空ファイル</span></tt>型式<tt><span class="type">ファイルの種類</span></tt>の間接的な子孫である場合もある<tt><span class="type">空ファイル</span></tt>したがって、ファイルタイプの階層を作成できます。 新しいファイルによって実装されるインタフェースも指定する必要があります。</p><pre class="indent">
type_implements_interface(
);
<span class="type">ファイルの種類</span><a class="type" href="#types_file">ファイルする</a></pre><p>型式<tt><a class="type" href="#types_file">ファイルする</a></tt>は使用できる唯一のインタフェースタイプではありません。 タイプもある<tt><a class="type" href="#types_text">テキスト</a></tt>に由来する<tt><a class="type" href="#types_file">ファイルする</a></tt>型式<tt><a class="type" href="#types_text">テキスト</a></tt>行単位のファイルを記述します。<tt><span class="func">setPos</span></tt>関数群が呼び出されます(これによって、現在位置が指定した行と列に移動します)。 から派生した新しいインタフェース型を定義することも可能です。<tt><a class="type" href="#types_file">ファイルする</a></tt>または<tt><a class="type" href="#types_text">テキスト</a></tt></p><p>次に、open関数が必要です。<tt><span class="type">ファイルの種類</span></tt>ファイル:</p><pre class="indent">



;



value;





newFile:=toInterface(new_file);


;
<span class="keywd">const</span><span class="type">funcファイル</span>:open_my_file(<span class="comment">(*パラメータ*)</span>)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">ファイルする</span>:newFile<a class="type" href="#types_file">は</a><span class="keywd">STD_NULL</span>地域の<span class="var">var</span><span class="keywd">ファイルの種類</span>:new_file<span class="keywd">は</span><span class="type">ファイルの種類</span>begin<span class="keywd">(*new_fileのデータ要素の初期化*)</span>関数終了<span class="type"></span><span class="keywd"></span><span class="comment"></span><span class="keywd"></span></pre><p>関数<tt>&#39;toInterface&#39;</tt>を使用して、新しい<tt><a class="type" href="#types_file">ファイルする</a></tt>オブジェクトを作成します。 ここで定義する必要があるのは、次の2つの基本入出力操作のみです。</p><pre class="indent">







;






&quot;&quot;;







;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:write(<span class="keywd">入力する</span><span class="type">ファイルの種類</span>:new_fil<span class="keywd">で</span><span class="type">文字列</span>:stri)<span class="keywd">is func</span>begin<span class="keywd">(*出力する文*)</span>関数終了<span class="comment">const</span><span class="keywd">proc</span>:gets(<span class="keywd">入力する</span><a class="type" href="#types_proc">ファイルの種類</a>:new_fil<span class="keywd">で</span><span class="type">整数</span>:leng)<span class="keywd">is func</span>結果<span class="type">var</span><span class="keywd">文字列</span>:stri<span class="keywd">は</span>begin<span class="keywd">(*入力を行う文*)</span>関数終了<span class="type"></span><span class="keywd"></span><span class="keywd"></span><span class="comment"></span><span class="keywd"></span></pre><p></p>
          <a name="file_Scanning_a_file">
        <h3>8.12ファイルのスキャン</h3>
          </a>
        <p>前章で紹介した入出力の概念では、データの入力と変換を分離しています。 その<tt><span class="func">読む</span></tt><tt><span class="func">readln</span></tt><tt><span class="func">getwd</span></tt>および<tt><span class="func">getln</span></tt>関数は空白で区切られたデータ要素を読むように設計されている。 データ要素が空白文字で区切られていない場合、このI/Oの概念は使用できません。 その代わりに、ファイルから読み取る関数には、読み取りたい型に関する何らかの知識が必要です。 幸い、ここはよく研究された地域です。 コンパイラが使用する字句走査プログラムは、まさにこの問題を解決します。</p><p>字句走査装置は、ファイルからシンボルを読み取り、現行文字の概念を使用します。 シンボルには、名前、数字、文字列、演算子、括弧などがあります。 シンボルをスキャンすると、現在の文字が最初に処理されます。 スキャナがシンボルを読み取った後、現在の文字はそのシンボルの直後の文字を含む。 この文字は次のシンボルの最初の文字か空白文字である可能性があります。 シンボルのセットが適切に選択されれば、シンボルのタイプとシンボルの文字の読み取りをいつ停止するかに関するすべての決定は、現在の文字に基づいて行うことができます。</p><p>毎<tt><a class="type" href="#types_file">ファイルする</a></tt>を含む<tt>&#39;bufferChar&#39;</tt>で定義されたスキャナ関数によって現在の文字として使用されている<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリ。 その<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリにskip.が含まれています そして手に入れよう で呼び出されます。 スキップ. プロシージャはvoidを返し、get. 関数は読み込んだ文字列を返す。 以下の基本的なスキャナ関数は<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリ:</p><dl>
    <dt>
          <span class="func">skipComment</span>
        </dt>
      <dd>ネストされている可能性があるエントリをスキップします<a class="link" href="#tokens_Comments">Seed7コメント</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getComment</span>
        </dt>
      <dd>ネストされている可能性があるファイルを読み取ります。<a class="link" href="#tokens_Comments">Seed7コメント</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">skipClassicコメント</span>
        </dt>
      <dd>aから古典的なCのコメントをスキップします。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">skipLineComment</span>
        </dt>
      <dd>をスキップします。<a class="link" href="#tokens_Line_comments">行コメント</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getLineComment</span>
        </dt>
      <dd>を読み取ります。<a class="link" href="#tokens_Line_comments">行コメント</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getDigits</span>
        </dt>
      <dd>から数字の列を読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getInteger</span>
        </dt>
      <dd>からオプション符号付きの10進整数を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getNumber</span>
        </dt>
      <dd>数値リテラル(<a class="link" href="#tokens_Integer_literals">整数</a><a class="link" href="#tokens_BigInteger_literals">bigInteger</a>または<a class="link" href="#tokens_Float_literals">浮かぶ</a>リテラル)から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getNonDigits</span>
        </dt>
      <dd>から数字以外の文字列を読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getQuotedText</span>
        </dt>
      <dd>&quot;or&quot;で囲まれたテキストを読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getSimpleStringLiteral</span>
        </dt>
      <dd>から単純文字列リテラルを読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getCharLiteral</span>
        </dt>
      <dd>を読み取ります。<a class="link" href="#tokens_Character_literals">文字直定数</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getStringLiteral</span>
        </dt>
      <dd>を読み取ります。<a class="link" href="#tokens_String_literals">文字列直定数</a>から<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getName</span>
        </dt>
      <dd>から英数字の名前を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
</dl><p>に反して<tt><span class="func">読む</span></tt>および<tt><span class="func">getwd</span></tt>基本的なスキャナ関数は先頭の空白文字をスキップしない。 空白文字をスキップするには、次のいずれかの関数を使用します。</p><dl>
    <dt>
          <span class="func">skipSpace</span>
        </dt>
      <dd>スペース文字をスキップします。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">skipSpaceOrTab</span>
        </dt>
      <dd>スペースおよびタブ文字をスキップします。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">空白をスキップ</span>
        </dt>
      <dd>から空白文字をスキップします。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getWhiteSpace</span>
        </dt>
      <dd>から空白文字を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getWord</span>
        </dt>
      <dd>から空白で区切られた単語を読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">スキップライン</span>
        </dt>
      <dd>から1行飛ばして表示する。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getLine</span>
        </dt>
      <dd>から行を読み込む。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
</dl><p>高度なスキャナ関数は、シンボルを読み取る前に空白文字をスキップします。</p><dl>
    <dt>
          <span class="func">getSymbolOrComment</span>
        </dt>
      <dd>からシンボルまたはコメントを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getSymbol</span>
        </dt>
      <dd>からシンボルを読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getSymbolWithHtmlEntities</span>
        </dt>
      <dd>htmlエンティティが許可されているシンボルを<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getHtmlTagSymbolOrComment</span>
        </dt>
      <dd>からHTMLタグ、シンボル、またはコメントを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">skipXmlComment</span>
        </dt>
      <dd>からXMLコメントをスキップします。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getXmlTagOrContent</span>
        </dt>
      <dd>からXML/HTMLタグまたはXML/HTMLコンテンツテキストを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getXmlCharacterReference</span>
        </dt>
      <dd>から定義済みXMLエンティティを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getXmlCdataContent</span>
        </dt>
      <dd>からCDATAセクションのコンテンツ・テキストを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getXmlTagHeadOrContent</span>
        </dt>
      <dd>からXML/HTMLタグヘッドまたはXML/HTMLコンテンツを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getSymbolInXmlTag</span>
        </dt>
      <dd>からXML/HTMLタグ内に表示されるシンボルを読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">skipXmlTag</span>
        </dt>
      <dd>内のXMLタグを超えてスキップする。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getNextXmlAttribute</span>
        </dt>
      <dd>XMLタグ内の属性の名前および値を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getHtmlAttributeValue</span>
        </dt>
      <dd>からHTMLタグの属性値を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getNextHtmlAttribute</span>
        </dt>
      <dd>からHTMLタグ内の属性の名前と値を読み取ります。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
    <dt>
          <span class="func">getSimpleSymbol</span>
        </dt>
      <dd>から単純シンボルを読み込みます。<tt><a class="type" href="#types_file">ファイルする</a></tt></dd>
</dl><p>すべてのスキャナ関数は、処理される最初の文字が<tt>&#39;bufferChar&#39;</tt>そして、それらが終了した後、処理されるべき次の文字も<tt>&#39;bufferChar&#39;</tt>新しく開いたファイルに対して検索機能を使うには、最初の文字を<tt>&#39;bufferChar&#39;</tt>変更後:</p><pre class="indent">myFile.bufferChar:=getc(myFile);
</pre><p>ほとんどの場合、ファイル全体が通常の入出力機能または検索機能で処理される。 通常の入出力機能とスキャナ機能を組み合わせる必要がある場合は、次の点に注意してください。</p><ul>
    <li>ファイルから最後に読み取られた関数が<tt><span class="func">読む</span></tt><tt><span class="func">readln</span></tt><tt><span class="func">getwd</span></tt>または<tt><span class="func">getln</span></tt>その<tt>&#39;bufferChar&#39;</tt>には次に処理すべき文字がすでに含まれているので、以降のスキャナ関数を使用することができます。</li>

    <li>その他のI/O機能<tt><span class="func">getc</span></tt>および<tt><span class="func">取得</span></tt>何かを割り当てない<tt>&#39;bufferChar&#39;</tt>この場合は何かが割り当てられるべきです<tt>&#39;bufferChar&#39;</tt></li>

    <li>スキャナ機能から通常の入出力機能への切り替えは<tt>&#39;bufferChar&#39;</tt>が知られている。 行末などです。</li>
</ul><p>スキャナ関数は、数字が存在しない場合に失敗せずに数値入力を読み込む必要がある場合に便利です。</p><pre class="indent">
skipWhiteSpace(
);


writeln(&quot;empty input&quot;);


数:=
);
skipLine(
);
writeln(&quot;number&quot;&lt;&amp;number);


stri:=getLine(
);
writeln(&quot;command&quot;&lt;&amp;literal(stri));

;
<span class="var">IN</span>if<span class="keywd">eoln(</span>IN<span class="var">)</span>その時<span class="keywd">elsif</span><span class="keywd">IN</span>bufferChar<span class="var">で</span>{&#39;0&#39;..&#39;9&#39;}<span class="keywd">その時</span>整数<span class="keywd"></span>解析する<span class="type">getDigits(</span>IN<span class="op">IN</span>else<span class="var">IN</span>if終了<span class="var"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">getSymbol</span></tt>は、Seed7シンボルを読み取るように設計されています。 ファイルの終わりに達すると、以下を返す。<tt><span class="stri">&quot;&quot;</span></tt>with<tt><span class="func">getSymbol</span></tt>名前と値のペアが読み込めます:</p><pre class="indent">name:=getSymbol(inFile);




aValue=getSymbol(inFile);




keyValueHash@:=[name]aValue[2.];


keyValueHash@:=[name]aValue;

;

;

;

;
<span class="keywd">一方で</span>名前&lt;><span class="stri">&quot;&quot;</span><span class="keywd">do</span>if<span class="keywd">名前&lt;></span>「#」<span class="stri"></span>および<span class="keywd">getSymbol(inFile)=</span>&quot;=&quot;<span class="stri"></span>その時<span class="keywd">if</span>aValue&lt;><span class="keywd">&quot;&quot;</span><span class="stri">その時</span>if<span class="keywd">aValue[1]=</span>&quot;&quot;&quot;<span class="keywd"></span>その時<span class="stri">elsif</span>aValue[1]<span class="keywd">で</span>{<span class="keywd">&#39;0&#39;</span><span class="keywd">&#39;9&#39;</span>}<span class="stri">その時</span>if終了<span class="stri">if終了</span>if終了<span class="keywd">whileを終了する</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>次のループを使用して、Seed7プログラムのシンボルを処理できます。</p><pre class="indent">inFile.bufferChar:=getc(inFile);
currSymbol:=getSymbol(inFile);


process currSymbol.
currSymbol:=getSymbol(inFile);

;
<span class="keywd">一方で</span>currSymbol&lt;><span class="stri">&quot;&quot;</span><span class="keywd">do</span>whileを終了する<span class="keywd"></span></pre><p>空白文字とコメントはこの関数で自動的にスキップされます。<tt><span class="func">getSymbol</span></tt>・コメントも返されるべき場合、関数<tt><span class="func">getSymbolOrComment</span></tt>も使用できます。 機能と合わせて<tt><span class="func">getWhiteSpace</span></tt>シンボル間の空白文字を取得することも可能です。</p><pre class="indent">



;



;

;


inFile:=open(fileName
);


inFile.bufferChar:=getc(inFile);
processed:=getWhiteSpace(inFile);
currSymbol:=getSymbolOrComment(inFile);


processed&amp;:=currSymbol;
processed&amp;:=getWhiteSpace(inFile);
currSymbol:=getSymbolOrComment(inFile);

;

;

;
<span class="keywd">const</span><span class="type">機能文字列</span>:processFile(<span class="keywd">で</span><span class="type">文字列</span>:fileName)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">文字列</span>:処理済み<span class="type">は</span><span class="keywd">&quot;&quot;</span>地域の<span class="stri">var</span><span class="keywd">ファイルする</span>:inFile<span class="keywd">は</span><a class="type" href="#types_file">STD_NULL</a>var<span class="keywd"></span>文字列<span class="var">:currSymbol</span>は<span class="keywd"></span>&quot;&quot;<span class="type">begin</span>「r」<span class="keywd">if</span>inFile&lt;><span class="stri">STD_NULL</span><span class="keywd">その時</span>一方で<span class="stri">currSymbol&lt;></span>&quot;&quot;<span class="keywd"></span>do<span class="var">whileを終了する</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>上記の例では<tt>&#39;processFile&#39;</tt>は、返された文字列からすべてのシンボル、空白文字、コメントを収集する。 返される文字列は<tt>&#39;processFile&#39;</tt>関数が返すものと等価である<tt>&#39;getf&#39;</tt>これにより、スキャナの機能を簡単にテストできます。</p><p>ロジックは<tt><span class="func">getWhiteSpace</span></tt>および<tt><span class="func">getSymbolOrComment</span></tt>は、コメントやリテラルにHTMLタグを追加するのに使用することができます。 次の関数は、コメントを緑、文字列リテラル、文字リテラルを栗色、数値リテラルを紫で色付けします。</p><pre class="indent">



;


inFile.bufferChar:=getc(inFile);
write(outFile
);
write(outFile, getWhiteSpace(inFile));
currSymbol:=getSymbolOrComment(inFile);


currSymbol:=replace(currSymbol
);
currSymbol:=replace(currSymbol
);


write(outFile
);
write(outFile, currSymbol);
write(outFile
);


write(outFile
);
write(outFile, currSymbol);
write(outFile
);


write(outFile
);
write(outFile, currSymbol);
write(outFile
);


write(outFile, currSymbol);

;
write(outFile, getWhiteSpace(inFile));
currSymbol:=getSymbolOrComment(inFile);

;
write(outFile
);

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:sourceToHtml(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:inFile<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:outFile)<span class="keywd">is func</span>地域の<span class="keywd">var</span><span class="keywd">文字列</span>:currSymbol<span class="type">は</span><span class="keywd">&quot;&quot;</span>begin<span class="stri">&quot;&lt;pre>\n&quot;</span>一方で<span class="keywd">currSymbol&lt;></span>&quot;&quot;<span class="stri"></span>do<span class="keywd">&quot;&amp;&quot;</span><span class="stri">&quot;&amp;amp;&quot;</span>&quot;&lt;&quot;<span class="keywd"></span>&quot;&amp;lt;&quot;<span class="stri">if</span>currSymbol[1]<span class="stri">で</span>{<span class="stri">&quot;&quot;&quot;</span><span class="stri">「」</span>}<span class="keywd">その時</span>&quot;&lt;フォントカラー=\&quot;栗色\&quot;>&quot;<span class="keywd">&quot;&lt;/font>&quot;</span>elsif<span class="stri">currSymbol[1]=</span>&#39;#&#39;<span class="stri"></span>または<span class="keywd">startsWith(currSymbol</span>&quot;(*&quot;<span class="stri">)</span>その時<span class="stri">&quot;&lt;フォント色=\&quot;緑\&quot;>&quot;</span>&quot;&lt;/font>&quot;<span class="keywd">elsif</span>currSymbol[1]<span class="stri">で</span>digit_char<span class="keywd">その時</span>&quot;&lt;フォントカラー=\&quot;紫\&quot;>&quot;<span class="stri">&quot;&lt;/font>&quot;</span>else<span class="keywd">if終了</span>whileを終了する<span class="stri">&quot;&lt;/pre>\n&quot;</span>関数終了<span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">skipSpace</span></tt>および<tt><span class="func">空白をスキップ</span></tt>は<span class="stri">&quot;<span class="lib">scanfile.s7i</span>&quot;</span>ライブラリを次のように変更します。</p><pre class="indent">



;


ch:=inFile.bufferChar;


ch:=getc(inFile);

;
inFile.bufferChar:=ch;

;







inFile.bufferChar:=getc(inFile);

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:skipSpace(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:inFile)<span class="keywd">is func</span>地域の<span class="keywd">var</span><span class="keywd">char</span>:ch<a class="type" href="#types_char">は</a><span class="keywd">「」</span>begin<span class="stri">一方で</span>ch=&#39;&#39;<span class="keywd">do</span>whileを終了する<span class="keywd">関数終了</span>const<span class="keywd"></span>proc<span class="keywd">:skipWhiteSpace(</span>入力する<span class="keywd"></span>ファイルする<span class="keywd">:inFile)</span>is func<a class="type" href="#types_proc">begin</a>一方で<span class="keywd">inFile.bufferChar</span>で<a class="type" href="#types_file">空白文字</a>do<span class="keywd">whileを終了する</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">skipComment</span></tt>および<tt><span class="func">skipLineComment</span></tt>は、Seed7コメントをスキップするために使用でき、次のように定義されています。</p><pre class="indent">



;


character:=getc(inFile);






character:=getc(inFile);

;


character:=getc(inFile);


skipComment(inFile);
character:=getc(inFile);

;

;

;


character:=getc(inFile);

;

;


inFile.bufferChar:=
;


inFile.bufferChar:=getc(inFile);

;








;




character:=getc(inFile);

;
inFile.bufferChar:=character;


<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:skipComment(<span class="keywd">入力する</span><a class="type" href="#types_file">ファイルする</a>:inFile)<span class="keywd">は</span><span class="keywd">機能</span>地域の<span class="keywd">var</span><span class="keywd">char</span>:文字<span class="type">は</span><span class="keywd">「」</span>begin<span class="stri">繰り返す</span>繰り返す<span class="keywd">一方で</span>性格<span class="keywd">ない</span><span class="keywd">で</span>special_comment_char<span class="keywd">do</span>終わり<span class="keywd"></span>一方で<span class="keywd">if</span>文字=<span class="keywd">&#39;(&#39;</span><span class="keywd">その時</span>if<span class="keywd">文字=</span>&#39;*&#39;<span class="keywd"></span>その時<span class="stri">終わり</span><span class="keywd">if</span>終わり<span class="keywd"></span>if<span class="stri">まで</span>文字=<span class="keywd">&#39;*&#39;</span><span class="keywd">または</span>文字=<span class="keywd">ファイルの終り</span>if<span class="keywd">文字&lt;></span>ファイルの終り<span class="keywd"></span>その時<span class="keywd">終わり</span><span class="stri">if</span>まで<span class="keywd">文字=</span>&#39;)&#39;<span class="var"></span>または<span class="keywd">文字=</span>ファイルの終り<span class="var">if</span>文字=<span class="keywd">ファイルの終り</span><span class="keywd">その時</span>ファイルの終り<span class="keywd">else</span>終わり<span class="keywd"></span>if<span class="stri">終わり</span><span class="keywd">機能</span>;<span class="var">#skipComment</span>const<span class="keywd"></span>proc<span class="var">:skipLineComment(</span>入力する<span class="keywd"></span>ファイルする<span class="var">:inFile)</span>は<span class="keywd"></span>機能<span class="keywd">地域の</span>var<span class="keywd"></span>char<span class="keywd">:文字</span>は<span class="keywd"></span>「」<span class="comment">begin</span>繰り返す<span class="keywd">まで</span>文字=<a class="type" href="#types_proc">&#39;\n&#39;</a><span class="keywd">または</span>文字=<a class="type" href="#types_file">ファイルの終り</a>終わり<span class="keywd"></span>機能<span class="keywd">;</span>#skipLineComment<span class="keywd"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span><span class="var"></span><span class="keywd"></span><span class="keywd"></span><span class="comment"></span></pre><p></p>
          <a name="syntax_file_start"></a>
        <p></p>
          <a name="syntax_STRUCTURED_SYNTAX_DEFINITION">
        <h2>9. 構造化構文の定義</h2>
          </a>
        <p>ほとんどのプログラミング言語には、文や演算子のような定義済みの構造しかありません。 一方、Seed7では、ユーザ定義のコンストラクトも追加で許可されています。 この章では、新しい構成体の構文を定義するために使用されるSeed7構造化構文記述(S7SSD)を紹介します。 定義済みコンストラクトの構文は、S7SSDでも定義されています。</p><p>従来の構文解析のマニュアルで使用されている構文記述は、対応するインタプリタ/コンパイラのプログラミング言語で使用されているアプローチとは無関係です。 S7SSDは、人間とコンパイラ/インタプリタが使用できる単純な構文記述です。 コンパイラ-コンパイラは機械可読な構文記述の道をたどりますが、はるかに複雑な構文と意味記述を使用し、言語のユーザーが新しい構造を定義できません。</p><p>プログラミング言語のシンタックスを指定するための様々な既存の表記法がある。 バッカス-ナウア形式(BNF)およびその変種である拡張バッカス-ナウア形式(EBNF)は、このような構文仕様の例です。 新しい概念はよく知られた概念と比較すると理解しやすいため、ここではEBNFをS7SSDの説明のベースとして使用します。</p>
          <a name="syntax_The_Extended_Backus-Naur_Form">
        <h3>9.1拡張バッカス-ナウア形式</h3>
          </a>
        <p>名前が示すように、拡張バッカス-ナウア形式はBNFの拡張です。 この拡張機能では、再帰を使用せずに反復およびオプション・パートを定義できます。 EBNFには次の要素が含まれます。</p><ul>
    <li>非終端記号は識別子で記述されます。 識別子は、英小文字と下線文字で構成されます。</li>

    <li>終端記号は、大文字で引用された文字列または名前で、印刷不可能な文字(制御文字)を表します。</li>

    <li>非終端記号および/または終端記号の連結は、それらを順に記述することによって記述される。</li>

    <li>2つの選択肢があれば、分けられます。</li>

    <li>拡張バッカス-ナウア形式の式は括弧(.)で囲むことができます。</li>

    <li>式がオプションの場合は、角括弧[.]で囲みます。</li>

    <li>式が省略されたり繰り返されたりする場合は、中括弧{.}で囲まれます。</li>
</ul><p>拡張バッカス-ナウア形式の構文は、拡張バッカス-ナウア形式で説明できます。</p><dl><dd>
          <tt>
        <dl>
    <dt>syntax_description::=</dt><dd>{<a class="ebnf" href="#syntax_ebnf_ebnf_statement">ebnf_statement</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="syntax_ebnf_ebnf_statement">ebnf_statement</a>::=</dt><dd>identifier&#39;::=&#39;<a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a>&#39;.&#39;.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="syntax_ebnf_ebnf_expression">ebnf_expression</a>::=</dt><dd><a class="ebnf" href="#syntax_ebnf_ebnf_term">期間</a>{&#39;&#39;<a class="ebnf" href="#syntax_ebnf_ebnf_term">期間</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="syntax_ebnf_ebnf_term">期間</a>::=</dt><dd><a class="ebnf" href="#syntax_ebnf_ebnf_factor">要因</a>{<a class="ebnf" href="#syntax_ebnf_ebnf_factor">要因</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="syntax_ebnf_ebnf_factor">要因</a>::=</dt><dd>識別文字列control_character_description<br />&#39;(&#39;<a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a>&#39;)&#39;&#39;[&#39;<a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a>&#39;]&#39;<br />&#39;{&#39;<a class="ebnf" href="#syntax_ebnf_ebnf_expression">ebnf_expression</a>&#39;}&#39;。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="syntax_The_Seed7_Structured_Syntax_Description">
        <h3>9.2Seed7構造化構文の説明</h3>
          </a>
        <p>Seed7構造化構文記述はS7SSDと省略される。 S7SSDは、プログラミング言語の構文のほとんどを記述できますが、すべてを記述できるわけではありません。 識別子やリテラル、コメントの構文はS7SSDで記述しない。 S7SSDでは、プログラムを大きなタイプレスの式として捉えています。 この式の構文は、前置、中置、後置の演算子を使用して記述します。 演算子には優先順位と結合性があります。 演算子は1つ以上の演算子記号を持つことができます。 演算子の演算子記号は隣接していてもよいし、間にパラメータを含んでいてもよい。 インフィックスのS7SSD<tt>+</tt>は:</p><pre class="indent">
$
7;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.(). +.()<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a></pre><p>これは<tt>+</tt>as<a class="link" href="#syntax_left_associative">左結合</a>優先順位7の中置演算子。 実際の構文を以下に示します。</p><pre class="indent">()。 +.()
</pre><p>ドットは要素のリストを作成するために使用されます。 構文を記述するために、ドットを削除するだけで次のようになります。</p><pre class="indent">()+()
</pre><p>パラメータの場所は<tt>()</tt>その<tt>+</tt>演算子はインフィックス演算子です。<tt>+</tt>の前後には<tt>()</tt>任意の式を<tt>()</tt>パラメータを使用します。 のタイプ。<tt>()</tt>パラメータと結果の型<tt>+</tt>はS7SSDでは指定されていません。 正しい型のチェックは、構文レベルでは行われません。 このように、S7SSDでは、対応するEBNF記述では許されないような構文も許されています。 S7SSDでは、演算子記号とその優先度および結合性のみが考慮されます。</p>
          <a name="syntax_The_syntax_of_a_statement">
        <h3>9.3文の構文</h3>
          </a>
        <p>Seed7構造化構文記述を説明するために、新しいステートメントを設計します。<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>その<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>と類似している必要があります<a class="link" href="#stats_while-statement">一方-</a>および<a class="link" href="#stats_repeat-statement">repeat-loops</a>ただし、最初または最後に条件付き終了を設定するのではなく、ループの途中に条件付き終了を設定する必要があります。 この中央の条件付き終了は<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>一部のプログラミング言語に存在するbreakステートメントは、それ自体がステートメントであり、残すループの一部ではないことに注意してください。 したがって、中間の条件付き終了をbreakステートメントと混同しないでください。 新しいの例<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は:<p><pre class="indent">
ch
(inFile);


stri
ch;

;
<span class="keywd">輪</span>:=<a class="op_no_ul" href="#stats_Assignment"></a>getc<span class="func_no_ul">まで</span>ch<span class="keywd">=</span><span class="op_no_ul">&#39;\n&#39;</span><span class="stri">do</span>&amp;:=<span class="keywd">エンドループ</span><span class="op_no_ul"></span><span class="keywd"></span></pre><p>その<tt>&#39;<span class="keywd">輪</span>&#39;</tt>上記の例では、ファイルから文字を読み込み、それらの文字を<tt><span class="stri">&#39;\n&#39;</span></tt>が読み込まれます。 その<tt><span class="stri">&#39;\n&#39;</span></tt>ループを終了します。 したがって、文字列には追加されません。 を使用しない同等のソリューション<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は次のようになります。<p><pre class="indent">
ch
(inFile);


stri
ch;

;

;
<span class="keywd">繰り返す</span>:=<a class="op_no_ul" href="#stats_Assignment"></a>getc<span class="func_no_ul">if</span>ch<span class="keywd">&lt;></span><span class="op_no_ul">&#39;\n&#39;</span><span class="stri">その時</span>&amp;:=<span class="keywd">if終了</span>まで<span class="op_no_ul">ch</span>=<span class="keywd"></span>&#39;\n&#39;<span class="keywd"></span><span class="op_no_ul"></span><span class="stri"></span></pre><p>のS7SSD<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は:</p><pre class="indent">
$
25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.loop.().until.().do.().end.loop<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a></pre><p>S7SSDの詳細は<tt>&#39;<span class="keywd">構文</span>&#39;</tt>定義は後で説明します。 ここでは、S7SSDの中心である次の式に注目します。</p><pre class="indent">loop.().until.().do.().end.loop
</pre><p>構文を記述するために、ドットを削除するだけで次のようになります。</p><pre class="indent">loop()until()do()end loop
</pre><p>These are the keywords used in a<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>記号<tt>()</tt>は、式のプレースホルダとして機能します。 EBNFを使用すると<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は、次のように記述できます。</p><dl><dd>
          <tt>
        <dl>
    <dt>loop_statement::=</dt><dd>&#39;<span class="keywd">輪</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">まで</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">do</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">輪</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>EBNF記述では、などの非終端記号を多数使用できます。<tt>&#39;<a class="ebnf" href="#stats_ebnf_statement">声明</a>&#39;</tt>または<tt>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;</tt>S7SSDでは、異なる非終端記号を区別しません。 代わりにS7SSDは1つの非終端シンボルしか知りません:<tt>()</tt></p><p>したがって、S7SSDでは<tt>&#39;<a class="ebnf" href="#stats_ebnf_statement">声明</a>&#39;</tt><tt>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;</tt>あるいは他の何かです 構文レベルでは、どんな種類の式でもS7SSD非終端記号に置き換えることができます。<tt>()</tt>EBNFでは、式の型などの制約を記述することができます。 S7SSDでは、このような制約を検証するためにセマンティックチェックに依存しています。 S7SSDを<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>のような表現</p><pre class="indent">








<span class="keywd">輪</span>「X」<span class="stri">まで</span>1+2<span class="keywd">do</span>整数<span class="keywd">エンドループ</span><a class="type" href="#types_integer"></a><span class="keywd"></span></pre><p>必要なキーワードを含んでいるので、合法である</p><pre class="indent"><span class="keywd">輪</span><span class="keywd">まで</span><span class="keywd">do</span><span class="keywd">終わり</span><span class="keywd">輪</span></pre><p>と表現</p><pre class="indent"><span class="stri">「X」</span>1+2<a class="type" href="#types_integer">整数</a></pre><p>その場所で<tt>()</tt>記号。 これは構文定義で指定されているものとまったく同じですが<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>章の最初に。 の場所で使用できる式のタイプを決定するには<tt>()</tt>記号、の意味定義<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>必要です。 意味定義は、構文定義からのキーワードおよびパラメータを使用する単なる関数定義です。 の定義<tt>&#39;<span class="keywd">輪</span>&#39;</tt>関数(関数の意味定義)<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>)は:</p><pre class="indent">:loop
(
:ステートメント1)
まで(
:condition)do
(
:ステートメント2)
エンドループ




FALSE;




statements1;


statements2;


exitLoop:=TRUE;

;

exitLoop;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>で<span class="keywd"></span>proc<a class="type" href="#types_proc">で</a><span class="keywd">機能</span><a class="type" href="#types_func">ブール</a>で<a class="type" href="#types_boolean"></a>proc<span class="keywd">is func</span>地域の<a class="type" href="#types_proc">var</a><span class="keywd">ブール</span>:exitLoop<span class="keywd">は</span>begin<span class="keywd">繰り返す</span>if<a class="type" href="#types_boolean"></a>ない<span class="keywd">状態</span>その時<span class="keywd">else</span>if終了<span class="keywd">まで</span>関数終了<span class="keywd"></span><span class="op"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>この定義により、キーワード間で使用できる式の型が決まります。 それに加えて<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は単なる普通の関数定義である。 この関数定義のヘッダーにあるキーワードおよびパラメータの順序は、対応する構文定義によって決定されることに注意してください。</p><p>パラメータ<tt>&#39;statements1&#39;</tt><tt>&#39;condition&#39;</tt>および<tt>&#39;statements2&#39;</tt>は名前による呼び出しのパラメータである。 名前渡しパラメータとは、パラメータのない関数のことである。 次のような関数タイプ<tt><a class="type" href="#types_proc">proc</a></tt>または<tt><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a></tt>は正式な名前による呼び出しパラメータの型として使用される。 正しい型の式を実際の名前呼び出しパラメータとして使用できます。 実パラメータ式は、関数が呼び出されたときに評価されません。 その代わり、正式なcall-by-nameパラメータが使用されるたびに式が評価されます。 こうして<tt>&#39;statements1&#39;</tt><tt>&#39;condition&#39;</tt>および<tt>&#39;statements2&#39;</tt>が実行されない。<tt>&#39;<span class="keywd">輪</span>&#39;</tt>関数が呼び出された後に行われます の本体内部<tt>&#39;<span class="keywd">輪</span>&#39;</tt>関数の名前による呼び出しパラメータがいくつかの場所で実行される。</p><p>その<tt>&#39;<span class="keywd">輪</span>&#39;</tt>関数は<a class="link" href="#stats_repeat-statement">repeat-</a>および<a class="link" href="#stats_if-statement">if文</a>目的の動作を実装します。 必要に応じて、名前による呼び出しパラメータが複数回実行されます。</p><p>For the<tt>&#39;<span class="keywd">輪</span>&#39;</tt>例では、セマンティックエラー(上記参照)があると、次のようなエラーメッセージが表示されます。</p><pre class="indent">
***chkloop.sd7(35):57:

<a class="link" href="#errors_NO_MATCH">{1+2}do integer end loop}までの{loop&quot;X&quot;の一致が失敗しました</a></pre><p></p>
          <a name="syntax_Priority_and_associativity">
        <h3>9.4優先順位と結合性</h3>
          </a>
        <p>構文構造が最初の記号の前または最後の記号の後にパラメータを持つ場合、構造の優先順位と結合性が重要になります。 優先順位の強いコンストラクトは、優先順位の弱いコンストラクトよりも先にパラメータをバインドする。 優先度は、自然数(0含む)で記述する。 最強優先順位は0です。 数値が大きいほど優先度が低いことを示す。 bindの意味は、次の例で説明できます。</p><pre class="box">=
A=B+C*D/\
A+
*priority 6/\
+priority 7 B*
=priority 12/\
C D
</pre><p>*演算子は、関連するすべての演算子の中で最も強い優先度(6)を持ちます。 したがって<tt><span class="op">*</span></tt>は最初にパラメータを取り込みます。 次に<tt><span class="op">+</span></tt>(優先順位7)、最後に<tt><span class="op">=</span></tt>(優先順位12)が続きます。 このことから、この表現は次のように解釈される。</p><pre class="indent">A=(B+(C*D))
</pre><p>連想性は、同じ優先度を持つ構造体がどの順序でパラメータをバインドするかを記述する。 例:</p><pre class="indent">A-B-C
</pre><p>は、次の2通りの方法で解釈できます。</p><pre class="indent">(A-B)-CまたはA-(B-C)
</pre><p>最初の解釈は通常数学者に好まれ、結合性とともに記述される<tt><a class="op_no_ul" href="#syntax_left_associative">-></a></tt>一般に、4つの関連性が可能である。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

    <tr><th align="left">関連性</th><th>シンボル</th></tr>

    <tr><td>
          <a name="syntax_left_associative">とじ方(左から右)</a>
        </td><td align="center">
          <tt>
            <span class="op">-></span>
          </tt>
        </td></tr>

    <tr><td>
          <a name="syntax_right_associative">とじ方(右から左)</a>
        </td><td align="center">
          <tt>
            <span class="op">&lt;-</span>
          </tt>
        </td></tr>

    <tr><td>左または右パラメータのいずれも同じ優先度を持つことはできません。</td><td align="center">
          <tt>
            <span class="op">&lt;-></span>
          </tt>
        </td></tr>

    <tr><td>左側には左から右への製本があり、右側には右から左への製本があります。</td><td align="center">
          <tt>
            <span class="op">->&lt;-</span>
          </tt>
        </td></tr>

</table></dd></dl><p>最後の2つの可能性は、減算の例では法解釈がありません。 第3の自動調整機能(<tt><span class="op">&lt;-></span></tt>)は、等号演算子(<tt><span class="op">=</span></tt>のような表現があるので、パスカルの</p><pre class="indent">A=B=C
</pre><p>は違法です。</p><p>結合性を説明する第2の方法があります。 結合規則は、オペランドの優先順位を演算子の優先順位よりも高くしなければならないかどうかを規定しています。 例:</p><pre class="box">
-7
A-B-C/\/\
/\&lt;=7/\&lt;7
-priority 7
/\/\
-C 7 0
/\/\
/\&lt;=7/\&lt;7
/\/\
A B 0 0
<a class="op_no_ul" href="#syntax_left_associative">-></a></pre><p>右側のツリーのノードの数字は、各部分式(サブツリー)の優先度を示します。 有<tt><span class="op">&lt;</span></tt>および<tt><span class="op">&lt;=</span></tt>オペランドの優先順位の必要条件を記述します。 これらの条件がすべて満たされている場合、通訳は合法です。 二つ以上の法的解釈が存在するか、あるいは法解釈が存在しない場合、その式は違反である。</p><p>関連性の可能性に関する表:</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

    <tr><th rowspan="2">結合性</th><th align="center" colspan="2">の優先順位。</th></tr>

    <tr><th align="center">左オペランドは</th><th align="center">右オペランドは</th></tr>

    <tr><td align="center">
          <tt>
            <a class="op_no_ul" href="#syntax_left_associative">-></a>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;=</span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;</span>
          </tt>
        </td></tr>
    <tr><td align="center">
          <tt>
            <a class="op_no_ul" href="#syntax_right_associative">&lt;-</a>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;</span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;=</span>
          </tt>
        </td></tr>
    <tr><td align="center">
          <tt>
            <span class="op">&lt;-></span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;</span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;</span>
          </tt>
        </td></tr>
    <tr><td align="center">
          <tt>
            <span class="op">->&lt;-</span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;=</span>
          </tt>
        </td><td align="center">
          <tt>
            <span class="op">&lt;=</span>
          </tt>
        </td></tr>

    <tr><td> </td><td align="center" colspan="2">オペレーターのそれより</td></tr>

</table></dd></dl><p>演算子記号の前のパラメータは、左オペランドと呼ばれます。 構造の最後の記号の後のパラメータは、右オペランドと呼ばれます。 通常の演算子の場合、数式要素の最後の記号と演算子記号は同一である。 そうでない場合には、第三の種類のオペランドがあります。 演算子記号と数式要素の最後の記号の間には、中間オペランドがあります。 中間オペランドの優先順位は任意です。</p>
          <a name="syntax_The_syntax_of_operators">
        <h3>9.5演算子の構文</h3>
          </a>
        <p>構文定義は、文または演算子の用法を記述する方法を指定します。 たとえば<tt><span class="keywd">ない</span></tt>演算子は次のようになります。</p><pre class="indent">わかった
<span class="op">ない</span></pre><p>の構文の説明<tt><span class="keywd">ない</span></tt>演算子私たちはこう書きます:</p><pre class="indent">
$
13;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.not.()<span class="keywd">は</span><a class="op_no_ul" href="#syntax_right_associative">&lt;-</a></pre><p>これは<tt><span class="keywd">ない</span></tt>式はシンボルで作成される<tt><span class="keywd">ない</span></tt>その後にパラメータが続く。 パラメータの位置には()記号が付いています。 構文記述に、パラメータの型に関する情報が含まれていません。 構文レベルでは、パラメータは何でもかまいません。 有<tt><a class="op_no_ul" href="#syntax_right_associative">&lt;-</a></tt>の結合性<tt><span class="keywd">ない</span></tt>演算子は右結合と指定されます。 これは、右オペランドが演算子記号と同じ優先度を持つことができることを意味する。 つまり、この表現は</p><pre class="indent">わかった
<span class="op">ない</span><span class="op">ない</span></pre><p>法的で手段である</p><pre class="indent">わかった)
<span class="op">ない</span>(<span class="op">ない</span></pre><p>の結合性が<tt><span class="keywd">ない</span></tt>演算子が<tt><a class="op_no_ul" href="#syntax_left_associative">-></a></tt>の代わりに<tt><a class="op_no_ul" href="#syntax_right_associative">&lt;-</a></tt>その<tt>&#39;<span class="op">ない</span><span class="op">ない</span>&#39;</tt>上記の式は不正です。 13で全体の優先度を<tt><span class="keywd">ない</span></tt>演算子を決定します。 慣例では、1～20の優先順位が演算子によって使用され、25がステートメントによって使用されます。 算術演算子の優先順位は1～11であり、比較の優先順位は12です。</p><p>を定義するには<tt><span class="keywd">ない</span></tt>演算子を完全に使用する場合は、次のような意味定義も必要です。</p><pre class="indent">



TRUE;




neation:=FALSE;

;

;
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:not(<span class="keywd">で</span><a class="type" href="#types_boolean">ブール</a>:aBool)<span class="keywd">is func</span>結果<span class="keywd">var</span><span class="keywd">ブール</span>:否定<a class="type" href="#types_boolean">は</a>begin<span class="keywd">if</span>aBool<span class="keywd">その時</span>if終了<span class="keywd">関数終了</span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>宣言の中で<tt><span class="keywd">ない</span></tt>operatorは、呼び出されたときとまったく同じように記述します。 宣言と呼び出しの両方で、構文定義が使用されています。 構文と意味宣言は<tt><span class="keywd">ない</span></tt>作業者が作業します。</p><p>次の例では<tt><span class="keywd">および</span></tt>オペレータ。 のコール<tt><span class="keywd">および</span></tt>演算子は次のようになります。</p><pre class="indent">
わかった
間違い
<span class="op">および</span><span class="op">ない</span></pre><p>の構文の説明<tt><span class="keywd">および</span></tt>演算子私たちはこう書きます:</p><pre class="indent">
$
->14;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.().および.()<span class="keywd">は</span></pre><p>これは<tt><span class="keywd">および</span></tt>式はシンボルで作成される<tt><span class="keywd">および</span></tt>パラメータで囲まれています。 その<tt><span class="op">-></span></tt>を定義する。<tt><span class="keywd">および</span></tt>演算子を左結合に設定します。 これは、次のような式があることを意味します。</p><pre class="indent">
A
C
<span class="op">および</span>B<span class="op">および</span></pre><p>は次のように解釈され</p><pre class="indent">
(A
C
<span class="op">および</span>B)<span class="op">および</span></pre><p>全体の優先順位は14である<tt><span class="keywd">および</span></tt>演算子を決定します。 優先順位14は<tt><span class="keywd">ない</span></tt>これは13なので、サンプルの式は次のように評価されます。</p><pre class="indent">
わかった
エラー)
<span class="op">および</span>(<span class="op">ない</span></pre><p>式</p><pre class="indent">
わかった
間違い
<span class="op">および</span><span class="op">ない</span></pre><p>が<tt><span class="keywd">および</span></tt>演算子の優先順位は14ではなく12です。</p><p>S7SSDでは、すべてが演算子記述として扱われます。 演算子には優先順位と結合性があります。 優先順位と結合規則によって、どの継承にS7SSD構文規則が適用されるかが決まります。 優先順位と結合性を説明するために、基本的な算術演算(+、-、*、/)を使用します。 これらをEBNFで記述するには、次のように記述します。</p><dl><dt></dt><dd>
          <tt>
        <dl>
    <dt>factor::=</dt><dd>番号名。</dd>

    <dt>式_5::=</dt><dd>factor(&#39;+&#39;式_5)<br />(&#39;-&#39;expression_5)。</dd>

    <dt>式_6::=</dt><dd>式_5<br />(expression_6&#39;*&#39;expression_7)<br />(expression_6&#39;/&#39;expression_7).</dd>

    <dt>式_7::=</dt><dd>式_6<br />(expression_7&#39;+&#39;expression_6)<br />(expression_7&#39;-&#39;expression_6).</dd>
</dl>
          </tt>
        </dd></dl><p>これは、以下のことを説明しています。</p><ul>
    <li>演算子の優先順位は異なります。<ul>
      <li>プラス記号とマイナス記号が最初に実行されます。</li>
      <li>乗算と除算が二番目に実行される。</li>
      <li>最後に加算と減算が行われる。</li></ul></li>

    <li>これらの優先順位は、まさに算術式に期待されるものです。</li>

    <li>さらに、++2が許可され、+(+(2))と解釈されることがわかります。これは、プラス記号が右結合演算子であることを意味します。</li>

    <li>また、a*b*cが許可され、(a*b)*cと解釈されることもわかります。これは、乗算が左結合演算子であることを意味します。</li>
</ul><p>これらはすべてS7SSDでも説明できます。</p><pre class="indent">
$
5;
$
5;
$
6;
$
6;
$
7;
$
7;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:. +.()は<a class="op_no_ul" href="#syntax_right_associative">&lt;-</a>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:. -.()は</a>&lt;-<a class="op_no_ul" href="#syntax_right_associative">構文</a><span class="keywd">expr</span>:.(). *.()は<a class="type" href="#types_expr">-></a>構文<a class="op_no_ul" href="#syntax_left_associative"></a>expr<span class="keywd">:.()./.()は</span>-><a class="type" href="#types_expr">構文</a><a class="op_no_ul" href="#syntax_left_associative">expr</a>:.(). +.()は<span class="keywd">-></span>構文<a class="type" href="#types_expr"></a>expr<a class="op_no_ul" href="#syntax_left_associative">:.(). -.()は</a>-><span class="keywd"></span><a class="type" href="#types_expr"></a><a class="op_no_ul" href="#syntax_left_associative"></a></pre><p>S7SSDは、EBNFの説明としては短いことがわかります。 以下に、構文を説明します。</p><ul>
    <li>$はすべてのハードコードされたステートメントを導入するために使用されます。</li>

    <li>キーワード<tt>&#39;<span class="keywd">構文</span>&#39;</tt>は構造化構文記述を導入します。</li>

    <li>認識された式の結果は<tt><a class="type" href="#types_expr">expr</a></tt>型式<tt><a class="type" href="#types_expr">expr</a></tt>は、構文と意味解析の間で使用されます。 型式<tt><a class="type" href="#types_expr">expr</a></tt>構文的には分析されるが、意味的には分析されない表現を記述する。 意味解析後(および実行時)のタイプ<tt><a class="type" href="#types_expr">expr</a></tt>は使用されません。</li>

    <li>コロン「:」は、タイプと構文記述の間のセパレータとして使用されます。</li>

    <li>次のようなドット式<tt>&#39;.(). *.()&#39;</tt>は(名前から推測できるように)ドットで導入されます。 構文を説明するために、頭の中の点を削除することができます。<tt>&#39;()*()&#39;</tt></li>

    <li>シンボルは<tt>&#39;<span class="keywd">は</span>&#39;</tt>は、すべてのSeed7宣言で名前と値の間のセパレータとして使用されます。</li>

    <li>結合性はシンボルの1つとともに記述されます。<tt>-></tt>(左結合)<tt>&lt;-</tt>(右結合)<tt>&lt;-></tt>(関連しない)および<tt>->&lt;-</tt>(両方とも関連性)。 の場合のように、左右のオペランドがない場合<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>関連性は関係ありません。</li>

    <li>最後に、構文構成体の優先度は、次のような整数リテラルで定義されます。<tt>&#39;6&#39;</tt>・優先度<tt>&#39;6&#39;</tt>演算子に使用される<tt><span class="keywd">*</span></tt><tt><span class="keywd">/</span></tt><tt><span class="keywd">div</span></tt><tt><span class="keywd">レム</span></tt><tt><span class="keywd">mdiv</span></tt>および<tt><span class="keywd">mod</span></tt></li>
</ul><p></p>
          <a name="syntax_Syntax_of_predefined_statements">
        <h3>9.6事前定義済ステートメントの構文</h3>
          </a>
        <p>定義済みステートメントは、S7SSDで定義することもできます。 例:<a class="link" href="#stats_while-statement">while文</a>A use of the<a class="link" href="#stats_while-statement">while文</a>は:</p><pre class="indent">
processElement;
write(
);

;
<span class="keywd">一方で</span>element_index>0<span class="op">および</span>わかった<span class="keywd">do</span>&quot;.&quot;<span class="stri">whileを終了する</span><span class="keywd"></span></pre><p>の構文の説明<a class="link" href="#stats_while-statement">while文</a>本文:</p><pre class="indent">
$
25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:while.().do.().end.while<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a></pre><p>これは<a class="link" href="#stats_while-statement">while文</a>は、次の記号を含む式です。<tt>&#39;<span class="keywd">一方で</span>&#39;</tt><tt>&#39;<span class="keywd">do</span>&#39;</tt><tt>&#39;<span class="keywd">終わり</span>&#39;</tt>および<tt>&#39;<span class="keywd">一方で</span>&#39;</tt>with<tt><span class="op">-></span></tt>の結合性<a class="link" href="#stats_while-statement">while文</a>左結合として指定されます。 関連性は意味を持ちません<a class="link" href="#stats_while-statement">while文</a>最初のシンボルの前や最後のシンボルの後にはパラメータがないからである。 全体の優先性<a class="link" href="#stats_while-statement">while文</a>は25です。</p><p>の意味的定義<a class="link" href="#stats_while-statement">while文</a>は次のとおりです。</p><pre class="indent">:condition)do
(





文;


文;

;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:while(<span class="keywd">で</span>機能<a class="type" href="#types_boolean">ブール</a>で<span class="keywd"></span>proc<a class="type" href="#types_proc">:statement)end while</a>is func<span class="keywd">begin</span>if<span class="keywd">状態</span>その時<span class="keywd">一方で</span>状態<span class="keywd">do</span>whileを終了する<span class="keywd">if終了</span>関数終了<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>宣言と発呼にこのシンタックス定義を使います。 この宣言は<a class="link" href="#stats_while-statement">while文</a>動作します。 これは<a class="link" href="#stats_if-statement">if文</a>再帰を使用してループ本体の繰り返しをエミュレートします。 構文記述の別の例として<a class="link" href="#stats_repeat-statement">反復文</a></p><pre class="indent">
processElement;
write(
);

わかった;
<span class="keywd">繰り返す</span>&quot;.&quot;<span class="stri">まで</span>element_index=0<span class="keywd">または</span><span class="op">ない</span><span class="op"></span></pre><p>これには、次の構文説明があります。</p><pre class="indent">
$
25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.repeat.().until.()<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a></pre><p>これは<a class="link" href="#stats_repeat-statement">反復文</a>は、次の記号を含む式です。<tt>&#39;<span class="keywd">繰り返す</span>&#39;</tt>および<tt>&#39;<span class="keywd">まで</span>&#39;</tt>との間のパラメータ<tt>&#39;<span class="keywd">繰り返す</span>&#39;</tt>および<tt>&#39;<span class="keywd">まで</span>&#39;</tt>以降<tt>&#39;<span class="keywd">まで</span>&#39;</tt>25を全体の優先順位とする<a class="link" href="#stats_repeat-statement">反復文</a>が決定される。 有<tt><span class="op">-></span></tt>の結合性<a class="link" href="#stats_repeat-statement">反復文</a>左結合として指定されます。 これにより、後ろのパラメータに0から24までの優先順位を付けることができる。<tt>&#39;<span class="keywd">まで</span>&#39;</tt>文には優先順位25があるため、直後に文を書くことはできません。<tt>&#39;<span class="keywd">まで</span>&#39;</tt></p><p>A simple<a class="link" href="#stats_if-statement">if文</a>なし<tt>&#39;<span class="keywd">elsif</span>&#39;</tt>は、次の例です。 これの使い方<a class="link" href="#stats_if-statement">if文</a>以下のようになります。</p><pre class="indent">
writeln(
);


writeln(
);

;
<span class="keywd">if</span>わかった<span class="keywd">その時</span>&quot;わかった&quot;<span class="stri">else</span>「よくない」<span class="keywd">if終了</span><span class="stri"></span><span class="keywd"></span></pre><p>構文記述として使用する</p><pre class="indent">
$
25;
$
25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.if.().then.().end.if<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.if.().then.().else.().end.if</a>は<span class="keywd"></span>-><a class="op_no_ul" href="#syntax_left_associative"></a></pre><p>この説明では<a class="link" href="#stats_if-statement">if文</a>有無<tt>&#39;<span class="keywd">else</span>&#39;</tt>部品。 意味記述として使用するのは</p><pre class="indent">:condition)then
(
:statement)
if終了






{TRUE}:文;

;

;


:condition)then
(
:statement1)
else
(
:statement2)
if終了




状態

{TRUE}:statement1;

{FALSE}:statement2;

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:if(<span class="keywd">で</span><a class="type" href="#types_boolean">ブール</a>で<span class="keywd"></span>proc<a class="type" href="#types_proc">is func</a>begin<span class="keywd">ケース</span>状態<span class="keywd">の</span>いつ<span class="keywd">格を終わらせる</span>関数終了<span class="keywd">const</span>proc:if(<span class="keywd">で</span><span class="keywd">ブール</span>で<span class="keywd"></span>proc<span class="keywd">で</span><span class="keywd">proc</span>is func<a class="type" href="#types_boolean">begin</a>ケース<span class="keywd">いつ</span>いつ<a class="type" href="#types_proc">格を終わらせる</a>関数終了<span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre><p>2つの形式の<a class="link" href="#stats_if-statement">if文</a>は<a class="link" href="#stats_case-statement">判決理由陳述書</a>より複雑な<a class="link" href="#stats_if-statement">if文</a>で<tt>&#39;<span class="keywd">elsif</span>&#39;</tt>partsには次のものがあります。</p><pre class="indent">
write(
);


write(
);


write(
);

;
<span class="keywd">if</span>数値&lt;0<span class="keywd">その時</span>「より少ない」<span class="stri">elsif</span>数値=0<span class="keywd">その時</span>「等しい」<span class="keywd">else</span>&quot;greater&quot;<span class="stri">if終了</span><span class="keywd"></span><span class="stri"></span><span class="keywd"></span></pre><p>この文の構文や語義の定義方法については、次章で説明します。</p>
          <a name="syntax_Advanced_syntax_definitions">
        <h3>9.7高度な構文定義</h3>
          </a>
        <p>ある場所でのみ許可される特別な構文を使用したい場合は、次のようにします。</p><ul>
    <li>S7SSDの特別な構文は、他の構文定義と矛盾しないように定義してください。</li>

    <li>意味定義を使用して、この構文構造が希望する場所でのみ使用できるようにします。</li>
</ul><p>のEBNF<a class="link" href="#stats_if-statement">if文</a>で<tt>&#39;<span class="keywd">elsif</span>&#39;</tt>partsは次のとおりです。</p><dl><dd>
          <tt>
        <dl>
    <dt>if_statement::=</dt><dd>&#39;<span class="keywd">if</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />{&#39;<span class="keywd">elsif</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>}<br />[&#39;<span class="keywd">else</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a>]<br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">if</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>このS7SSDは<a class="link" href="#stats_if-statement">if文</a>は:</p><pre class="indent">
$
25;
$
25;

$
60;
$
60;
$
60;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.if.().then.().end.if<span class="keywd">は</span><a class="op_no_ul" href="#syntax_left_associative">-></a>構文<span class="keywd"></span>expr<a class="type" href="#types_expr">:.if.().then.().().end.if</a>は<span class="keywd"></span>-><a class="op_no_ul" href="#syntax_left_associative">構文</a><span class="keywd">expr</span>:.elsif.().then.()<a class="type" href="#types_expr">は</a><span class="keywd">&lt;-</span>構文<a class="op_no_ul" href="#syntax_right_associative"></a>expr<span class="keywd">:.elsif.().then.().()</span>は<a class="type" href="#types_expr"></a>&lt;-<span class="keywd">構文</span><a class="op_no_ul" href="#syntax_right_associative">expr</a>:.else.()<span class="keywd">は</span><a class="type" href="#types_expr">&lt;-</a><span class="keywd"></span><a class="op_no_ul" href="#syntax_right_associative"></a></pre><p>EBNFのように1つのルールではなく、複数のS7SSDルールに分割される。 S7SSDでは[]および{}の表記がサポートされていないため、この処理が必要になります。 次のような理由でサポートされていません。 それらはパラメータリストを複雑にし、実装もそれほど簡単ではありません。 一方、S7SSDのBNFのようなルールは、解析しやすく、コンパイルしやすい意味構造をもたらします。 S7SSDルールの詳細<a class="link" href="#stats_if-statement">if文</a>は、次のEBNF記述に対応します。</p><dl><dd>
          <tt>
        <dl>
    <dt>if_statement::=</dt><dd>&#39;<span class="keywd">if</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">if</span>&#39;.</dd>
<dt>
          <br />
        </dt>
    <dt>if_statement::=</dt><dd>&#39;<span class="keywd">if</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />elseif_or_else_part<br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">if</span>&#39;.</dd>
<dt>
          <br />
        </dt>
    <dt>elseif_or_else_part::=</dt><dd>&#39;<span class="keywd">elsif</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a></dd>
<dt>
          <br />
        </dt>
    <dt>elseif_or_else_part::=</dt><dd>&#39;<span class="keywd">elsif</span>&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;<span class="keywd">その時</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a><br />elseif_or_else_part.</dd>
<dt>
          <br />
        </dt>
    <dt>elseif_or_else_part::=</dt><dd>&#39;<span class="keywd">else</span>&#39;<br /><a class="ebnf" href="#stats_ebnf_statement">声明</a></dd>
</dl>
          </tt>
        </dd></dl><p>S7SSDは非終端記号を1つしか使わないので<tt>&#39;()&#39;</tt>正しい非終端記号のみが使用できるようにするのが、意味レベルの仕事です。 これは、タイプ<tt><span class="type">ELSIF_PROC</span></tt>(これは非終端記号<tt>&#39;elseif_or_else_part&#39;</tt>EBNFの)とタイプ<tt><span class="type">ELSIF_RESULT</span></tt>(これは<tt><span class="type">ELSIF_PROC</span></tt>)。</p><p>通常、構文宣言は多くの意味宣言で使用できます。 例:<tt>&#39;+&#39;</tt>演算子は一度定義され<tt>&#39;+&#39;</tt>タイプの演算子が定義されます。<tt><a class="type" href="#types_integer">整数</a></tt><tt><a class="type" href="#types_bigInteger">bigInteger</a></tt><tt><a class="type" href="#types_float">浮かぶ</a></tt><tt><a class="type" href="#types_integer">複雑なさま</a></tt>,.この可能性は<a class="link" href="#stats_if-statement">if文</a>の5つのS7SSD構文規則のそれぞれについて<a class="link" href="#stats_if-statement">if文</a>対応する意味宣言が1つだけ実行されます。</p><pre class="indent">:condition)then
(
:ステートメント)
if終了






{TRUE}:ステートメント;

;

;




:condition)then
(
:ステートメント)
(
:elsifPart)
if終了






{TRUE}:ステートメント;

{FALSE}:elsiffPart;

;

;




:condition)then
(






{TRUE}:ステートメント;

;

;




:condition)then
(
:ステートメント)
(






{TRUE}:ステートメント;

{FALSE}:elsiffPart;

;

;




:else
(
ELSIF_EMPTY;
<span class="comment">#Semantic for the syntax:.if.().then.().end.if</span>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:if(</a>で<span class="keywd"></span>ブール<a class="type" href="#types_boolean">で</a><span class="keywd">proc</span>is func<a class="type" href="#types_proc">begin</a>ケース<span class="keywd">状態</span>の<span class="keywd">いつ</span>格を終わらせる<span class="keywd">関数終了</span>#構文の意味:.if.().then.().().end.if<span class="keywd">const</span><span class="keywd">proc</span>:if(<span class="keywd">で</span><span class="keywd">ブール</span>で<span class="comment"></span>proc<span class="keywd">で</span><a class="type" href="#types_proc">ELSIF_PROC</a>is func<span class="keywd">begin</span>ケース<a class="type" href="#types_boolean">状態</a>の<span class="keywd">いつ</span>いつ<a class="type" href="#types_proc">格を終わらせる</a>関数終了<span class="keywd">#構文の意味:.elsif.().then.()</span>const<span class="type"></span>ELSIF_PROC<span class="keywd">:elsif(</span>で<span class="keywd"></span>ブール<span class="keywd">で</span><span class="keywd">proc</span>:ステートメント)<span class="keywd">is func</span>begin<span class="keywd">ケース</span>状態<span class="keywd">の</span>いつ<span class="keywd">格を終わらせる</span>関数終了<span class="comment">#構文の意味:.elsif.().then.().()</span>const<span class="keywd"></span>ELSIF_PROC<span class="type">:elsif(</span>で<span class="keywd"></span>ブール<a class="type" href="#types_boolean">で</a><span class="keywd">proc</span>で<a class="type" href="#types_proc"></a>ELSIF_PROC<span class="keywd">:elsifPart)</span>is func<span class="keywd">begin</span>ケース<span class="keywd">状態</span>の<span class="keywd">いつ</span>いつ<span class="keywd">格を終わらせる</span>関数終了<span class="keywd">#構文の意味:.else.()</span>const<span class="keywd"></span>ELSIF_PROC<span class="comment">参照</span><span class="keywd">無</span>:voidValue)<span class="type">は</span><span class="keywd"></span><a class="type" href="#types_boolean"></a><span class="keywd"></span><a class="type" href="#types_proc"></a><span class="keywd"></span><span class="type"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="comment"></span><span class="keywd"></span><span class="type"></span><span class="keywd"></span><a class="type" href="#types_void"></a><span class="keywd"></span></pre><p>他のタイプの関数<tt>&#39;<span class="type">ELSIF_PROC</span>&#39;</tt>合法的であるとのみ定義される<a class="link" href="#stats_if-statement">if文</a>書くことができる。</p>
          <a name="syntax_Comparison_of_EBNF_and_S7SSD">
        <h3>9.8 EBNFとS7SSDの比較</h3>
          </a>
        <p>のS7SSDに<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a></p><pre class="indent">
$
->25;
<span class="keywd">構文</span><a class="type" href="#types_expr">expr</a>:.loop.().until.().do.().end.loop<span class="keywd">は</span></pre><p>は非終端表現ではない<tt>&#39;()&#39;</tt>最初のキーワードの前、または最後のキーワードの後。 したがって、結合性は何の役割も果たしません。 非終端表現<tt>&#39;()&#39;</tt>の<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>はすべてキーワードで囲まれているため、任意の優先度を持つことができます。 の優先度として<tt>&#39;<span class="keywd">輪</span>&#39;</tt>25が選択されるのは、他のほとんどのステートメントの優先順位も25だからです。 割り当て(:=+:=*:=.)の優先順位は20で、算術、ブール式、および文字列式で使用されるすべての演算子の優先順位は20未満です。 ちなみに:セミコロン演算子(;)は優先度50で定義されています。 優先順位が0の演算子は、優先順位が1の演算子よりも先にパラメータを取得します。</p><p>対応するEBNF記述<a class="link" href="#syntax_The_syntax_of_a_statement">ループ文</a>は次のようになります。</p><dl><dd>
          <tt>
        <dl>
    <dt>式_25::=</dt><dd>&#39;<span class="keywd">輪</span>&#39;<br />式_127<br />&#39;<span class="keywd">まで</span>&#39;expression_127&#39;<span class="keywd">do</span>&#39;<br />式_127<br />&#39;<span class="keywd">終わり</span>「」<span class="keywd">輪</span>&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>expression_25には別のルールも可能であり、すべての優先度レベルに対して次のようなルールがあることに注意しなければなりません。</p><dl><dd>
          <tt>
        <dl>
    <dt>expression_127::=</dt><dd>式_126。</dd>
</dl>
          </tt>
        </dd></dl><p>が定義されます。 さらに、次のルールが定義されています。</p><dl><dd>
          <tt>
        <dl>
    <dt>式_0::=</dt><dd>トークンかっこ_式<br />call_expression dot_expression.</dd>
<dt>
          <br />
        </dt>
    <dt>token::=</dt><dd>識別子リテラル。</dd>
<dt>
          <br />
        </dt>
    <dt>parentheses_expression::=</dt><dd>&#39;(&#39;expression_127&#39;)&#39;</dd>
<dt>
          <br />
        </dt>
    <dt>call_expression::=</dt><dd>expression_127[&#39;(&#39;<br />[expression_127{&#39;,&#39;expression_127}]<br />&#39;)&#39;]。</dd>
<dt>
          <br />
        </dt>
    <dt>dot_expression::=</dt><dd>[&#39;.&#39;]call_expression{&#39;.&#39;call_expression}.</dd>
</dl>
          </tt>
        </dd></dl><p>EBNFの記述は、Seed7の場合のように、存在する優先レベルが多いと長くなる可能性があります。</p><p>S7SSDのスコープから外れるものもあります。 構文<a class="link" href="#tokens_Comments">コメント</a>、トークン(<a class="link" href="#tokens_Identifiers">識別子</a>および<a class="link" href="#tokens_Literals">直定数</a>)や式(括弧、関数呼び出し、ドット式)はハードコードされます。 ハードコードされた構造体は<a class="link" href="#tokens_file_start">第10章(トークン)</a>および<a class="link" href="#expr_file_start">第11章(式)</a></p><p>上記の理由により、すべてのEBNF構文記述をS7SSDに変換することは不可能です。 S7SSD記述のEBNFへの変換は常に可能です。</p><p>S7SSDの利点は,その単純さと高速自動構文認識アルゴリズムが容易に実装できることにある。 これを成功させるのは、まさにハードコードされた構文認識と柔軟な構文規則の組み合わせです。</p>
          <a name="tokens_file_start"></a>
        <p></p>
          <a name="tokens_TOKENS">
        <h2>10トークン</h2>
          </a>
        <p>プログラムは、空白で区切られた一連のトークンで構成されます。 トークンには次の2種類があります。</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_literal">文字通りの</a>s</dd>
</dl><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt>program::=</dt><dd>{<a class="ebnf" href="#tokens_ebnf_white_space">白いスペース</a><a class="ebnf" href="#tokens_ebnf_token">象徴</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_token">象徴</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_identifier">識別子</a><a class="ebnf" href="#tokens_ebnf_literal">文字通りの</a></dd>
</dl>
          </tt>
        </dd></dl><p>空白文字またはトークン文字のいずれも使用されていない文字は<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***tst255.sd7(1):3:

(*使用できない文字*)\b
-----------------------^
<a name="tokens_CHAR_ILLEGAL_example"></a><a class="link" href="#errors_CHAR_ILLEGAL">テキスト&quot;\8;&quot;に不正な文字(U+0008)</a></pre>
          <a name="tokens_White_space">
        <h3>10.1空白</h3>
          </a>
        <p>ホワイトスペースには次の3種類があります。</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_space">空間</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_comment">コメント</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_line_comment">行コメント</a>s</dd>
</dl><p>空白文字は常に直前の<a class="link" href="#tokens_Identifiers">識別子</a><a class="link" href="#tokens_Integer_literals">整数</a><a class="link" href="#tokens_BigInteger_literals">bigInteger</a>または<a class="link" href="#tokens_Float_literals">浮かぶ</a>リテラル。 隣接したトークンを区切るために空白が必要です。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_white_space">白いスペース</a>::=</dt><dd>(<a class="ebnf" href="#tokens_ebnf_space">空間</a><a class="ebnf" href="#tokens_ebnf_comment">コメント</a><a class="ebnf" href="#tokens_ebnf_line_comment">行コメント</a>)<br />{<a class="ebnf" href="#tokens_ebnf_space">空間</a><a class="ebnf" href="#tokens_ebnf_comment">コメント</a><a class="ebnf" href="#tokens_ebnf_line_comment">行コメント</a>}。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Spaces">
        <h4>10.1.1スペース</h4>
          </a>
        <p>スペース文字には、トークンを区切る場合以外は無視されるものがいくつかあります。</p><dl><dd>空白、水平タブ、復改、改行。</dd></dl><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_space">空間</a>::=</dt><dd>「TAB CR NL.</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Comments">
        <h4>10.1.2コメント</h4>
          </a>
        <p>コメントは、次の文字で始まります。<span class="comment">(*で始まり、*で終わる)</span>例:</p><pre class="indent"><span class="comment">(*これはコメントです*)</span></pre><p>コメントは複数行にまたがることができ、コメントの入れ子も可能です。</p><pre class="indent">(*これは続くコメントです
次の行に(*、および*)*)

<span class="comment"></span></pre><p>これにより、それ自体がコメントを含む、プログラムのより大きなセクションをコメントアウトすることができます。 内にコメントを記述することはできません<a class="link" href="#tokens_String_literals">文字列</a>および<a class="link" href="#tokens_Character_literals">文字リテラル</a></p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_comment">コメント</a>::=</dt><dd>&#39;(*&#39;{<a class="ebnf" href="#tokens_ebnf_any_character">任意の文字</a>}&#39;*)&#39;</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_any_character">任意の文字</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_simple_literal_character">単純文字</a><a class="ebnf" href="#tokens_ebnf_apostrophe">アポストロフィ</a>&#39;&#39;&#39;&#39;\&#39;<br /><a class="ebnf" href="#tokens_ebnf_control_character">control_character</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_control_character">control_character</a>::=</dt><dd>NUL SOH STX ETX EOT ENQ ACK BEL<br />BS TAB LF VT FF CR SO SI<br />DLE DC1 DC2 DC3 DC4 NAK SYN ETB<br />CAN EMサブESC FS GS RS US<br />DEL</dd>
</dl>
          </tt>
        </dd></dl><p>メインファイルの最後でコメントが閉じられていない場合<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>がトリガーされます。</p><pre class="indent">
***tst256.sd7(2):4:&lt;a name=&quot;tokens_UNCLOSED_COMMENT_example&quot;&lt;

(※閉じていないコメント
</a><a class="link" href="#errors_UNCLOSED_COMMENT">閉じられていないコメント</a></pre>
          <a name="tokens_Line_comments">
        <h4>10.1.3行コメント</h4>
          </a>
        <p>行コメントは、次の文字で始まります。<span class="comment">#そして行末で終了します。</span><br />例:</p><pre class="indent"><span class="comment">#This is a comment</span></pre><p>内にコメントを記述することはできません<a class="link" href="#tokens_String_literals">文字列</a><a class="link" href="#tokens_Character_literals">性格</a>と数字直定数です。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_line_comment">行コメント</a>::=</dt><dd>&#39;#&#39;{<a class="ebnf" href="#tokens_ebnf_any_character">任意の文字</a>}NL</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Identifiers">
        <h3>10.2識別子</h3>
          </a>
        <p>識別子には次の3種類があります。</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_name_identifier">名前識別子</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_special_identifier">特別な識別子</a>s</dd>
    <dd>
          <a class="ebnf" href="#tokens_ebnf_bracket">大括弧</a>
        </dd>
</dl><p>識別子は隣接して書くことができる。ただし、2つの名前識別子の間、および2つの特殊識別子の間は空白で区切らなければならない。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_identifier">識別子</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_name_identifier">name_identifier</a><a class="ebnf" href="#tokens_ebnf_special_identifier">special_identifier</a><a class="ebnf" href="#tokens_ebnf_bracket">大括弧</a></dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Name_identifiers">
        <h4>10.2.1名前の識別子</h4>
          </a>
        <p>名前識別子は、一連の文字、数字、およびアンダースコア(_)です。 先頭文字は英字またはアンダースコアにする必要があります。 名前識別子の例を次に示します。</p><pre class="indent">NUMBER integer const if UPPER_LIMIT LowerLimit x5_end
</pre><p>大文字と小文字は違います。 名前識別子は任意の長さにでき、すべての文字が意味を持ちます。 名前識別子は、英字(または_)でも数字でもない文字で終了します。 終端文字が名前識別子の一部ではありません。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_name_identifier">name_identifier</a>::=</dt><dd>(<a class="ebnf" href="#tokens_ebnf_letter">手紙</a><a class="ebnf" href="#tokens_ebnf_underscore">強調する</a>){<a class="ebnf" href="#tokens_ebnf_letter">手紙</a><a class="ebnf" href="#tokens_ebnf_digit">指</a><a class="ebnf" href="#tokens_ebnf_underscore">強調する</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_letter">手紙</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_upper_case_letter">大文字</a><a class="ebnf" href="#tokens_ebnf_lower_case_letter">小文字</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_upper_case_letter">大文字</a>::=</dt><dd>「A」「B」「C」「D」「E」「F」「G」「H」「I」「J」<br />「K」「L」「M」「N」「O」「P」「Q」「R」「S」「T」<br />「U」「V」「W」「X」「Y」「Z」。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_lower_case_letter">小文字</a>::=</dt><dd>「a」「b」「c」「d」「e」「f」「g」「h」「i」「j」<br />「k」「l」「n」「o」「p」「q」「r」「t」<br />「u」「v」「w」「x」「y」「z」。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_digit">指</a>::=</dt><dd>「0」「1」「2」「3」「4」「5」「6」「7」「8」「9」です。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_underscore">強調する</a>::=</dt><dd>「_」。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Special_identifiers">
        <h4>10.2.2特殊識別子</h4>
          </a>
        <p>特殊識別子は、一連の特殊文字です。 特殊識別子の例を以下に示します。</p><pre class="indent">+:=&lt;= * ->、&amp;
</pre><p>以下は、すべての特殊文字のリストです。</p><pre class="indent">$%&amp;*+,-. /:;&lt; = >?@\^`~
</pre><p>特殊識別子の長さには制限がなく、すべての文字が有効です。 特殊識別子は特殊文字ではない文字で終了します。 終端文字が特別な識別子の一部ではありません。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_special_identifier">special_identifier</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_special_character">特殊文字</a>{<a class="ebnf" href="#tokens_ebnf_special_character">特殊文字</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_special_character">特殊文字</a>::=</dt><dd>&#39;!&#39;$&#39;&#39;%&#39;&#39;&amp;&#39;&#39;*&#39;&#39;+&#39;&#39;、&#39;&#39;-&#39;&#39;.&#39;&#39;/&#39;&#39;<br />&#39;:&#39;&#39;;&#39;&#39;&lt;&#39;&#39;=&#39;&#39;>&#39;&#39;?&#39;&#39;@&#39;&#39;\&quot;^&#39;&#39;&#39;&#39;&#39;&#39;<br />&#39;&#39;~&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Brackets">
        <h4>10.2.3ブラケット</h4>
          </a>
        <p>角括弧は、以下のいずれかの文字です。</p><pre class="indent">()[]{}
</pre><p>角括弧は1文字のみで構成されることに注意してください。 文字シーケンス(*(コメントを開始する)を除き、ブラケットは次の文字で終了します。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_bracket">大括弧</a>::=</dt><dd>&#39;&#39;(&#39;&#39;)&#39;&#39;[&#39;&#39;]&#39;&#39;{&#39;&#39;}&#39;。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Literals">
        <h3>10.3リテラル</h3>
          </a>
        <p>リテラルにはいくつかの種類があります。</p><dl>
    <dd><a class="ebnf" href="#tokens_ebnf_integer_literal">整数リテラル</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_biginteger_literal">bigintegerリテラル</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_float_literal">浮動リテラル</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_character_literal">文字直定数</a>s</dd>
    <dd><a class="ebnf" href="#tokens_ebnf_string_literal">文字列直定数</a>s</dd>
</dl><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_literal">文字通りの</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_integer_literal">integer_literal</a><a class="ebnf" href="#tokens_ebnf_biginteger_literal">biginteger_literal</a><a class="ebnf" href="#tokens_ebnf_float_literal">float_literal</a><br /><a class="ebnf" href="#tokens_ebnf_character_literal">文字直定数</a><a class="ebnf" href="#tokens_ebnf_string_literal">文字列リテラル</a></dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Integer_literals">
        <h4>10.3.1整数リテラル</h4>
          </a>
        <p>整数リテラルは10進数と見なされる数字列です。 数字列の後には、文字Eまたはe、オプションの+記号、および10進指数が続く場合があります。<a name="tokens_based_integer"></a>ベース番号は、数字列の後に#文字と拡張数字列が続く場合に指定できます。 #文字の前にある10進数は、#文字の後に続く数の基数を指定します。 基数として2から36までの数が許される。 拡張桁として、文字Aまたはaは10に使用でき、Bまたはbは11などに使用でき、Zまたはzは35に使用できます。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_integer_literal">integer_literal</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a>[<a class="ebnf" href="#tokens_ebnf_exponent">冪指数</a><a class="ebnf" href="#tokens_ebnf_based_integer">based_integer</a>]。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_decimal_integer">decimal_integer</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_digit">指</a>{<a class="ebnf" href="#tokens_ebnf_digit">指</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_exponent">冪指数</a>::=</dt><dd>(&#39;E&#39;&#39;e&#39;)[&#39;+&#39;]<a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_based_integer">based_integer</a>::=</dt><dd>&#39;#&#39;<a class="ebnf" href="#tokens_ebnf_extended_digit">拡張数字</a>{<a class="ebnf" href="#tokens_ebnf_extended_digit">拡張数字</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_extended_digit">拡張数字</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_letter">手紙</a><a class="ebnf" href="#tokens_ebnf_digit">指</a></dd>
</dl>
          </tt>
        </dd></dl><p>整数リテラルを読み込めない場合<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>がトリガーされます。</p><pre class="indent">
***tst256.sd7(2):14:

const integer:tooBigは12345678901234567890;
-----------------------------------------------^
***tst256.sd7(3):15:

const integer:negativeExponentは1e-1;
----------------------------------^
***tst256.sd7(4):16:

const integer:digitExpected is 1e;
-------------------------------^
***tst256.sd7(5):17

const integer:integerWithExponentTooBig is 1e20;
-------------------------------------------------^
***tst256.sd7(6):18:

const integer:baseNotBetween2To36 is 37#0;
----------------------------------------^
***tst256.sd7(7):19:

const integer:extendedDigitExpected is 16#;
---------------------------------------------^
***tst256.sd7(8):20:

const integer:illegalBaseDigit is 16#G;
----------------------------------------^
***tst256.sd7(9):21:

const integer:basedIntegerTooBig is 16#ffffffffffffffffff;
-----------------------------------------------------------^
<a name="tokens_INTEGER_TOO_BIG_example"></a><a class="link" href="#errors_INTEGER_TOO_BIG">整数&quot;12345678901234567890&quot;は大きすぎます</a><a name="tokens_NEGATIVE_EXPONENT_example">整数リテラルの負の指数</a><a class="link" href="#errors_NEGATIVE_EXPONENT"></a>予期された数字が見つかりました;&quot;<a name="tokens_DIGIT_EXPECTED_example"></a><a class="link" href="#errors_DIGIT_EXPECTED">整数&quot;1E20&quot;は大きすぎます</a><a name="tokens_INTEGER_WITH_EXPONENT_TOO_BIG_example">整数ベース&quot;37&quot;が2と36の間にありません</a><a class="link" href="#errors_INTEGER_WITH_EXPONENT_TOO_BIG"></a>予期された拡張ディジットが見つかりました;&quot;<a name="tokens_BASE2TO36ALLOWED_example"></a><a class="link" href="#errors_BASE2TO36ALLOWED">ベース整数&quot;16#G&quot;の数字&quot;G&quot;が不正です。</a><a name="tokens_EXTENDED_DIGIT_EXPECTED_example">基底整数&quot;16#ffffffffffffffff&quot;は大きすぎます</a><a class="link" href="#errors_EXTENDED_DIGIT_EXPECTED"></a><a name="tokens_ILLEGAL_BASED_DIGIT_example"></a><a class="link" href="#errors_ILLEGAL_BASED_DIGIT"></a><a name="tokens_BASED_INTEGER_TOO_BIG_example"></a><a class="link" href="#errors_BASED_INTEGER_TOO_BIG"></a></pre>
          <a name="tokens_BigInteger_literals">
        <h4>10.3.2 BigIntegerリテラル</h4>
          </a>
        <p>bigIntegerリテラルは、直後に下線文字が続く数字列です。 数字の並びは10進数として扱われます。 ベース番号は、数字列の後に#文字、拡張された数字列、および下線文字が続く場合に指定できます。 #文字の前にある10進数は、#文字の後に続く数の基数を指定します。 基数として2から36までの数が許される。 拡張桁として、文字Aまたはaは10に使用でき、Bまたはbは11などに使用でき、Zまたはzは35に使用できます。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_biginteger_literal">biginteger_literal</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a>[<a class="ebnf" href="#tokens_ebnf_based_integer">based_integer</a>]&#39;_&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_Float_literals">
        <h4>10.3.3 Floatリテラル</h4>
          </a>
        <p>浮動小数点リテラルは、小数点で区切られた2つの10進整数リテラルからなります。 基本浮動小数点リテラルの後には、文字Eまたはe、オプションの+または-符号、および10進指数を続けることができます。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_float_literal">float_literal</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a>&#39;.&#39;<a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a>[<a class="ebnf" href="#tokens_ebnf_float_exponent">float_exponent</a>]。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_float_exponent">float_exponent</a>::=</dt><dd>(&#39;E&#39;&#39;e&#39;)[&#39;+&#39;&#39;&#39;-&#39;]<a class="ebnf" href="#tokens_ebnf_decimal_integer">decimal_integer</a></dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="tokens_String_literals">
        <h4>10.3.4文字列リテラル</h4>
          </a>
        <p>ストリング・リテラルは、UTF-8エンコードのUnicode文字を二重引用符で囲んだものです。 例:</p><pre class="indent"><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;\&quot;&quot;&quot;</span><span class="stri">&quot;&quot;&quot;</span><span class="stri">&quot;\&quot;&quot;</span><span class="stri">&quot;文字列&quot;</span><span class="stri">&quot;ch=\&quot;&quot;</span><span class="stri">&quot;\n\n&quot;</span>&quot;Euro:\8364;&quot;<span class="stri"></span>&quot;\16#ff;&quot;<span class="stri"></span></pre><p>印刷できない文字や特定の印刷可能な文字を表すために、次のエスケープシーケンスを使用できます。</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>警告音</td> <td width="20"></td><td>BEL</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\a</span>
          </tt>
        </td></tr>
    <tr><td>バックスペース</td> <td width="20"></td><td>BS</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\b</span>
          </tt>
        </td></tr>
    <tr><td>逃げる</td> <td width="20"></td><td>ESC</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\e</span>
          </tt>
        </td></tr>
    <tr><td>フォームフィード</td> <td width="20"></td><td>FF</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\f</span>
          </tt>
        </td></tr>
    <tr><td>改行</td> <td width="20"></td><td>NL(LF)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\n</span>
          </tt>
        </td></tr>
    <tr><td>復帰</td> <td width="20"></td><td>CR</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\r</span>
          </tt>
        </td></tr>
    <tr><td>水平タブ</td> <td width="20"></td><td>HT</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\t</span>
          </tt>
        </td></tr>
    <tr><td>垂直タブ</td> <td width="20"></td><td>心室頻拍</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\v</span>
          </tt>
        </td></tr>
    <tr><td>バックスラッシュ</td> <td width="20"></td><td>(\)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\\</span>
          </tt>
        </td></tr>
    <tr><td>アポストロフィ</td> <td width="20"></td><td>(&#39;)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\&#39;</span>
          </tt>
        </td></tr>
    <tr><td>ダブルクオート</td> <td width="20"></td><td>(&quot;)</td> <td width="20"></td><td>
          <tt>
            <span class="stri">\&quot;</span>
          </tt>
        </td></tr>
    <tr><td>A制御</td> <td width="20"></td><td></td> <td width="20"></td><td>
          <tt>
            <span class="stri">\A</span>
          </tt>
        </td></tr>
    <tr><td> </td></tr>
    <tr><td>Ctrl+Z</td> <td width="20"></td><td></td> <td width="20"></td><td>
          <tt>
            <span class="stri">\Z</span>
          </tt>
        </td></tr>
</table></dd></dl><p>さらに、次の可能性があります。</p><ul>
    <li><a name="tokens_string_continuation">2つのバックスラッシュとそれに続く空白、水平タブ、復帰、改行<a class="link" href="#tokens_Line_comments">行コメント</a>完全に無視されます。 無視された文字は、文字列の一部にはなりません。 次の行に続く文字列を続けるときに使用できます。 この場合、新しい行の先頭のスペースは文字列の一部ではないことに注意してください。 それは<a class="link" href="#errors_WRONG_STRING_CONTINUATION">間違い</a>バックスラッシュの後に空白文字の並びがあり、その並びの最後に2つ目のバックスラッシュがない場合。</li>

    <li>整数リテラルとセミコロンが後に続くバックスラッシュは、指定した序数を持つ文字として解釈されます。 以下のように書かれていない限り、整数リテラルは10進数として解釈されることに注意してください。<a class="link" href="#tokens_based_integer">基底付き整数</a></li>
</ul><p>文字列は、長さフィールドとUTF-32エンコーディングで実装されます。 文字列は<tt><span class="stri">&#39;\0;&#39;</span></tt>終端されており、バイナリデータも含むことができます。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_string_literal">文字列リテラル</a>::=</dt><dd>&quot;&quot;{<a class="ebnf" href="#tokens_ebnf_string_literal_element">文字列リテラル要素</a>}&#39;&#39;&quot;.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_string_literal_element">文字列リテラル要素</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_simple_literal_character">単純文字</a><a class="ebnf" href="#tokens_ebnf_escape_sequence">エスケープシーケンス</a><a class="ebnf" href="#tokens_ebnf_apostrophe">アポストロフィ</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_simple_literal_character">単純文字</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_letter">手紙</a><a class="ebnf" href="#tokens_ebnf_digit">指</a><a class="ebnf" href="#tokens_ebnf_bracket">大括弧</a><a class="ebnf" href="#tokens_ebnf_special_literal_character">特殊文字</a><br />utf8_encoded_character.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_special_literal_character">特殊文字</a>::=</dt><dd>&#39;&#39;!&#39;&#39;#&#39;&#39;$&#39;&#39;%&#39;&#39;&amp;&#39;&#39;*&#39;&#39;+&#39;&#39;,&#39;&#39;-&#39;&#39;<br />&#39;.&#39;&#39;/&#39;&#39;:&#39;&#39;;&#39;&#39;&lt;&#39;&#39;=&#39;&#39;>&#39;&#39;?&#39;&#39;@&#39;&#39;^&#39;&#39;<br />&quot;_&quot;&quot;&quot;&quot;&quot;~&quot;.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_escape_sequence">エスケープシーケンス</a>::=</dt><dd>&#39;\a&#39;\b&#39;\e&#39;\f&#39;\n&#39;\r&#39;\t&#39;\v&#39;<br />&#39;\\&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;<a class="ebnf" href="#tokens_ebnf_upper_case_letter">大文字</a><br />&#39;\&#39;{<a class="ebnf" href="#tokens_ebnf_space">空間</a><a class="ebnf" href="#tokens_ebnf_line_comment">行コメント</a>}&#39;&#39;&#39;&#39;&#39;\&#39;<a class="ebnf" href="#tokens_ebnf_integer_literal">integer_literal</a>&#39;;&#39;.</dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_apostrophe">アポストロフィ</a>::=</dt><dd>「」。</dd>
</dl>
          </tt>
        </dd></dl><p>文字列リテラルを<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>がトリガーされます。</p><pre class="indent">
***tst256.sd7(2):24:

const string:wrongQuotationRepresentation is&quot;double&quot;&quot;quotations&quot;;
-----------------------------------------------------------^
***tst256.sd7(3):25:

const string:illegalStringEscape is&quot;\z&quot;;
-------------------------------------^
***tst256.sd7(4):26:

const string:wrongNumericEscape is&quot;\1234xyz&quot;;
-------------------------------------------^
***tst256.sd7(5):27:

const string:numericEscapeTooBig is&quot;asd\1234678123467892346;dfdfg&quot;;
------------------------------------------------------------------^
***tst256.sd7(6):28:

const string:backslashExpected is&quot;string\continuation&quot;;
-----------------------------------------------------^
***tst256.sd7(7):29:

const string:exceedSourceLine is&quot;abc
-------------------------------------^
***tst256.sd7(8):31:

const string:integerExpected is&quot;\1.5;&quot;;
------------------------------------^
<a name="tokens_WRONG_QUOTATION_REPRESENTATION_example"></a><a class="link" href="#errors_WRONG_QUOTATION_REPRESENTATION">文字列内での表現には&quot;&quot;の代わりに&quot;&quot;を使用します。</a><a name="tokens_ILLEGAL_STRING_ESCAPE_example">文字列エスケープが不正です:&quot;\z&quot;</a><a class="link" href="#errors_ILLEGAL_STRING_ESCAPE"></a>数字エスケープシーケンスの末尾は&quot;;&quot;とし、&quot;x&quot;は使用しないでください。<a name="tokens_WRONG_NUMERICAL_ESCAPE_example"></a><a class="link" href="#errors_WRONG_NUMERICAL_ESCAPE">数字エスケープシーケンス&quot;\1234678123467892346;&quot;は大きすぎます。</a><a name="tokens_NUMERICAL_ESCAPE_TOO_BIG_example">文字列継続は&quot;c&quot;ではなく&quot;\&quot;で終了する必要があります</a><a class="link" href="#errors_NUMERICAL_ESCAPE_TOO_BIG"></a>文字列リテラルがソース行を超えています<a name="tokens_WRONG_STRING_CONTINUATION_example"></a><a class="link" href="#errors_WRONG_STRING_CONTINUATION">整数リテラルが予期され、&quot;1.5&quot;が見つかりました</a><a name="tokens_STRING_EXCEEDS_example"></a><a class="link" href="#errors_STRING_EXCEEDS"></a><a name="tokens_INTEGER_EXPECTED_example"></a><a class="link" href="#errors_INTEGER_EXPECTED"></a></pre>
          <a name="tokens_Character_literals">
        <h4>10.3.5文字リテラル</h4>
          </a>
        <p>文字リテラルはUTF-8エンコードされたUnicode文字でアポストロフィで囲まれています。 例:</p><pre class="indent"><span class="stri">&#39;a&#39;</span><span class="stri">「」</span><span class="stri">&#39;\n&#39;</span><span class="stri">&#39;!&#39;</span><span class="stri">&#39;\\&#39;</span><span class="stri">&#39;2&#39;</span><span class="stri">&quot;&quot;&quot;</span><span class="stri">&#39;\&quot;&#39;</span><span class="stri">「」</span><span class="stri">&#39;\8;&#39;</span></pre><p>制御文字やその他の特定の文字を文字リテラルで表すには<a class="link" href="#tokens_String_literals">文字列リテラル</a>も用いることができる。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="tokens_ebnf_character_literal">文字直定数</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_apostrophe">アポストロフィ</a><a class="ebnf" href="#tokens_ebnf_char_literal_element">文字リテラル要素</a><a class="ebnf" href="#tokens_ebnf_apostrophe">アポストロフィ</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="tokens_ebnf_char_literal_element">文字リテラル要素</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_simple_literal_character">単純文字</a><a class="ebnf" href="#tokens_ebnf_escape_sequence">エスケープシーケンス</a><a class="ebnf" href="#tokens_ebnf_apostrophe">アポストロフィ</a>&#39;&quot;&#39;.</dd>
</dl>
          </tt>
        </dd></dl><p>charリテラルが読み込めない場合<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>がトリガーされます。</p><pre class="indent">
***tst256.sd7(2):22:

const char:apostropheExpected is&#39;x;
---------------------------------^
***tst256.sd7(3):23:

const char:charExceeds is&#39;
--------------------------^
<a name="tokens_APOSTROPHE_EXPECTED_example"></a><a class="link" href="#errors_APOSTROPHE_EXPECTED">&quot;&#39;&#39;&quot;予期したものが見つかりました&quot;;&quot;</a><a name="tokens_CHAR_EXCEEDS_example">文字直定数がソース行を超えています</a><a class="link" href="#errors_CHAR_EXCEEDS"></a></pre>
          <a name="tokens_Unicode_characters">
        <h3>10.4 Unicode文字</h3>
          </a>
        <p>Seed7ソースコードにはUTF-8コード化されたUnicode文字が含まれる場合があります。 Unicodeの使用は<a class="link" href="#tokens_String_literals">文字列</a>および<a class="link" href="#tokens_Character_literals">char</a>リテラル。 その<a class="link" href="#decls_Pragmas">プラグマ</a><tt><span class="keywd">名前</span></tt>Unicodeを可能にするために使用できる<a class="link" href="#tokens_Name_identifiers">名前の識別子</a>:</p><pre class="indent">
$
;
<span class="keywd">名前</span><span class="keywd">ユニコード</span></pre><p><a class="link" href="#tokens_Comments">コメント</a>および<a class="link" href="#tokens_Line_comments">行コメント</a>も含む場合がありますが、有効なUTF-8かどうかはチェックされません。 これにより、無効なUTF-8を持つコード部分をコメントアウトすることができます。 無効なUTF-8エンコーディング<a class="link" href="#tokens_Identifiers">識別子</a>および<a class="link" href="#tokens_Literals">直定数</a>トリガー<a class="link" href="#errors_Parsing_errors">構文解析エラー</a>:</p><pre class="indent">
***err.sd7(90):61:

ignore(&quot;\0;&quot;);
----------^
***err.sd7(91):62:

ignore(&quot;\55296;&quot;);
--------------^
***err.sd7(92):63:

&quot;\1114112;&quot;);
---------^
***err.sd7(93):64:

ignore(&quot;í\128;A&quot;);
-------------^
***err.sd7(94):65:

ignore(&quot;\128;&quot;);
--------^
***err.sd7(95):66:

ignore(&quot;íA&quot;);
--------^
***部品16(1):67:


-^
<a name="tokens_OVERLONG_UTF8_ENCODING_example"></a><a class="link" href="#errors_OVERLONG_UTF8_ENCODING">文字&quot;\0;&quot;に使用される長すぎるUTF-8エンコーディング(U+0000)</a><a name="tokens_UTF16_SURROGATE_CHAR_FOUND_example">UTF-8エンコード形式の&quot;\55296;&quot;で使用されるUTF-16代理文字(U+d800)</a><a class="link" href="#errors_UTF16_SURROGATE_CHAR_FOUND"></a>非Unicode文字が見つかりました&quot;\1114112;&quot;(U+110000)<a name="tokens_CHAR_NOT_UNICODE_example"></a><a class="link" href="#errors_CHAR_NOT_UNICODE">UTF-8継続バイトが&quot;A&quot;を検出しました</a><a name="tokens_UTF8_CONTINUATION_BYTE_EXPECTED_example">予期しないUTF-8継続バイトが&quot;\128;&quot;(U+0080)</a><a class="link" href="#errors_UTF8_CONTINUATION_BYTE_EXPECTED"></a>孤立したUTF-8開始バイト&quot;\237;&quot;が見つかりました(U+00 ed)<a name="tokens_UNEXPECTED_UTF8_CONTINUATION_BYTE_example"></a><a class="link" href="#errors_UNEXPECTED_UTF8_CONTINUATION_BYTE">UTF-16バイトオーダーマークで&quot;\65279;&quot;(U+feff)が見つかりました</a><a name="tokens_SOLITARY_UTF8_START_BYTE_example"></a><a class="link" href="#errors_SOLITARY_UTF8_START_BYTE"></a><a name="tokens_UTF16_BYTE_ORDER_MARK_FOUND_example"></a><a class="link" href="#errors_UTF16_BYTE_ORDER_MARK_FOUND"></a></pre>
          <a name="expr_file_start"></a>
        <p></p>
          <a name="expr_EXPRESSIONS">
        <h2>11表現</h2>
          </a>
        <p>式には2種類ある。 一方には、固定された定義済みの構文規則を使用して構築される、いわゆる単純式があります。 構文規則に従って構築された式もあります。 構文規則は、構文宣言で定義します。 構文宣言の動作方法については、を参照してください。<a class="link" href="#decls_Syntax_declarations">3.2章(構文の宣言)</a>および<a class="link" href="#syntax_file_start">第9章(構造化構文定義)</a>構文宣言は、Seed7の拡張可能な構文をサポートします。 ユーザ定義の式を簡略化して説明します。この式では優先度は考慮されません。</p><dl><dd>
          <tt>
        <dl>
    <dt><a name="expr_ebnf_expression">表現</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_prefix_expression">接頭語式</a><a class="ebnf" href="#expr_infix_expression">中置式</a><a class="ebnf" href="#expr_ebnf_simple_expression">単純式</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_prefix_expression">接頭語式</a>::=</dt><dd><a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>{<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a><a class="ebnf" href="#expr_ebnf_expression">表現</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_infix_expression">中置式</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_expression">表現</a><a class="ebnf" href="#tokens_ebnf_identifier">識別子</a>{<a class="ebnf" href="#tokens_ebnf_identifier">識別子</a><a class="ebnf" href="#expr_ebnf_expression">表現</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_simple_expression">単純式</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_dot_expression">ドット式</a><a class="ebnf" href="#expr_ebnf_call_expression">call_expression</a></dd>
</dl>
          </tt>
        </dd></dl><p>次の章では、単純表現の定義済み構文規則について説明します。</p>
          <a name="expr_EXPRESSION_Parentheses">
        <h3>11.1括弧</h3>
          </a>
        <p>括弧を使用すると、定義済み構文およびユーザー定義構文の優先順位規則を上書きできます。 例:</p><pre class="indent">2*(3+4)
</pre><p>+演算子によって自分のパラメータが最初に取得されるように指定します。</p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="expr_ebnf_parentheses_expression">括弧式</a>::=</dt><dd>&#39;(&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>&#39;)&#39;。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="expr_Call_expressions">
        <h3>11.2呼び出し式</h3>
          </a>
        <p>呼び出し式を使用してリストを作成することもできます。 例:</p><pre class="indent">
writeln(
)
<span class="stri">&quot;hello world&quot;</span></pre><p>要素でリスト式を形成する</p><dl>
    <dd>
          <tt>
            <span class="stri">&quot;hello world&quot;</span>
          </tt>
        </dd>
    <dd>
          <tt>writeln</tt>
        </dd>
</dl><p>このリストの型は<a class="link" href="#decls_System_declarations">システム宣言</a><span class="stri">&quot;system expr&quot;</span>これは、includeファイルで定義されています。<span class="stri">&quot;syntax.s7i&quot;</span>から含まれる<span class="stri">&quot;seed7_05.s7i&quot;</span>as</p><pre class="indent">
$
is expr;
<span class="keywd">システム</span><span class="stri">&quot;expr&quot;</span></pre><p>2つのパラメータを持つ呼び出し式</p><pre class="indent">
pos(
)
<span class="stri">「スコッティ! 送ってくれ」</span><span class="stri">「am」</span></pre><p>要素でリスト式を形成する</p><dl>
    <dd>
          <tt>
            <span class="stri">「スコッティ! 送ってくれ」</span>
          </tt>
        </dd>
    <dd>
          <tt>
            <span class="stri">「am」</span>
          </tt>
        </dd>
    <dd>
          <tt>pos</tt>
        </dd>
</dl><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="expr_ebnf_call_expression">call_expression</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_primary_expression">第1式</a>[&#39;(&#39;<a class="ebnf" href="#expr_ebnf_parameter_list">パラメータリスト</a>&#39;)&#39;]。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_primary_expression">第1式</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_parentheses_expression">括弧式</a><a class="ebnf" href="#tokens_ebnf_token">象徴</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_parameter_list">パラメータリスト</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_expression">表現</a>{&#39;,&#39;<a class="ebnf" href="#expr_ebnf_expression">表現</a>}。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="expr_Dot_expressions">
        <h3>11.3ドット表現</h3>
          </a>
        <p>ドット式はドットで始まり、リストの要素間のセパレータとしてドットを持ちます。 例:</p><pre class="indent">

TRUE
<span class="op">ない</span></pre><p>および</p><pre class="indent">
…じゃあ
GO_ON
<span class="op">および</span></pre><p>要素によるフォームリスト式</p><dl>
    <dd>
          <tt>
            <span class="op">ない</span>
          </tt>
        </dd>
    <dd>
          <tt>TRUE</tt>
        </dd>
</dl><p>および</p><dl>
    <dd>
          <tt>わかった</tt>
        </dd>
    <dd>
          <tt>
            <span class="op">および</span>
          </tt>
        </dd>
    <dd>
          <tt>実行オン</tt>
        </dd>
</dl><p>このリストの型は<a class="link" href="#decls_System_declarations">システム宣言</a><span class="stri">&quot;system expr&quot;</span>これは、includeファイルで定義されています。<span class="stri">&quot;syntax.s7i&quot;</span>から含まれる<span class="stri">&quot;seed7_05.s7i&quot;</span>as</p><pre class="indent">
$
;
<span class="keywd">システム</span><span class="stri">&quot;expr&quot;</span><span class="keywd">は</span><a class="type" href="#types_expr">expr</a></pre><p>ドット表現は要素の優先度を上書きします。 ドット表現は<a class="link" href="#syntax_The_Seed7_Structured_Syntax_Description">syntax-declarations</a></p><dl><dt>構文:</dt><dd>
          <tt>
        <dl>
    <dt><a name="expr_ebnf_dot_expression">ドット式</a>::=</dt><dd>&#39;.&#39;<a class="ebnf" href="#expr_ebnf_dot_subexpression">ドット部分式</a>{&#39;.&#39;<a class="ebnf" href="#expr_ebnf_dot_subexpression">ドット部分式</a>}。</dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_dot_subexpression">ドット部分式</a>::=</dt><dd><a class="ebnf" href="#expr_ebnf_empty_parentheses">空の括弧</a><a class="ebnf" href="#expr_ebnf_parentheses_expression">括弧式</a><a class="ebnf" href="#expr_ebnf_call_expression">call_expression</a></dd>
<dt>
          <br />
        </dt>
    <dt><a name="expr_ebnf_empty_parentheses">空の括弧</a>::=</dt><dd>&#39;(&#39;&#39;)&#39;。</dd>
</dl>
          </tt>
        </dd></dl><p></p>
          <a name="os_file_start"></a>
        <p></p>
          <a name="os_OPERATING_SYSTEM_ACCESS">
        <h2>12オペレーティング・システムへのアクセス</h2>
          </a>
        <p>Seed7は、オペレーティングシステムが提供するサービスへのポータブルアクセスを提供します。 このインタフェースはPosixおよびUnix指向です。 この章の関数はライブラリで定義されています。<span class="stri">&quot;<span class="lib">osfiles.s7i</span>&quot;</span><span class="stri">&quot;<span class="lib">dir.s7i</span>&quot;</span>および<span class="stri">&quot;<span class="lib">環境.s7i</span>&quot;</span></p>
          <a name="os_Standard_path_representation">
        <h3>12.1標準経路表現</h3>
          </a>
        <p>パスはファイルシステム内のファイルの場所を指定します。 オペレーティングシステムは、どのようにパスが見えるべきかという異なる概念を持っています。 Seed7では、この違いを標準パス表現で補正しています。 標準パスは、パスを扱うすべてのSeed7関数で使用されます。 標準パス表現では<tt><a class="type" href="#types_string">文字列</a>s</tt>以下のプロパティでパスを記述します。</p><ul>
    <li>スラッシュ(<tt><span class="stri">「/」</span></tt>)をパスの区切り文字として使用します。</li>
    <li>ドライブレターは使用できませんが、交換するソリューションがあります。</li>
    <li>経路以外は<tt><span class="stri">&quot;/&quot;</span></tt>標準パスの末尾にスラッシュを使用することはできません。</ul><p>次のような関数がある場合<tt><span class="func">開いたさま</span></tt>が次のようなパスで呼び出されました:<tt><span class="stri">&quot;/&quot;</span></tt>例外はスラッシュで終わります。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>を上げます。 Windowsでは、次のような標準パス<tt><span class="stri">&quot;/c&quot;</span></tt>ドライブにマップされる<tt><span class="stri">「C:」</span></tt>・ディレクトリを読む<tt><span class="stri">&quot;/&quot;</span></tt>Windowsでは、使用可能なドライブのリストが表示されます。 バックスラッシュまたはドライブ文字を含むパスは、例外が発生する場合があります。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>のような関数を指定すると<tt><span class="func">開いたさま</span></tt>が呼び出されます。</p><p>絶対パスはファイルシステム内で一意の場所を指定します。 絶対パスは、常にスラッシュで始まります。 相対パスは、プログラムの現在の作業ディレクトリに相対的な場所を指定します。 標準パスは移植性のある方法で定義されているが、絶対パスは通常移植性がない。</p>
          <a name="os_File_properties">
        <h3>12.2ファイルプロパティ</h3>
          </a>
        <p>ファイルには、タイプ、サイズ、モード(パーミッション)、複数のタイムスタンプ、所有者、グループなどの属性があります。 タイプやサイズなどの属性を直接変更することはできません。 他のプロパティは変更される可能性があります。 これらのプロパティには、ゲッターおよびセッターが用意されています。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>プロパティ</th><th>ゲッター</th><th>設定者</th><th>コメント</th></tr>

  <tr><td>ファイルの種類</td><td>
          <tt>
            <a class="func" href="#os_fileType">ファイルタイプ</a>
          </tt>
          <br />
          <tt>
            <a class="func" href="#os_fileType">ファイルタイプL</a>
          </tt>
        </td><td></td><td><!--(*-->可能な値については、functionを参照してください。<tt><a class="func" href="#os_fileType">ファイルタイプ</a></tt><br /><!--*)-->その他の中で<tt><a href="#os_FILE_REGULAR">FILE_REGULAR</a></tt>および<tt><a href="#os_FILE_DIR">FILE_DIR</a></tt>ファイルタイプである</td></tr>
  <tr><td>サイズ</td><td>
          <tt>
            <a class="func" href="#os_fileSize">ファイルサイズ</a>
          </tt>
          <br />
          <tt>
            <a class="func" href="#os_fileSize">bigFileSize</a>
          </tt>
        </td><td></td><td><!--(*-->ファイルのサイズ(バイト)<!--*)--></td></tr>
  <tr><td>モード</td><td>
          <tt>
            <a class="func" href="#os_getFileMode">getFileMode</a>
          </tt>
        </td><td>
          <tt>
            <a class="func" href="#os_setFileMode">setFileMode</a>
          </tt>
        </td><td>権限。 可能な値については、functionを参照してください。<tt><a class="func" href="#os_getFileMode">getFileMode</a></tt></td></tr>
  <tr><td>aTime</td><td>
          <tt>
            <a class="func" href="#os_getATime">getATime</a>
          </tt>
        </td><td>
          <tt>
            <a class="func" href="#os_setATime">setATime</a>
          </tt>
        </td><td>最終アクセス日時</td></tr>
  <tr><td>cTime</td><td>
          <tt>
            <a class="func" href="#os_getCTime">getCTime</a>
          </tt>
        </td><td></td><td>ステータスが最後に変更された時刻</td></tr>
  <tr><td>mTime</td><td>
          <tt>
            <a class="func" href="#os_getMTime">getMTime</a>
          </tt>
        </td><td>
          <tt>
            <a class="func" href="#os_setMTime">setMTime</a>
          </tt>
        </td><td>内容を最後に修正した時刻</td></tr>
  <tr><td>所有者</td><td>
          <tt>
            <a class="func" href="#os_getOwner">getOwner</a>
          </tt>
        </td><td>
          <tt>
            <a class="func" href="#os_setOwner">所有者を設定する</a>
          </tt>
        </td><td>ファイル所有者のユーザー名</td></tr>
  <tr><td>グループ</td><td>
          <tt>
            <a class="func" href="#os_getGroup">getGroup</a>
          </tt>
        </td><td>
          <tt>
            <a class="func" href="#os_setGroup">setGroup</a>
          </tt>
        </td><td>ファイルが属するグループの名前</td></tr>

</table></dd></dl><p></p>
          <a name="os_fileType">
        <h4>12.2.1ファイルタイプ</h4>
          </a>
        <p>ファイルのタイプは<tt><span class="func">ファイルタイプ</span></tt>または<tt><span class="func">ファイルタイプL</span></tt>:</p><pre class="indent">


<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:fileType(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>整数<a class="type" href="#types_integer">:fileTypeSL(</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:filePath)</a>は<span class="keywd"></span></pre><p>機能<tt><span class="func">ファイルタイプ</span></tt>はシンボリックリンクをたどる。 機能<tt><span class="func">ファイルタイプL</span></tt>はシンボリックリンクを辿らない。 戻り値<tt><a class="var" href="#os_FILE_ABSENT">ファイル_不在</a></tt>では、この名前のファイルが作成されるとは限りません。不明なディレクトリや不正なファイル名があると<tt><a class="var" href="#os_FILE_ABSENT">ファイル_不在</a></tt></p>
  <div><dl><dt><p>戻り値:</p></dt><dd><dl>
    <dt>
          <a name="os_FILE_ABSENT">ファイル_不在</a>
        </dt>
        <dd>パスの構成要素が存在しない。</dd>
    <dt>
          <a name="os_FILE_UNKNOWN">FILE_UNKNOWN</a>
        </dt>
        <dd>ファイルは存在しますが、タイプが不明です。</dd>
    <dt>
          <a name="os_FILE_REGULAR">FILE_REGULAR</a>
        </dt>
        <dd>そのファイルは正則ファイルです。</dd>
    <dt>
          <a name="os_FILE_DIR">FILE_DIR</a>
        </dt>
        <dd>ファイルはディレクトリです。</dd>
    <dt>
          <a name="os_FILE_CHAR">FILE_CHAR</a>
        </dt>
        <dd>そのファイルはキャラクタ型スペシャル・ファイルです。</dd>
    <dt>
          <a name="os_FILE_BLOCK">FILE_BLOCK</a>
        </dt>
        <dd>そのファイルはブロック型スペシャル・ファイルです。</dd>
    <dt>
          <a name="os_FILE_FIFO">FILE_FIFO</a>
        </dt>
        <dd>ファイルがパイプまたはFIFOスペシャル・ファイルである。</dd>
    <dt>
          <a name="os_FILE_SYMLINK">FILE_SYMLINK</a>
        </dt>
        <dd>ファイルはシンボリック・リンクです。</dd>
    <dt>
          <a name="os_FILE_SOCKET">FILE_SOCKET</a>
        </dt>
        <dd>ファイルがソケットである。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a></dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>システム関数がENOENT、ENOTDIR、EMANTOOLONG、EACCES以外のエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_fileSize">
        <h4>12.2.2ファイルサイズ</h4>
          </a>
        <p>ファイルのサイズは<tt><span class="func">ファイルサイズ</span></tt>および<tt><span class="func">bigFileSize</span></tt>:</p><pre class="indent">


<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:fileSize(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>bigInteger<a class="type" href="#types_bigInteger">:bigFileSize(</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:filePath)</a>は<span class="keywd"></span></pre><p>その機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>ディレクトリの場合、サイズ0を返します。 他のファイルタイプのためのオペレーティングシステム機能<tt>&#39;stat()&#39;</tt>および<tt>&#39;seek()&#39;</tt>ファイルのサイズを決定するために使用されます。 機能<tt><span class="func">ファイルサイズ</span></tt>および<tt><span class="func">bigFileSize</span></tt>:ファイルサイズを決定する方針が少なくとも1つ成功すると、このオプションは成功します。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd>ファイルサイズはとして表現できません<tt><a class="type" href="#types_integer">整数</a></tt>(この例外は<tt><span class="func">bigFileSize</span></tt>)。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ファイルサイズを判別できませんでした。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getFileMode">
        <h4>12.2.3 getFileMode</h4>
          </a>
        <p>ファイルのファイルモード(パーミッション)は以下で決定します。<tt><span class="func">getFileMode</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">ファイルモード</span>:getFileMode(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。 型式<tt><span class="type">ファイルモード</span></tt>は次のように定義され<tt>&#39;<a class="type" href="#types_set">設定する</a><span class="type">の</span><span class="type">filePermission</span>&#39;</tt></p>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>その<tt><span class="type">ファイルモード</span></tt>これは次のように定義されてい<tt><a class="type" href="#types_set">設定する</a><span class="type">の</span><span class="type">filePermission</span></tt></p></dd></dl></div>
  <div><dl><dt><p>リテラル値<tt><span class="type">filePermission</span></tt>は:</p></dt><dd><dl>
    <dt>EXEC_OTHER</dt>
        <dd>他のものは実行許可がある</dd>
    <dt>WRITE_OTHER</dt>
        <dd>他のユーザには書き込み権限があります</dd>
    <dt>READ_OTHER</dt>
        <dd>他の人には読み込み権限があります</dd>
    <dt>EXEC_GROUP</dt>
        <dd>実行権限を持つグループ</dd>
    <dt>WRITE_GROUP</dt>
        <dd>グループに書き込み権限があります</dd>
    <dt>読み込みグループ</dt>
        <dd>グループに読み取り権限があります</dd>
    <dt>EXEC_USER</dt>
        <dd>所有者には実行権限がある</dd>
    <dt>WRITE_USER</dt>
        <dd>所有者に書き込み権限があります</dd>
    <dt>ユーザーの読み取り</dt>
        <dd>所有者に読み取り権限があります</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setFileMode">
        <h4>12.2.4 setFileMode</h4>
          </a>
        <p>ファイルのパーミッションは以下のコマンドで変更できます。<tt><span class="func">setFileMode</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setFileMode(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><span class="type">ファイルモード</span>:newFileMode)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。 型式<tt><span class="type">ファイルモード</span></tt>は次のように定義され<tt>&#39;<a class="type" href="#types_set">設定する</a><span class="type">の</span><span class="type">filePermission</span>&#39;</tt></p>
  <div><dl><dt><p>リテラル値<tt><span class="type">filePermission</span></tt>は:</p></dt><dd><dl>
    <dt>EXEC_OTHER</dt>
        <dd>他のものは実行許可がある</dd>
    <dt>WRITE_OTHER</dt>
        <dd>他のユーザには書き込み権限があります</dd>
    <dt>READ_OTHER</dt>
        <dd>他の人には読み込み権限があります</dd>
    <dt>EXEC_GROUP</dt>
        <dd>実行権限を持つグループ</dd>
    <dt>WRITE_GROUP</dt>
        <dd>グループに書き込み権限があります</dd>
    <dt>読み込みグループ</dt>
        <dd>グループに読み取り権限があります</dd>
    <dt>EXEC_USER</dt>
        <dd>所有者には実行権限がある</dd>
    <dt>WRITE_USER</dt>
        <dd>所有者に書き込み権限があります</dd>
    <dt>ユーザーの読み取り</dt>
        <dd>所有者に読み取り権限があります</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getATime">
        <h4>12.2.5 getATime</h4>
          </a>
        <p>ファイルのアクセス時間が関数によって返されます。<tt><span class="func">getATime</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_time">時間</a>:getATime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setATime">
        <h4>12.2.6 setATime</h4>
          </a>
        <p>機能<tt><span class="func">setATime</span></tt>ファイルのアクセス時間を設定する。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setATime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_time">時間</a>:aTime)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合。<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getCTime">
        <h4>12.2.7 getCTime</h4>
          </a>
        <p>ファイルの状態変更時刻が関数によって返されます。<tt><span class="func">getCTime</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_time">時間</a>:getCTime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getMTime">
        <h4>12.2.8 getMTime</h4>
          </a>
        <p>ファイルの更新時刻が関数によって返されます。<tt><span class="func">getMTime</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_time">時間</a>:getMTime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setMTime">
        <h4>12.2.9 setMTime</h4>
          </a>
        <p>機能<tt><span class="func">setMTime</span></tt>ファイルの修正時刻を設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setMTime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_time">時間</a>:aTime)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getOwner">
        <h4>12.2.10 getOwner</h4>
          </a>
        <p>ファイルの所有者は関数によって返されます。<tt><span class="func">getOwner</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getOwner(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setOwner">
        <h4>12.2.11 setOwner</h4>
          </a>
        <p>機能<tt><span class="func">所有者を設定する</span></tt>ファイルの所有者を設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setOwner(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:owner)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getGroup">
        <h4>12.2.12 getGroup</h4>
          </a>
        <p>ファイルのグループが関数によって返されます。<tt><span class="func">getGroup</span></tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getGroup(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setGroup">
        <h4>12.2.13 setGroup</h4>
          </a>
        <p>機能<tt><span class="func">setGroup</span></tt>ファイルのグループを設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setGroup(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:group)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクをたどります。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない場合、またはシステム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_Symbolic_links">
        <h3>12.3シンボリック・リンク</h3>
          </a>
        <p>シンボリックリンク(symlink)は目的のファイルやディレクトリを指し示すファイルです。 ターゲット(宛先)への相対パスまたは絶対パスを指定します。 相対シンボリックリンクはファイルシステム内の場所に相対的であり、現在の作業ディレクトリには相対的ではありません。 シンボリックリンクのターゲットが存在しない可能性があります。 この場合、それはダングリングシンボリックリンクです。 多くのファイル関数はシンボリックリンクをたどります。 No wとは: シンボリックリンクの場合、この関数はパスが再びシンボリックリンクでなくなるまでシンボリックリンクチェーンをたどります。 その後、関数はこの最終経路に適用される。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th align="center" colspan="2">シンボリックリンクをたどる関数</th><th align="center" colspan="2">シンボリックリンク上でのみ動作し、シンボリックリンクには従わない関数</th></tr>
  <tr><td colspan="2">ダングリングシンボリックリンクが発生します。<tt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></tt></td><td colspan="2"><tt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></tt>&#39;path&#39;がシンボリックリンクでない場合には0を返します。</td></tr>

  <tr><td>
          <tt><a class="func" href="#os_fileSize">ファイルサイズ</a>(パス)</tt>
        </td><td></td><td></td><td></td></tr>
  <tr><td>
          <tt><a class="func" href="#os_fileSize">bigFileSize</a>(パス)</tt>
        </td><td></td><td></td><td></td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getFileMode">getFileMode</a>(パス)</tt>
        </td><td>
          <tt><a class="func" href="#os_setFileMode">setFileMode</a>(path, mode)</tt>
        </td><td>
          <tt><a class="func" href="#os_getFileMode_SYMLINK">getFileMode</a>(path, SYMLINK)</tt>
        </td><td></td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getATime">getATime</a>(パス)</tt>
        </td><td>
          <tt><a class="func" href="#os_setATime">setATime</a>(path, time)</tt>
        </td><td>
          <tt><a class="func" href="#os_getATime_SYMLINK">getATime</a>(path, SYMLINK)</tt>
        </td><td></td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getCTime">getCTime</a>(パス)</tt>
        </td><td></td><td></td><td></td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getMTime">getMTime</a>(パス)</tt>
        </td><td>
          <tt><a class="func" href="#os_setMTime">setMTime</a>(path, time)</tt>
        </td><td>
          <tt><a class="func" href="#os_getMTime_SYMLINK">getMTime</a>(path, SYMLINK)</tt>
        </td><td>
          <tt><a class="func" href="#os_setMTime_SYMLINK">setMTime</a>(path, time, SYMLINK)</tt>
        </td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getOwner">getOwner</a>(パス)</tt>
        </td><td>
          <tt><a class="func" href="#os_setOwner">所有者を設定する</a>(パス、名前)</tt>
        </td><td>
          <tt><a class="func" href="#os_getOwner_SYMLINK">getOwner</a>(path, SYMLINK)</tt>
        </td><td>
          <tt><a class="func" href="#os_setOwner_SYMLINK">所有者を設定する</a>(path, name, SYMLINK)</tt>
        </td></tr>
  <tr><td>
          <tt><a class="func" href="#os_getGroup">getGroup</a>(パス)</tt>
        </td><td>
          <tt><a class="func" href="#os_setGroup">setGroup</a>(パス、名前)</tt>
        </td><td>
          <tt><a class="func" href="#os_getGroup_SYMLINK">getGroup</a>(path, SYMLINK)</tt>
        </td><td>
          <tt><a class="func" href="#os_setGroup_SYMLINK">setGroup</a>(path, name, SYMLINK)</tt>
        </td></tr>
  <tr><td></td><td></td><td>
          <tt><a class="func" href="#os_readLink">readLink</a>(パス)</tt>
        </td><td></td></tr>
  <tr><td></td><td></td><td>
          <tt><a class="func" href="#os_readLink">readLink</a>(path, ABSOLUTE)</tt>
        </td><td></td></tr>

</table></dd></dl><p>シンボリック・リンクを辿らない関数:</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">

  <tr><th>機能</th><th>コメント</th></tr>

  <tr><td>
          <tt><a class="func" href="#os_removeFile">removeFile</a>(パス)</tt>
        </td><td>シンボリック・リンクの削除に使用できる。</td></tr>
  <tr><td>
          <tt><a class="func" href="#os_removeTree">removeTree</a>(パス)</tt>
        </td><td>シンボリック・リンクの削除に使用できる。</td></tr>
  <tr><td>
          <tt><a class="func" href="#os_cloneFile">cloneFile</a>(source, dest)</tt>
        </td><td>シンボリック・リンクをコピーするために使用できる。</td></tr>
  <tr><td>
          <tt><a class="func" href="#os_moveFile">moveFile</a>(source, dest)</tt>
        </td><td>シンボリック・リンク名の変更に使用できる。</td></tr>

</table></dd></dl><p></p>
          <a name="os_readLink">
        <h4>12.3.1 readLink</h4>
          </a>
        <p>機能<tt><span class="func">readLink</span>(パス)</tt>および<tt><span class="func">readLink</span>(path, ABSOLUTE)</tt>シンボリックリンク先を読み込む。</p><pre class="indent">


<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:readLink(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>文字列<a class="type" href="#types_string">:readLink(</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:filePath, ABSOLUTE)</a>は<span class="keywd"></span></pre><p>機能<tt><span class="func">readLink</span>(パス)</tt>ファイルシステムに格納されたリンク先を読み出す。 シンボリックリンクには相対的なものと絶対的なものがある。 相対シンボリックリンクはファイルシステム内の場所に相対的であり、現在の作業ディレクトリには相対的ではありません。 機能<tt><span class="func">readLink</span>(path, ABSOLUTE)</tt>は常に絶対パスを返す。 絶対シンボリック・リンクは変更しないまま、相対シンボリック・リンクを絶対パスに変換します。</p>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>シンボリックリンク<tt>&#39;filePath&#39;</tt></p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプまたは結果を表すのに十分なメモリーがありません<tt><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_finalPath">
        <h4>12.3.2 finalPath</h4>
          </a>
        <p>機能<tt><span class="func">finalPath</span></tt>次のように機能する最終パスを返します。<tt><span class="func">getMTime</span></tt>および<tt><span class="func">開いたさま</span></tt>を使用します。 もし<tt>ファイルパス</tt>がシンボリックリンクでない場合、それを返します。 シンボリックリンクの場合、この関数はパスが再びシンボリックリンクでなくなるまでシンボリックリンクチェーンをたどります。 最終パスは存在しないファイルを参照する場合があります。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:finalPath(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>パラメータ:</p></dt><dd><dl>
    <dt>ファイルパス</dt>
        <dd>相対パスまたは絶対パス。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>シンボリックリンクチェーンをたどった後の最終パスです。</dl></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプまたは結果を表すのに十分なメモリーがありません<tt><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しないか、システム関数がエラーを返した場合に呼び出されます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_makeLink">
        <h4>12.3.3 makeLink</h4>
          </a>
        <p>機能<tt><span class="func">makeLink</span></tt>シンボリックリンクを作成します<tt>symlinkPath</tt>で参照される文字列を含む<tt>targetPath</tt>関数はシンボリック・リンクをたどりません。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:makeLink(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:symlinkPath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:targetPath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>パラメータ:</p></dt><dd><dl>
    <dt>symlinkPath</dt>
        <dd>作成するシンボリック・リンクの名前。</dd>
    <dt>targetPath</dt>
        <dd>シンボリックリンクに含まれる文字列。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;symlinkPath&#39;</tt>または<tt>&#39;targetPath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;symlinkPath&#39;</tt>または<tt>&#39;targetPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>、またはいずれかをシステム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ファイル&#39;&#39;dirPath&#39;&#39;は既に存在するか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getFileMode_SYMLINK">
        <h4>12.3.4シンボリック・リンクgetFileMode</h4>
          </a>
        <p>シンボリックリンクのファイルモード(パーミッション)は<tt><span class="func">getFileMode</span>(path, SYMLINK)</tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">ファイルモード</span>:getFileMode(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getATime_SYMLINK">
        <h4>12.3.5シンボリック・リンクgetATime</h4>
          </a>
        <p>関数がシンボリック・リンクのアクセス時刻を返します。<tt><span class="func">getATime</span>(path, SYMLINK)</tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_time">時間</a>:getATime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getMTime_SYMLINK">
        <h4>12.3.6シンボリックリンクgetMTime</h4>
          </a>
        <p>シンボリックリンクの更新時刻が関数によって返されます。<tt><span class="func">getMTime</span>(path, SYMLINK)</tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_time">時間</a>:getMTime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setMTime_SYMLINK">
        <h4>12.3.7シンボリックリンクのsetMTime</h4>
          </a>
        <p>機能<tt><span class="func">setMTime</span>(path, time, SYMLINK)</tt>シンボリックリンクの更新時刻を設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setMTime(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_time">時間</a>:aTime、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getOwner_SYMLINK">
        <h4>12.3.8シンボリック・リンクgetOwner</h4>
          </a>
        <p>関数がシンボリックリンクの所有者を返します。<tt><span class="func">getOwner</span>(path, SYMLINK)</tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getOwner(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setOwner_SYMLINK">
        <h4>12.3.9シンボリック・リンクのsetOwner</h4>
          </a>
        <p>機能<tt><span class="func">所有者を設定する</span>(path、owner、SYMLINK)</tt>シンボリックリンクの所有者を設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setOwner(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:owner, SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_getGroup_SYMLINK">
        <h4>12.3.10シンボリック・リンクgetGroup</h4>
          </a>
        <p>関数によってシンボリックリンクのグループが返されます。<tt><span class="func">getGroup</span>(path, SYMLINK)</tt>:</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getGroup(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setGroup_SYMLINK">
        <h4>12.3.11シンボリックリンクsetGroup</h4>
          </a>
        <p>機能<tt><span class="func">setGroup</span>(path, group, SYMLINK)</tt>シンボリックリンクのグループを設定します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setGroup(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:group、SYMLINK)<span class="keywd">は</span></pre><p>この機能はシンボリック・リンクに対してのみ有効で、シンボリック・リンクの後には続きません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>またはシステム・パス・タイプに変換できない<tt>&#39;aTime&#39;</tt>が無効であるか、または<tt>&#39;aTime&#39;</tt>システムファイル時間に変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;filePath&#39;</tt>が存在しない、シンボリックリンクでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_Directory_functions">
        <h3>12.4ディレクトリ機能</h3>
          </a>
        <p>ディレクトリは特別な種類のファイルです。 他のファイルへの参照が含まれています。 一部の関数は、ディレクトリ上でのみ動作します(例:<tt><a class="func" href="#os_readDir">readDir</a></tt>)他の機能(例:<tt><a class="func" href="#os_getMTime">getMTime</a></tt>)はどんな種類のファイルでも動きます。 ディレクトリはファイルなので、このような一般的な関数の説明では特に言及しません。</p>
          <a name="os_readDir">
        <h4>12.4.1 readDir</h4>
          </a>
        <p>機能<tt><span class="func">readDir</span></tt>では、ファイルシステム内のディレクトリの内容に簡単にアクセスできます。 指定されたディレクトリを読み込み、ファイル名を文字列配列に格納します。 ファイル<tt><span class="stri">&quot;.&quot;</span></tt>および<tt><span class="stri">&quot;.&quot;</span></tt>結果から除外されます。 文字列にはファイル名のみが含まれることに注意してください。 その他のコールを使用して追加情報を取得する必要がある。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:readDir(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:dirPath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>指定されたディレクトリ内のすべてのファイルの名前を含む文字列の配列。<tt><span class="stri">&quot;.&quot;</span></tt>および<tt><span class="stri">&quot;.&quot;</span></tt></p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;dirPath&#39;</tt>システム・パス・タイプまたは結果を表すのに十分なメモリーがありません<tt><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;dirPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>で説明されているファイル<tt>&#39;dirPath&#39;</tt>が存在しない、ディレクトリでない、システム関数がエラーを返した、のいずれかです。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><p>宣言の後</p><pre class="indent">;
<span class="keywd">var</span><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:dir_array<span class="keywd">は</span>0<span class="op">回</span><span class="stri">&quot;&quot;</span></pre><p>文</p><pre class="indent">
dir_array:=readDir(
);
<span class="stri">&quot;.&quot;</span></pre><p>現在の作業ディレクトリを読み込み、それを文字列配列に格納します。<tt>&#39;dir_array&#39;</tt>ディレクトリのコンポーネントには、インデックスを使用してアクセスできるようになりました。</p><pre class="indent">writeln(dir_array[index]);

;
<span class="keywd">の</span>索引<span class="keywd">範囲</span>1<span class="keywd">へ</span>length(dir_array)<span class="keywd">do</span>終わる<span class="keywd"></span></pre><p></p></dd></dl></div><p></p>
          <a name="os_openDir">
        <h4>12.4.2 openDir</h4>
          </a>
        <p>機能<tt><span class="func">openDir</span></tt>は指定したディレクトリをファイルとして開く。 このディレクトリファイルの各行には、ディレクトリに存在するファイルのファイル名が含まれます。 ファイル<tt><span class="stri">&quot;.&quot;</span></tt>および<tt><span class="stri">&quot;.&quot;</span></tt>がディレクトリファイルから除外されます。 ディレクトリファイルから読み込めるのは、ファイル名だけであることに注意してください。 その他の電話では追加情報を得る必要がある。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_file">ファイルする</a>:openDir(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:dirPath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>指定されたディレクトリのディレクトリファイル。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;dirPath&#39;</tt>システム・パス・タイプまたは結果を表すのに十分なメモリーがありません<tt><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;dirPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>システム関数がエラーを返す。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><pre class="indent">


;


;

;



aDirFile:=openDir(
);
fileName:=getln(aDirFile);


writeln(fileName);
fileName:=getln(aDirFile);

;
<span class="keywd">含む</span><span class="stri">&quot;dir.s7i&quot;</span>var<span class="keywd"></span>ファイルする<a class="type" href="#types_file">:aDirFile</a>は<span class="keywd"></span>STD_NULL<span class="var_no_ul">var</span><span class="keywd">文字列</span>:fileName<a class="type" href="#types_string">は</a><span class="keywd">&quot;&quot;</span>&quot;.&quot;<span class="stri">一方で</span>ファイル名&lt;><span class="stri">&quot;&quot;</span><span class="keywd">do</span>whileを終了する<span class="stri"></span><span class="keywd"></span><span class="keywd"></span></pre><p></p></dd></dl></div><p></p>
          <a name="os_getcwd">
        <h4>12.4.3 getcwd</h4>
          </a>
        <p>機能<tt><span class="func">getcwd</span></tt>は呼び出し元プロセスの現在の作業ディレクトリを絶対パスで返す。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getcwd<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>カレントワーキングディレクトリの絶対パス。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>メモリ不足のため、結果を表示できません<tt><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>システム関数がエラーを返します。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><p>ステートメント</p><pre class="indent">my_dir:=getcwd;
</pre><p>は現在の作業ディレクトリのフルパスを<tt><a class="type" href="#types_string">文字列</a></tt>変わりやすい<tt>&#39;my_dir&#39;</tt></p></dd></dl></div><p></p>
          <a name="os_chdir">
        <h4>12.4.4 chdir</h4>
          </a>
        <p>機能<tt><span class="func">chdir</span></tt>は呼び出し元プロセスの現在の作業ディレクトリを、指定されたディレクトリに変更する。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:chdir(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:名前)<span class="keywd">は</span></pre>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;name&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;name&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>システム関数がエラーを返す。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><p>ステートメント</p><pre class="indent">
chdir(
);
<span class="stri">&quot;/usr/bin&quot;</span></pre><p>現在の作業ディレクトリを<tt><span class="stri">&quot;/usr/bin&quot;</span></tt></p></dd></dl></div><p></p>
          <a name="os_makeDir">
        <h4>12.4.5 makeDir</h4>
          </a>
        <p>機能<tt><span class="func">makeDir</span></tt>新しいディレクトリを作成します。 その機能はシンボリック・リンクをたどりません。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:makeDir(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:dirPath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;dirPath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;dirPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ファイル&#39;&#39;dirPath&#39;&#39;は既に存在するか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><p>ステートメント</p><pre class="indent">
makeDir(
);
<span class="stri">&quot;my_dir&quot;</span></pre><p>ディレクトリを作成します。<tt><span class="stri">&quot;my_dir&quot;</span></tt></p></dd></dl></div><p></p>
          <a name="os_homeDir">
        <h4>12.4.6 homeDir</h4>
          </a>
        <p>機能<tt><span class="func">ホームディレクトリ</span></tt>ユーザのホームディレクトリを絶対パスで返します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:homeDir<span class="keywd">は</span></pre><p>この関数は、などの環境変数を使用するよりも優先されます。<tt>$HOME</tt><tt>$HOME</tt>はすべてのオペレーティングシステムでサポートされているわけではなく<a class="link" href="#os_Standard_path_representation">標準経路表現</a></p>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>ホーム・ディレクトリーの絶対パス。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>メモリ不足のため、結果を表示できません<tt><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ホームディレクトリーを判別できません。</dd>
</dl></dd></dl></div>
  <div><dl><dt><p>例:</p></dt><dd><p>ステートメント</p><pre class="indent">my_dir:=homeDir;
</pre><p>はホームディレクトリのフルパスを<tt><a class="type" href="#types_string">文字列</a></tt>変わりやすい<tt>&#39;my_dir&#39;</tt></p></dd></dl></div><p></p>
          <a name="os_Maintenance_functions">
        <h3>12.5整備機能</h3>
          </a>
        <p></p>
          <a name="os_removeFile">
        <h4>12.5.1 removeFile</h4>
          </a>
        <p>機能<tt><span class="func">removeFile</span></tt>は、空でないディレクトリでない限り、あらゆるタイプのファイルを削除します。 空ではないディレクトリを削除しようとした場合<a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:removeFile(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できません。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ファイルが存在しないか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_removeTree">
        <h4>12.5.2 removeTree</h4>
          </a>
        <p>機能<tt><span class="func">removeTree</span></tt>ディレクトリツリーを含むすべてのタイプのファイルを削除します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:removeTree(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:filePath)<span class="keywd">は</span></pre>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;filePath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;filePath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パス・タイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>ファイルが存在しないか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div>
          <a name="os_copyFile">
        <h4>12.5.3 copyFile</h4>
          </a>
        <p>機能<tt><span class="func">copyFile</span></tt>ファイルまたはディレクトリツリーをコピーします。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:copyFile(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:sourcePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:destPath)<span class="keywd">は</span></pre><p>コピー先ファイルのパーミッション/モード、所有権、タイムスタンプは、対応するソースプロパティとは無関係に決定されます。 目的ファイルはumaskで定義されたパーミッション/モードを取得する。 プログラムを実行したユーザが、目的ファイルの所有者になります。 目的ファイルのタイムスタンプが現在の時間に設定されます。 内のシンボリックリンク<tt>ソースパス</tt>常に従われます。 したがって<tt><span class="func">copyFile</span></tt>はシンボリックリンクを作成しません。 に注意してください。<tt><span class="func">copyFile</span></tt>はハードリンクを保持しない(ハードリンクは別のファイルに解決される)。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パスタイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>コピー元ファイルが存在しないか、コピー先ファイルがすでに存在するか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_cloneFile">
        <h4>12.5.4 cloneFile</h4>
          </a>
        <p>機能<tt><span class="func">cloneFile</span></tt>ファイルまたはディレクトリツリーのクローンを作成します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:cloneFile(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:sourcePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:destPath)<span class="keywd">は</span></pre><p>オリジナルのパーミッション/モード、オーナーシップ、タイムスタンプは保持される。 シンボリックリンクが辿られていない。 代わりにシンボリックリンクをコピーします。 に注意してください。<tt><span class="func">cloneFile</span></tt>はハードリンクを保持しない(ハードリンクは別のファイルに解決される)。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パスタイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>コピー元ファイルが存在しないか、コピー先ファイルがすでに存在するか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_moveFile">
        <h4>12.5.5 moveFile</h4>
          </a>
        <p>機能<tt><span class="func">moveFile</span></tt>ファイルまたはディレクトリツリーの移動や名前の変更を行います。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:moveFile(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:sourcePath<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:destPath)<span class="keywd">は</span></pre><p>このファンクションは、C<tt>&#39;rename()&#39;</tt>関数を使用します。 いつ<tt>&#39;rename()&#39;</tt>が失敗した場合、ファイル(またはディレクトリツリー)は<tt><a class="func" href="#os_cloneFile">cloneFile</a></tt>(権限/モード、所有権、タイムスタンプが保持されます)が新しい場所に新しい名前で移動します。 いつ<tt><a class="func" href="#os_cloneFile">cloneFile</a></tt>が成功した場合、元のファイルは削除されます。 いつ<tt><a class="func" href="#os_cloneFile">cloneFile</a></tt>が失敗した場合(デバイスに空き領域がない、またはその他の理由)、失敗したクローンの残りはすべて削除されます。 に注意してください。<tt><a class="func" href="#os_cloneFile">cloneFile</a></tt>はシンボリックリンクに対しては動作するが、ハードリンクは保持しない(ハードリンクは別のファイルに解決される)。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>システム・パス・タイプに設定します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;sourcePath&#39;</tt>または<tt>&#39;destPath&#39;</tt>は<a class="link" href="#os_Standard_path_representation">標準経路表現</a>システム・パスタイプに変換できない場合があります。</dd>
    <dt>
          <a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a>
        </dt>
        <dd>コピー元ファイルが存在しないか、コピー先ファイルがすでに存在するか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_Environment">
        <h3>12.6環境</h3>
          </a>
        <p></p>
          <a name="os_argv_PROGRAM">
        <h4>12.6.1 argv(PROGRAM)</h4>
          </a>
        <p>機能<tt><span class="func">argv(PROGRAM)</span></tt>はプログラムの引数ベクトルを文字列の配列で返す。 プログラム名は、引数ベクトルの一部ではありません。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:argv(PROGRAM)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>引数ベクトルを含む文字列の配列。</p></dd></dl></div><p></p>
          <a name="os_name_PROGRAM">
        <h4>12.6.2 name(PROGRAM)</h4>
          </a>
        <p>機能<tt><span class="func">name(PROGRAM)</span></tt>パスと拡張子なしでプログラムの名前を返します。 によって返される名前。<tt><span class="func">name(PROGRAM)</span></tt>インタプリタ型プログラムとコンパイル型プログラムは同じです。 機能<tt><span class="func">name(PROGRAM)</span></tt>はシンボリックリンクを辿らない。 プログラムがどの名前で呼び出されたかを判別する。 複数のシンボリックリンクが同一のプログラムを指している場合<tt><span class="func">name(PROGRAM)</span></tt>はシンボリックリンク名を返す。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:name(PROGRAM)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>プログラムの名前。</p></dd></dl></div><p></p>
          <a name="os_path_PROGRAM">
        <h4>12.6.3 path(PROGRAM)</h4>
          </a>
        <p>機能<tt><span class="func">path(PROGRAM)</span></tt>プログラムの絶対パスを返します。 インタプリタ型プログラムの場合、これはソースファイルの絶対パスです。 コンパイルされたプログラムの場合、これは実行可能ファイルの絶対パスです。 機能<tt><span class="func">path(PROGRAM)</span></tt>はシンボリックリンクをたどる。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:path(PROGRAM)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>プログラムの絶対パスを指定します。</p></dd></dl></div><p></p>
          <a name="os_dir_PROGRAM">
        <h4>12.6.4 dir(PROGRAM)</h4>
          </a>
        <p>機能<tt><span class="func">dir(PROGRAM)</span></tt>プログラムが存在するディレクトリの絶対パスを返します。 機能<tt><span class="func">dir(PROGRAM)</span></tt>プログラムのディレクトリに構成データを格納することができます。<tt><span class="func">dir(PROGRAM)</span></tt>基づいている<tt><a class="func" href="#os_path_PROGRAM">path(PROGRAM)</a></tt></p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:dir(PROGRAM)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>プログラムを格納するディレクトリの絶対パス。</p></dd></dl></div><p></p>
          <a name="os_file_PROGRAM">
        <h4>12.6.5ファイル(PROGRAM)</h4>
          </a>
        <p>機能<tt><span class="func">ファイル(PROGRAM)</span></tt>パスなしでプログラムのファイル名を返します。<tt><span class="func">ファイル(PROGRAM)</span></tt>基づいている<tt><a class="func" href="#os_path_PROGRAM">path(PROGRAM)</a></tt></p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:file(PROGRAM)<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>プログラムのファイル名です。</p></dd></dl></div><p></p>
          <a name="os_getenv">
        <h4>12.6.6 getenv</h4>
          </a>
        <p>機能<tt><span class="func">getenv</span></tt>環境変数の値を決定する。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:getenv(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:名前)<span class="keywd">は</span></pre><p>機能<tt><span class="func">getenv</span></tt>は、与えられた<tt>&#39;name&#39;</tt>そのような環境変数が存在する場合、対応する<tt><a class="type" href="#types_string">文字列</a></tt>値が返されます。</p>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>環境変数の値。<span class="stri">&quot;&quot;</span>要求された環境変数が存在しない場合。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;name&#39;</tt>システム文字列の型か、結果を表示するのに十分なメモリがありません<tt><a class="type" href="#types_string">文字列</a></tt></dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd>&#39;name&#39;をシステム文字列タイプに変換できないか、システム関数がエラーを返します。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_setenv">
        <h4>12.6.7 setenv</h4>
          </a>
        <p>機能<tt><span class="func">setenv</span></tt>環境変数を追加または変更します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:setenv(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:name<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:value)<span class="keywd">は</span></pre><p>機能<tt><span class="func">setenv</span></tt>は、与えられた<tt>&#39;name&#39;</tt>このような環境変数が存在する場合、対応する値は次のように変更されます。<tt>&#39;value&#39;</tt>環境変数が指定された<tt>&#39;name&#39;</tt>新しい環境変数が存在する<tt>&#39;name&#39;</tt>値で<tt>&#39;value&#39;</tt>が作成されます。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;name&#39;</tt>または<tt>&#39;value&#39;</tt>システム文字列タイプに変更します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;name&#39;</tt>または<tt>&#39;value&#39;</tt>システム文字列型に変換できない場合、またはシステム関数がエラーを返した場合にのみ使用できます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_unsetenv">
        <h4>12.6.8 unsetenv</h4>
          </a>
        <p>機能<tt><span class="func">unsetenv</span></tt>環境変数を削除する。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:unsetenv(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:名前)<span class="keywd">は</span></pre><p>機能<tt><span class="func">unsetenv</span></tt>は、与えられた<tt>&#39;name&#39;</tt>そのような環境変数が存在する場合、それは環境から削除されます。 環境変数が指定された<tt>&#39;name&#39;</tt>が存在する場合、関数は成功し、環境は変更されません。</p>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>変換するためのメモリが不足しています<tt>&#39;name&#39;</tt>システム文字列タイプに変更します。</dd>
    <dt>
          <a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a>
        </dt>
        <dd><tt>&#39;name&#39;</tt>システム文字列型に変換できない場合、またはシステム関数がエラーを返した場合にのみ使用できます。</dd>
</dl></dd></dl></div><p></p>
          <a name="os_environment">
        <h4>12.6.9環境</h4>
          </a>
        <p>機能<tt><span class="func">環境</span></tt>環境変数名のリストを文字列の配列として返します。</p><pre class="indent">
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:環境<span class="keywd">は</span></pre>
  <div><dl><dt><p>戻り値:</p></dt><dd><p>環境変数名のリスト。</p></dd></dl></div>
  <div><dl><dt><p>例外:</p></dt><dd><dl>
    <dt>
          <a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a>
        </dt>
        <dd>結果を作成するためのメモリが不足しています。</dd>
</dl></dd></dl></div><p></p>
          <a name="database_file_start"></a>
        <p></p>
          <a name="database_DATABASE_ABSTRACTION_API">
        <h2>13データベース抽象化API</h2>
          </a>
        <p>Seed7は、データベース・アクセス用の抽象レイヤーを提供します。 クライアントのデータベースへのアクセス方法を定義するアプリケーション・プログラミング・インタフェース(API)があります。 Seed7では、アプリケーションとデータベース間の抽象化レイヤーとしてデータベース・ドライバを使用することで、データベースの独立性を実現しています。 MySQL、MariaDB、SQLLite、PostgreSQL、Oracle、Firebird、Interbase、Db2、Informix、SQL Serverの各データベース用のデータベースドライバがあります。 データベースには、ODBCインタフェースを介してアクセスすることもできます。 次の例ではデータベース抽象化APIを使用しています。</p><pre class="indent">



value;

value;

0;


currDb:=
);


statement:=
);

(ステートメント);




write(
);

;
writeln;

;

(currDb);

;

;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:dbDemo<span class="keywd">は</span><span class="keywd">機能</span>地域の<span class="keywd">var</span><span class="keywd">データベース</span>:currDb<span class="type">は</span><span class="keywd">データベース</span>var<span class="type"></span>sqlStatement<span class="keywd">:ステートメント</span>は<span class="type"></span>sqlStatement<span class="keywd">var</span><span class="type">整数</span>:index<span class="keywd">は</span>begin<a class="type" href="#types_integer">openDatabase</a>(<span class="keywd">DB_MYSQL</span><span class="keywd">&quot;testDb&quot;</span><span class="func">&quot;testUser&quot;</span><span class="var">&quot;testPassword&quot;</span>if<span class="stri">currDb</span>&lt;><span class="stri"></span>データベース<span class="stri">value</span>その時<span class="keywd">準備する</span>(currDb<span class="op">&quot;SELECT*FROM testTable&quot;</span>実行する<span class="type">一方で</span><span class="keywd">取ってくる</span>(ステートメント)<span class="func">do</span>の<span class="stri">索引</span>範囲<span class="func">1</span>へ<span class="keywd"></span>列数<span class="func">(ステートメント)</span>do<span class="keywd">列</span>(ステートメント、インデックス<span class="keywd">文字列</span>)<span class="keywd">&lt;&amp;</span><span class="keywd">&quot;、&quot;</span>終わり<span class="func"></span>の<span class="keywd">終わり</span><span class="func">一方で</span>クローズ<a class="type" href="#types_string">終わり</a><span class="op">if</span>終わり<span class="stri"></span>機能<span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="func"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span><span class="keywd"></span></pre>
          <a name="database_Opening_a_database_connection">
        <h3>13.1データベース接続を開く</h3>
          </a>
        <p>データベース接続を開くには、次のものを用意する必要があります。</p><ul>
    <li>使用するデータベースの種類。</li>
    <li>その<tt>ホスト</tt>データベースが実行されている場所。 空の<tt>ホスト</tt>名前(<tt><span class="stri">&quot;&quot;</span></tt>)ローカルマシンを指定します(<tt><span class="stri">&quot;localhost&quot;</span></tt>)。</li>
    <li>その<tt>ポート</tt>データベースにアクセスします。<tt>ポート</tt>0のはデータベースのデフォルトポートを指定します。</li>
    <li>その<tt>名前</tt>してください。</li>
    <li>データベース<tt>ユーザー</tt>名前。</li>
    <li>その<tt>パスワード</tt>します。</li>
</ul><p>データベースに応じて、対応するデータベースドライバを使用する必要があります。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  <tr><th>データベースの種類</th><th>ドライバー</th><th>デフォルトポート</th><th>コメント</th></tr>

  <tr><td>MySQL</td><td>DB_MYSQL</td><td>3306</td><td></td></tr>
  <tr><td>MariaDB</td><td>DB_MYSQL</td><td>3306</td><td></td></tr>
  <tr><td>SQLLite</td><td>DB_SQLITE</td><td></td><td>ホストは<tt><span class="stri">&quot;&quot;</span></tt>portは0でなければなりません。</td></tr>
  <tr><td>PostgreSQL</td><td>DB_POSTGRESQL</td><td>5432</td><td></td></tr>
  <tr><td>オラクル</td><td>DB_OCI</td><td>1521</td><td></td></tr>
  <tr><td>ファイアーバード</td><td>DB_FIRE</td><td></td><td></td></tr>
  <tr><td>インターベース</td><td>DB_FIRE</td><td></td><td></td></tr>
  <tr><td>Db2</td><td>DB_DB2</td><td>50000</td><td></td></tr>
  <tr><td>Informix</td><td>DB_INFORMIX</td><td>1526</td><td></td></tr>
  <tr><td>SQLサーバ</td><td>DB_SQL_SERVER</td><td>1433</td><td></td></tr>
  <tr><td>様々なDB</td><td>DB_ODBC</td><td></td><td>データベースに接続するのにODBCドライバが必要です。</td></tr>
  <tr><td>Sybaseベース</td><td>DB_TDS</td><td>1433</td><td>SQL ServerおよびSybaseをサポートします。</td></tr>
</table></dd></dl><p>データベースを開くための基本的な機能は次のとおりです。</p><pre class="indent">:ホスト

:dbName

:パスワード)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">データベース</span>:<b><span class="func">openDatabase</span></b>(<span class="keywd">で</span><span class="type">dbCategory</span>:ドライバ<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>で<span class="keywd"></span>整数<a class="type" href="#types_integer">:port</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">で</a><span class="keywd">文字列</span>:user<a class="type" href="#types_string">で</a><span class="keywd">文字列</span><a class="type" href="#types_string"></a></pre><p>次の文はそれぞれデータベースを開きます。</p><pre class="indent">
currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_MYSQL</span><span class="stri">「www.example.org」</span>,0<span class="stri">&quot;testDb&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="func">(</span>DB_MYSQL<span class="var"></span>&quot;192.0.2.235&quot;<span class="stri">,0</span>&quot;testDb&quot;<span class="stri"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="func">DB_POSTGRESQL</span><span class="var">&quot;1234:feed::dead:beef&quot;</span>,0<span class="stri">&quot;testDb&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_POSTGRESQL<span class="func"></span>&quot;localhost&quot;<span class="var">,0</span>&quot;testDb&quot;<span class="stri"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="stri">DB_OCI</span><span class="func">&quot;&quot;</span>,0<span class="var">&quot;aServiceName&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_OCI<span class="stri"></span>「www.example.org」<span class="func">,2345</span>&quot;aServiceName&quot;<span class="var"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="stri">DB_OCI</span><span class="stri">&quot;192.0.2.235&quot;</span>,0<span class="func">&quot;aSid&quot;</span><span class="var">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_DB2<span class="stri"></span>「www.example.org」<span class="stri">,0</span>&quot;testDb&quot;<span class="func"></span>&quot;testUser&quot;<span class="var"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="stri">DB_SQL_SERVER</span><span class="stri">&quot;192.168.1.13&quot;</span>,0<span class="stri">&quot;testDb&quot;</span><span class="func">&quot;testUser&quot;</span><span class="var">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_TDS<span class="stri"></span>&quot;192.168.1.13&quot;<span class="stri">,0</span>&quot;testDb&quot;<span class="stri"></span>&quot;testUser&quot;<span class="func"></span>&quot;testPassword&quot;<span class="var"></span><span class="stri"></span><span class="stri"></span><span class="stri"></span><span class="stri"></span></pre><p>その<tt>ホスト</tt>名前で指定することもできます(例:<tt><span class="stri">「www.example.org」</span></tt>)、IPv4アドレス(例:<tt><span class="stri">&quot;192.0.2.235&quot;</span></tt>)または、コロン表記のIPv6アドレス(例:<tt><span class="stri">&quot;1234:feed::dead:beef&quot;</span></tt>)。 指定する<tt><span class="stri">&quot;&quot;</span></tt>as<tt>ホスト</tt>手段<tt><span class="stri">&quot;localhost&quot;</span></tt></p>
          <a name="database_Opening_an_Oracle_database_connection">
        <h4>13.1.1 Oracleデータベース接続を開く</h4>
          </a>
        <p>When using the<tt><span class="var">DB_OCI</span></tt>ドライバを使用する場合は<tt>net_service_name</tt>から<tt><span class="stri">tnsnames.ora</span></tt>または<tt>サービス名</tt>または<tt>シド</tt>as<tt>データベース名</tt>If<tt><span class="stri">tnsnames.ora</span></tt>パラメータを使用する<tt>ホスト</tt>しなければならない<tt><span class="stri">&quot;&quot;</span></tt>そしてパラメータ<tt>ポート</tt>は、0でなければなりません。</p><pre class="indent">
currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_OCI</span><span class="stri">&quot;&quot;</span>,0<span class="stri">&quot;tnsnamesOraEntryName&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span></pre>
          <a name="database_Opening_a_Db2_database_connection">
        <h4>13.1.2 Db2データベース接続を開く</h4>
          </a>
        <p>When using the<tt><span class="var">DB_DB2</span></tt>ドライバを使用する場合は<tt>DSN</tt>(データソース名)から<tt><span class="stri">db2cli.ini</span></tt>(または<tt><span class="stri">db2dsdriver.cfg</span></tt>)または<tt>データベース名</tt>as<tt>データベース名</tt><tt>DSN</tt>パラメータを使用する<tt>ホスト</tt>しなければならない<tt><span class="stri">&quot;&quot;</span></tt>そしてパラメータ<tt>ポート</tt>は、0でなければなりません。</p><pre class="indent">
currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_DB2</span><span class="stri">&quot;&quot;</span>,0<span class="stri">&quot;databaseAlias&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span></pre>
          <a name="database_Opening_a_SQL_Server_database_connection">
        <h4>13.1.3 SQL Serverデータベース接続を開く</h4>
          </a>
        <p>When using the<tt><span class="var">DB_SQL_SERVER</span></tt>ドライバを使用する場合は<tt>データベース名</tt>ローカルマシンから、またはTCP/IP経由でアクセス可能なデータベースから ローカルマシンのデータベースにアクセスするには、パラメータ<tt>ホスト</tt>しなければならない<tt><span class="stri">&quot;&quot;</span></tt>そしてパラメータ<tt>ポート</tt>は、0にする必要があります。TCP/IPを使用する場合は、データベースで使用可能にする必要があります。</p><pre class="indent">
currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_SQL_SERVER</span><span class="stri">&quot;&quot;</span>,0<span class="stri">&quot;localDb&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span></pre>
          <a name="database_Opening_a_SQLite_database_connection">
        <h4>13.1.4 SQLiteデータベース接続を開く</h4>
          </a>
        <p>SQLiteデータベースは次のようにして開くことができます。</p><pre class="indent">
currDb:=
);

currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_SQLITE</span><span class="stri">&quot;&quot;</span>,0<span class="stri">&quot;aDir/dbName&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span>openDatabase<span class="func">(</span>DB_SQLITE<span class="var"></span>&quot;&quot;<span class="stri">,0</span>&quot;aDir/dbName.db&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri">openDatabase</span>(<span class="func">DB_SQLITE</span><span class="var">&quot;&quot;</span>,0<span class="stri">&quot;/c/Users/JohnSmith/dbName&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri"></span></pre><p>データベースファイルへのパス(上記の例では<tt><span class="stri">&quot;aDir/dbName&quot;</span></tt>)Seed7を使用する必要があります<a class="link" href="#os_Standard_path_representation">標準経路表現</a>データベース・ファイルが相対パスで指定されている場合、現在の作業ディレクトリに相対的なディレクトリが検索されます。 データベースファイル名は拡張子の有無にかかわらず指定できます。<tt><span class="stri">&quot;.db&quot;</span></tt>SQLiteデータベースの場合<tt>ホスト</tt>しなければならない<tt><span class="stri">&quot;&quot;</span></tt>および<tt>ポート</tt>は、0でなければなりません。 SQLiteはこれなしでも動作します。<tt>ユーザー</tt>および<tt>パスワード</tt>パラメータ<tt>ユーザー</tt>および<tt>パスワード</tt>は常に無視されます。</p>
          <a name="database_Opening_an_Informix_database_connection">
        <h4>13.1.5 Informixデータベース接続をオープンしています。</h4>
          </a>
        <p>When using the<tt><span class="var">DB_INFORMIX</span></tt>も指定する必要があります。<tt>サーバー</tt>:</p><pre class="indent">:port

:dbName

:パスワード)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">データベース</span>:<b><span class="func">openDatabase</span></b>(<span class="var">DB_INFORMIX</span><span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:ホスト<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:サーバ</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">で</a><span class="keywd">文字列</span>:user<a class="type" href="#types_string">で</a><span class="keywd">文字列</span><a class="type" href="#types_string"></a></pre><p>Informixデータベースは次のようにして開くことができます。</p><pre class="indent">
currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_INFORMIX</span><span class="stri">&quot;&quot;</span>,0<span class="stri">&quot;serverName&quot;</span><span class="stri">&quot;データベース名&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="func">(</span>DB_INFORMIX<span class="var"></span>「www.example.org」<span class="stri">,0</span>&quot;testServer&quot;<span class="stri"></span>&quot;testDb&quot;<span class="stri"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri"></span></pre>
          <a name="database_Opening_an_ODBC_database_connection">
        <h4>13.1.6 ODBCデータベース接続を開く</h4>
          </a>
        <p>Seed7データベースドライバ<tt><span class="var">DB_ODBC</span></tt>は、ODBCインタフェース自体で複数のデータベースタイプへの接続が可能であるという点で特殊です。 ODBCインタフェース・ライブラリは、ODBCドライバを使用してこれを実現します。 残念ながら、これらのドライバの品質にはばらつきがあります。 Seed7ドライバを介してデータベースに直接アクセスすることをお勧めします。 SQL Serverの場合、ODBCが唯一の接続インタフェースです。 ODBCデータベースを開くには、次の関数を使用します。</p><pre class="indent">:odbcDriver

:dbName

:パスワード)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">データベース</span>:<b><span class="func">openDatabase</span></b>(<span class="var">DB_ODBC</span><span class="keywd">で</span><a class="type" href="#types_string">文字列</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:サーバ</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">で</a><span class="keywd">文字列</span>:user<a class="type" href="#types_string">で</a><span class="keywd">文字列</span><a class="type" href="#types_string"></a></pre><p>SQL Serverは次のもので開くことができます。</p><pre class="indent">
currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_ODBC</span><span class="stri">&quot;sqlserver&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="func">(</span>DB_ODBC<span class="var"></span>&quot;sqlserver&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span></pre><p>もし<tt>サーバー</tt>または<tt>データベース名</tt>が空(<tt><span class="stri">&quot;&quot;</span></tt>)ODBCドライバのデフォルト値が使用されます。 ODBCドライバは、次のデフォルト値も提供します。<tt>ユーザー</tt>および<tt>パスワード</tt></p><p>ODBCでは、データソース名(DSN)も使用して、使用可能なデータベース接続を指定します。 パラメータにデータソース名(DSN)を指定して、ODBCデータベースを開くことができます。<tt>データベース名</tt>この場合、パラメータは<tt>odbcDriver</tt>および<tt>サーバー</tt>しなければならない<tt><span class="stri">&quot;&quot;</span></tt></p><pre class="indent">
currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_ODBC</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;dsnName&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="func">(</span>DB_ODBC<span class="var"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;dsnName&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span></pre><p>DSNを使用して開くことに成功した場合、パラメータは<tt>odbcDriver</tt>および<tt>サーバー</tt>は無視されます。 DSNでは、次のように指定することもできます。<tt>ユーザー</tt>および<tt>パスワード</tt>この場合、パラメータは空のままにしておくことができます。<tt><span class="func">openDatabase</span>()</tt>が呼び出されます。</p><p>ウィンドウを使用する場合、DSNおよびODBCドライバは次のもので管理できます。</p><dl><dd>「スタート」>「コントロールパネル」>「管理ツール」>「データ・ソース(ODBC)」を選択します。</dd></dl><p>unixODBCのデータ・ソース名(DSN)は、次のファイルに指定されています。<tt><span class="stri">odbc.ini</span></tt>unixODBCのODBCドライバは、ファイルに指定されています。<tt><span class="stri">odbcinst.ini</span></tt></p>
          <a name="database_Other_ways_to_open_a_database_connection">
        <h3>13.2データベース接続を開くその他の方法</h3>
          </a>
        <p>データベースを開くには、次の方法もあります。</p><pre class="indent">:dbPath

:パスワード)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">データベース</span>:<b><span class="func">openDatabase</span></b>(<span class="keywd">で</span><span class="type">dbCategory</span>:ドライバ<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string">:user</a>で<span class="keywd"></span>文字列<a class="type" href="#types_string"></a></pre><p>その<tt>dbPath</tt>は、次のいずれかの形式で与えられます。</p><ul>
    <li>host:port/dbName</li>
    <li>ホスト/データベース名</li>
    <li>データベース名</li>
</ul><p>その<tt>ホスト</tt>名前で指定することもできます(例:<tt><span class="stri">「www.example.org」</span></tt>)、またはIPv4アドレス(例:<tt><span class="stri">&quot;192.0.2.235&quot;</span></tt>)または、コロン表記のIPv6アドレスで(例:<tt><span class="stri">&quot;[1234:feed::dead:beef]&quot;</span></tt>)。 IPv6アドレスはカッコで囲む必要があります。 もし<tt>ホスト</tt>がデフォルトホスト(<tt><span class="stri">&quot;localhost&quot;</span></tt>)を使用します。 もし<tt>ポート</tt>が指定されていない場合、ドライバのデフォルトポートが使用されます。 次の文はそれぞれデータベースを開きます。</p><pre class="indent">
currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_MYSQL</span><span class="stri">&quot;www.example.org:1234/testDb&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="func">(</span>DB_MYSQL<span class="var"></span>&quot;[1234:feed::dead:beef]:1234/testDb&quot;<span class="stri"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="func">DB_POSTGRESQL</span><span class="var">&quot;192.0.2.235/testDb&quot;</span><span class="stri">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_POSTGRESQL<span class="func"></span>&quot;testDb&quot;<span class="var"></span>&quot;testUser&quot;<span class="stri"></span>&quot;testPassword&quot;<span class="stri">openDatabase</span>(<span class="stri">DB_OCI</span><span class="func">&quot;sidOrServiceName&quot;</span><span class="var">&quot;testUser&quot;</span><span class="stri">&quot;testPassword&quot;</span>openDatabase<span class="stri">(</span>DB_OCI<span class="stri"></span>&quot;tnsnamesOraEntryName&quot;<span class="func"></span>&quot;testUser&quot;<span class="var"></span>&quot;testPassword&quot;<span class="stri"></span><span class="stri"></span><span class="stri"></span></pre><p>もし<tt>ドライバー</tt>は<tt><span class="var">DB_ODBC</span></tt>その<tt>dbPath</tt>は、次のいずれかの形式で指定できます。</p><ul>
    <li>odbcDriver:dbServer/dbName</li>
    <li>odbcDriver:dbServer</li>
    <li>dbServer/dbName</li>
    <li>odbcDataSourceName</li>
</ul><p>次のような値を使用します。<tt><span class="stri">&quot;sqlserver&quot;</span></tt>の<tt>odbcDriver</tt></p><p>もし<tt>ドライバー</tt>は<tt><span class="var">DB_SQLITE</span></tt>その時<tt>dbPath</tt>はデータベースファイルのパスです。</p><ul>
    <li>sqlitePath</li>
</ul><p>その<tt>sqlitePath</tt>Seed7を使用します。<a class="link" href="#os_Standard_path_representation">標準経路表現</a>If<tt>sqlitePath</tt>が相対パスの場合、データベースファイルは現在の作業ディレクトリからの相対パスで検索されます。 データベースファイル名は拡張子の有無にかかわらず指定できます。<tt><span class="stri">&quot;.db&quot;</span></tt>次の文はそれぞれSQLiteデータベースを開きます。</p><pre class="indent">
currDb:=
);

currDb:=
);

currDb:=
);
<span class="func">openDatabase</span>(<span class="var">DB_SQLITE</span><span class="stri">&quot;aDir/dbName&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span>openDatabase<span class="func">(</span>DB_SQLITE<span class="var"></span>&quot;aDir/dbName.db&quot;<span class="stri"></span>&quot;&quot;<span class="stri"></span>&quot;&quot;<span class="stri">openDatabase</span>(<span class="func">DB_SQLITE</span><span class="var">&quot;/c/Users/JohnSmith/dbName&quot;</span><span class="stri">&quot;&quot;</span><span class="stri">&quot;&quot;</span><span class="stri"></span></pre><p>接続文字列を使用してデータベースを開くこともできます。</p><pre class="indent">:connectStri)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">データベース</span>:<b><span class="func">openDatabase</span></b>(<span class="keywd">で</span><span class="type">dbCategory</span>:ドライバ<span class="keywd">で</span><a class="type" href="#types_string">文字列</a></pre><p>その<tt>connectStri</tt>いずれかの形式である必要があります。</p><ul>
    <li>user:password@dbPath</li>
    <li>user@dbPath</li>
    <li>dbPath</li>
</ul><p>もしそうでなければ<tt>ユーザー</tt>が指定された場合<tt><span class="stri">「ゲスト」</span></tt>が使用されます。 もしそうでなければ<tt>パスワード</tt>パスワードが指定されます。<tt><span class="stri">「ゲスト」</span></tt>が使用されます。 その<tt>dbPath</tt>は前と同じように指定されます。</p>
          <a name="database_Prepared_statements">
        <h3>13.3準備文</h3>
          </a>
        <p>すべてのSQL文(SELECT、CREATE、INSERT、UPDATEなど)は、プリペアドステートメントを使用して実行できます。 データベース抽象化APIでは、準備文なしでSQLを実行することはできません。 準備文が作成されると、それは複数回実行されることがあります。 データベースは通常、実行を高速化するために準備文を最適化します。 準備文は以下の関数で作成されます。</p><pre class="indent">:sqlStatementStr)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><span class="type">sqlStatement</span>:<b><span class="func">準備する</span></b>(<span class="keywd">で</span><span class="type">データベース</span>:db<span class="keywd">で</span><a class="type" href="#types_string">文字列</a></pre><p>パラメータについて<tt>sqlStatementStr</tt>いくつかのことを考慮しなければならない。</p><ul>
    <li>疑問符(<tt></tt>)がバインド変数のプレースホルダとして使用されます。</li>
    <li>SQL文の文字列をアポストロフィで囲む(例:<tt>&#39;abc&#39;</tt>)。<ul>
      <li>ストリングは、前後のアポストロフィで囲まれたすべての文字からなります。</li>
      <li>アポストロフィ文字(<tt>&#39;</tt>)は、文字列内に1つのアポストロフィ文字を取得するために2倍にする必要があります。</li></ul></li>
    <li>SQL文内のコメントはで始まります。<tt>/*</tt>で終わる<tt>*/</tt></li>
    <li>SQL文内の行コメントはで始まります。<tt>--</tt>で始まり、改行復帰文字(<tt>&#39;\n&#39;</tt>)。</li>
    <li>テーブル名とフィールド名は二重引用符で囲みます(例:<tt>&quot;aTable&quot;</tt>)。<ul>
      <li>この方法では、テーブルまたはフィールド名に、通常は許可されないスペースやその他の文字が含まれる場合があります。</li>
      <li>引用符内の二重引用符は二重にする必要があります(データベースによっては二重引用符を使用できない場合があることに注意してください)。</li></ul></li>
</ul><p>次の文はそれぞれ、準備されたSQL文を作成します。</p><pre class="indent">
statement:=
);

statement:=
);

statement:=
);

statement:=
);

statement:=
);

statement:=
);

statement:=
);
<span class="func">準備する</span>(currDb<span class="stri">&quot;CREATE TABLE customers(name CHAR(128),area CHAR(128))&quot;</span>準備する<span class="func">(currDb</span>&quot;SELECT*FROM customers&quot;<span class="stri">準備する</span>(currDb<span class="func">&quot;SELECT*FROM customers/*comment*/WHERE name=&#39;adam&#39;&quot;</span>準備する<span class="stri">(currDb</span>&quot;SELECT*FROM customers--Comment\n WHERE name!=&#39;adam&#39;&quot;<span class="func">準備する</span>(currDb<span class="stri">&quot;SELECT*FROM customerS WHERE name=?&quot;</span>準備する<span class="func">(currDb</span>&quot;SELECT*FROM customers WHERE name LIKE&#39;&#39;&#39;&#39;%&#39;&#39;&quot;<span class="stri">準備する</span>(currDb<span class="func">&quot;SELECT\&quot;a field\&quot;FROM\&quot;a table\&quot;&quot;</span><span class="stri"></span><span class="func"></span><span class="stri"></span></pre><p>文の準備が失敗し<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>データベースが開いていない場合。 ドライバによって確認されます。 その他の事項は、データベースでチェックされます。 データベースは例外を上げるかもしれない。<tt><a class="exception" href="#errors_DATABASE_ERROR">DATABASE_ERROR</a></tt>一部のデータベースでは、文を準備するときにすべてをチェックしないことに注意してください。 したがって、無効なSQL文が<tt><span class="func">準備する</span>()</tt>しかし、準備文を後で実行すると失敗します。</p><p>バインド変数を持たず、結果を返さない準備済文の実行は非常に簡単です。</p><pre class="indent">
statement:=
);

(ステートメント);
<span class="func">準備する</span>(currDb<span class="stri">&quot;CREATE TABLE customers(name CHAR(128),area CHAR(128))&quot;</span>実行する<span class="func"></span></pre><p></p>
          <a name="database_Bind_values_to_placeholders">
        <h3>13.4プレースホルダへの値のバインド</h3>
          </a>
        <p>疑問符(<tt></tt>)がバインド変数のプレースホルダとして使用されます。 プリペアドステートメントが実行される前に、値をプレースホルダ(<tt></tt>)。 プレースホルダのない準備文は、結合を必要としません。 同じプレースホルダは何回でもバインドできます。 異なるタイプの値であっても。 これは、準備された同じ文を異なる値で複数回実行するために使用できます。 結束は<tt><span class="func">拘束する</span>()</tt>関数を使用します。 いくつかのタイプについて<tt><span class="func">拘束する</span>()</tt>関数が定義されている。</p><pre class="indent">:num)


:num)


:flag)


:bstri)


:番号)


:番号)


:pos、NULL)


:stri)


:timeData)


:durationData)
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:<b><span class="func">拘束する</span></b>(<span class="keywd">入力する</span><span class="type">sqlStatement</span>:ステートメント<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:pos<span class="keywd">で</span><a class="type" href="#types_bigInteger">bigInteger</a>const<span class="keywd"></span>proc<a class="type" href="#types_proc">:</a>拘束する<b><span class="func">(</span></b>入力する<span class="keywd"></span>sqlStatement<span class="type">:ステートメント</span>で<span class="keywd"></span>整数<a class="type" href="#types_integer">:pos</a>で<span class="keywd"></span>bigRational<a class="type" href="#types_bigRational">const</a><span class="keywd">proc</span>:<a class="type" href="#types_proc">拘束する</a>(<b><span class="func">入力する</span></b><span class="keywd">sqlStatement</span>:ステートメント<span class="type">で</span><span class="keywd">整数</span>:pos<a class="type" href="#types_integer">で</a><span class="keywd">ブール</span>const<a class="type" href="#types_boolean"></a>proc<span class="keywd">:</span>拘束する<a class="type" href="#types_proc">(</a>入力する<b><span class="func"></span></b>sqlStatement<span class="keywd">:ステートメント</span>で<span class="type"></span>整数<span class="keywd">:pos</span>で<a class="type" href="#types_integer"></a>bstring<span class="keywd">const</span><span class="type">proc</span>:<span class="keywd">拘束する</span>(<a class="type" href="#types_proc">入力する</a><b><span class="func">sqlStatement</span></b>:ステートメント<span class="keywd">で</span><span class="type">整数</span>:pos<span class="keywd">で</span><a class="type" href="#types_integer">浮かぶ</a>const<span class="keywd"></span>proc<a class="type" href="#types_float">:</a>拘束する<span class="keywd">(</span>入力する<a class="type" href="#types_proc"></a>sqlStatement<b><span class="func">:ステートメント</span></b>で<span class="keywd"></span>整数<span class="type">:pos</span>で<span class="keywd"></span>整数<a class="type" href="#types_integer">const</a><span class="keywd">proc</span>:<a class="type" href="#types_integer">拘束する</a>(<span class="keywd">入力する</span><a class="type" href="#types_proc">sqlStatement</a>:ステートメント<b><span class="func">で</span></b><span class="keywd">整数</span>const<span class="type"></span>proc<span class="keywd">:</span>拘束する<a class="type" href="#types_integer">(</a>入力する<span class="keywd"></span>sqlStatement<a class="type" href="#types_proc">:ステートメント</a>で<b><span class="func"></span></b>整数<span class="keywd">:pos</span>で<span class="type"></span>文字列<span class="keywd">const</span><a class="type" href="#types_integer">proc</a>:<span class="keywd">拘束する</span>(<a class="type" href="#types_string">入力する</a><span class="keywd">sqlStatement</span>:ステートメント<a class="type" href="#types_proc">で</a><b><span class="func">整数</span></b>:pos<span class="keywd">で</span><span class="type">時間</span>const<span class="keywd"></span>proc<a class="type" href="#types_integer">:</a>拘束する<span class="keywd">(</span>入力する<a class="type" href="#types_time"></a>sqlStatement<span class="keywd">:ステートメント</span>で<a class="type" href="#types_proc"></a>整数<b><span class="func">:pos</span></b>で<span class="keywd"></span>持続時間<span class="type"></span><span class="keywd"></span><a class="type" href="#types_integer"></a><span class="keywd"></span><a class="type" href="#types_duration"></a></pre><p>での結合が失敗します。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>文が<a class="link" href="#database_Prepared_statements">用意された</a>綴じ方は役職で行います。 位置番号は1から始まります。 をバインドするには<tt><a class="type" href="#types_integer">整数</a></tt>12345から3番目のプレースホルダ(<tt></tt>)を作成します。</p><pre class="indent">(statement, 3, 12345);
<span class="func">拘束する</span></pre><p>その<tt><span class="func">拘束する</span>()</tt>関数は与えられた位置(<tt>pos</tt>)、例外を挙げる<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>対応するプレースホルダがない場合(<tt></tt>)が見つかった。 これは、次の場合に発生します<tt>pos&lt;=0</tt>保持するか、または<tt>pos</tt>が、プレースホルダの数より大きい。 その<tt><span class="func">拘束する</span>()</tt>関数は、指定された値の型がデータベース列にフィットするかどうかもチェックします。 型が例外に該当しない場合<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>を上げます。</p><p>次にbindingの例をもう1つ示します。</p><pre class="indent">
write(
);
readln(name);
statement:=
);

(statement, 1, name);

(ステートメント);
……名前と地域のリストを書きます。
<span class="stri">&quot;名前?&quot;</span>準備する<span class="func">(currDb</span>&quot;SELECT name, area FROM customers WHERE name=?&quot;<span class="stri">拘束する</span>実行する<span class="func"></span><span class="func"></span></pre><p>バインディングはSQLインジェクションを防ぎます。 SQLインジェクションは、アプリケーションを攻撃する手法です。 ユーザー入力からSQL文をビルドする場合は、SQLインジェクションが可能です。 上の例をバインドせずに実行するとします。</p><pre class="indent">
write(
);
readln(name);
statement:=
);

(ステートメント);
……名前と地域のリストを書きます。
<span class="stri">&quot;名前?&quot;</span>準備する<span class="func">(currDb</span>&quot;SELECT name, area FROM customers WHERE name=&#39;&quot;<span class="stri">&lt;&amp;name&lt;&amp;</span>&quot;&quot;&quot;<span class="stri">実行する</span><span class="func"></span></pre><p>たとえば、ユーザーが(<tt>名前</tt>):</p><pre class="indent">&#39;UNION SELECTログイン、パスワードFROM user--
</pre><p>これにより、次のSQL文が準備され、実行されます。</p><pre class="indent">SELECT name, area FROM customers WHERE name=&#39;&#39;UNION SELECT login, password FROM user--&#39;&#39;
</pre><p>その結果、表示されたくない秘密のデータがさらに含まれることになります。</p>
          <a name="database_Execute_a_prepared_statement">
        <h3>13.5準備文の実行</h3>
          </a>
        <p>プリペアードステートメントを実行するには、それを実行する必要があります。 準備文は以下の関数で実行されます。</p><pre class="indent">:statement)
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:<b><span class="func">実行する</span></b>(<span class="keywd">入力する</span><span class="type">sqlStatement</span></pre><p>次の文は、準備されたSQL文を実行します。</p><pre class="indent">(ステートメント);
<span class="func">実行する</span></pre><p>実行が失敗し<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>文が準備されていない場合。 実行が失敗し<tt><a class="exception" href="#errors_DATABASE_ERROR">DATABASE_ERROR</a></tt>すべてのパラメータが一致していない場合は<a class="link" href="#database_Bind_values_to_placeholders">縛られた</a>データベースがエラーを返した場合は、例外<tt><a class="exception" href="#errors_DATABASE_ERROR">DATABASE_ERROR</a></tt>育てられるのです 無効なSQL文では<tt><a class="exception" href="#errors_DATABASE_ERROR">DATABASE_ERROR</a></tt>で<tt><span class="func">準備する</span>()</tt>または<tt><span class="func">実行する</span>()</tt>例外が発生するタイミングは、データベースによって異なります。</p><p>レコードの結果セットを返す準備された文(例:SELECT)と、データを返さない文(例:UPDATE)があります。 新<a class="link" href="#database_Execute_a_prepared_statement">実行する</a>プリペアードステートメント次の関数を使用して、結果セットのレコード(行)の列数を取得できます。</p><pre class="indent">:statement)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:<b><span class="func">列数</span></b>(<span class="keywd">で</span><span class="type">sqlStatement</span></pre><p>プリペアードステートメントがデータを返さない場合<tt><span class="func">列数</span>()</tt>は0を返す。 結果セットのレコード(行)にある列の名前は、次の関数で取得できます。</p><pre class="indent">:列)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:<b><span class="func">列名</span></b>(<span class="keywd">で</span><span class="type">sqlStatement</span>:ステートメント<span class="keywd">で</span><a class="type" href="#types_integer">整数</a></pre><p>これらの関数を組み合わせて、準備文の列名を記述することができます。</p><pre class="indent">(ステートメント);


write(
);

;
writeln;
<span class="func">実行する</span>の<span class="keywd">列番号</span>範囲<span class="keywd">1</span>へ<span class="keywd"></span>列数<span class="func">(ステートメント)</span>do<span class="keywd">列名</span>(statement, columnNum)&lt;&amp;<span class="func">&quot;&quot;</span>終わり<span class="stri"></span>の<span class="keywd"></span><span class="keywd"></span></pre>
          <a name="database_Fetch_records_from_the_result_set">
        <h3>13.6結果セットからレコードを取得する</h3>
          </a>
        <p>新<a class="link" href="#database_Execute_a_prepared_statement">実行する</a>データを返す準備された文(例:SELECT)では、以下のようにレコード(行)を1行ずつ取り出すことができます。<tt><span class="func">取ってくる</span>()</tt>後<a class="link" href="#database_Execute_a_prepared_statement">実行する</a>データのフェッチを行わないプリペアードステートメントは必要ありません。 フェッチは次の関数で行われます。</p><pre class="indent">:statement)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:<b><span class="func">取ってくる</span></b>(<span class="keywd">で</span><span class="type">sqlStatement</span></pre><p>この関数は次の値を返します。<tt><span class="var">TRUE</span></tt>結果セットのレコードを正常にフェッチできた場合。 この関数は次の値を返します。<tt><span class="var">FALSE</span></tt>データがない場合(例:UPDATE)、または取得する行(レコード)がこれ以上ない場合。 以下の例は、その方法を示しています。<tt><span class="func">取ってくる</span>()</tt>は通常次のように使用されます</p><pre class="indent">(ステートメント);
一方で
(statement)do
結果セットからレコードを処理します。
end while;
<span class="func">実行する</span>取ってくる<span class="func"></span></pre><p></p>
          <a name="database_Get_columns_from_fetched_records">
        <h3>13.7フェッチされたレコードからの列の取得</h3>
          </a>
        <p>レコード(行)が<a class="link" href="#database_Fetch_records_from_the_result_set">取得</a>を使用して、結果セットから個々のカラム・データを取得できます。<tt><span class="func">列</span>()</tt>関数を使用します。 いくつかのタイプについて<tt><span class="func">列</span>()</tt>関数が定義されている。</p><pre class="indent">)


)


)


)


)


)


)


)


)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_bigInteger">bigInteger</a>:<b><span class="func">列</span></b>(<span class="keywd">で</span><span class="type">sqlStatement</span>:ステートメント<span class="keywd">で</span><a class="type" href="#types_integer">整数</a>:列<a class="keywd_no_ul" href="#params_attr_parameter">attr</a><a class="type" href="#types_bigInteger">bigInteger</a>const<span class="keywd"></span>機能<a class="type" href="#types_func"></a>bigRational<a class="type" href="#types_bigRational">:</a>列<b><span class="func">(</span></b>で<span class="keywd"></span>sqlStatement<span class="type">:ステートメント</span>で<span class="keywd"></span>整数<a class="type" href="#types_integer">:列</a>attr<a class="keywd_no_ul" href="#params_attr_parameter"></a>bigRational<a class="type" href="#types_bigRational">const</a><span class="keywd">機能</span><a class="type" href="#types_func">ブール</a>:<a class="type" href="#types_boolean">列</a>(<b><span class="func">で</span></b><span class="keywd">sqlStatement</span>:ステートメント<span class="type">で</span><span class="keywd">整数</span>:列<a class="type" href="#types_integer">attr</a><a class="keywd_no_ul" href="#params_attr_parameter">ブール</a>const<a class="type" href="#types_boolean"></a>機能<span class="keywd"></span>bstring<a class="type" href="#types_func">:</a>列<span class="type">(</span>で<b><span class="func"></span></b>sqlStatement<span class="keywd">:ステートメント</span>で<span class="type"></span>整数<span class="keywd">:列</span>attr<a class="type" href="#types_integer"></a>bstring<a class="keywd_no_ul" href="#params_attr_parameter">const</a><span class="type">機能</span><span class="keywd">持続時間</span>:<a class="type" href="#types_func">列</a>(<a class="type" href="#types_duration">で</a><b><span class="func">sqlStatement</span></b>:ステートメント<span class="keywd">で</span><span class="type">整数</span>:列<span class="keywd">attr</span><a class="type" href="#types_integer">持続時間</a>const<a class="keywd_no_ul" href="#params_attr_parameter"></a>機能<a class="type" href="#types_duration"></a>浮かぶ<span class="keywd">:</span>列<a class="type" href="#types_func">(</a>で<a class="type" href="#types_float"></a>sqlStatement<b><span class="func">:ステートメント</span></b>で<span class="keywd"></span>整数<span class="type">:列</span>attr<span class="keywd"></span>浮かぶ<a class="type" href="#types_integer">const</a><a class="keywd_no_ul" href="#params_attr_parameter">機能</a><a class="type" href="#types_float">整数</a>:<span class="keywd">列</span>(<a class="type" href="#types_func">で</a><a class="type" href="#types_integer">sqlStatement</a>:ステートメント<b><span class="func">で</span></b><span class="keywd">整数</span>:列<span class="type">attr</span><span class="keywd">整数</span>const<a class="type" href="#types_integer"></a>機能<a class="keywd_no_ul" href="#params_attr_parameter"></a>文字列<a class="type" href="#types_integer">:</a>列<span class="keywd">(</span>で<a class="type" href="#types_func"></a>sqlStatement<a class="type" href="#types_string">:ステートメント</a>で<b><span class="func"></span></b>整数<span class="keywd">:列</span>attr<span class="type"></span>文字列<span class="keywd">const</span><a class="type" href="#types_integer">機能</a><a class="keywd_no_ul" href="#params_attr_parameter">時間</a>:<a class="type" href="#types_string">列</a>(<span class="keywd">で</span><a class="type" href="#types_func">sqlStatement</a>:ステートメント<a class="type" href="#types_time">で</a><b><span class="func">整数</span></b>:列<span class="keywd">attr</span><span class="type">時間</span><span class="keywd"></span><a class="type" href="#types_integer"></a><a class="keywd_no_ul" href="#params_attr_parameter"></a><a class="type" href="#types_time"></a></pre><p>で列の取得に失敗する。<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>これまでに記録がない場合は<a class="link" href="#database_Fetch_records_from_the_result_set">取得</a>を検索します。 段番号は1から始まります。 現在の結果レコード(行)から4番目の列を<tt><a class="type" href="#types_integer">整数</a></tt>do:</p><pre class="indent">);
<span class="func">列</span>(ステートメント、4<a class="type" href="#types_integer">整数</a></pre><p>その<tt><span class="func">列</span>()</tt>関数は与えられた位置(<tt>列</tt>)、例外を挙げる<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>結果レコードに対応する列が存在しない場合 これは、次の場合に発生します<tt>列&lt;=0</tt>は<tt><span class="var">TRUE</span></tt>または<tt>列</tt>は、カラムの数(この値は<tt><span class="func">列数</span>()</tt>)。 データベース列は次のことができます。<tt>ヌル</tt>これは次の関数で確認できます。</p><pre class="indent">:列)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>:<b><span class="func">isNull</span></b>(<span class="keywd">で</span><span class="type">sqlStatement</span>:ステートメント<span class="keywd">で</span><a class="type" href="#types_integer">整数</a></pre><p>機能<tt><span class="func">isNull</span>()</tt>戻り値<tt><span class="var">TRUE</span></tt>指定されたカラムが<tt>ヌル</tt>そうでなければ<tt><span class="func">isNull</span>()</tt>戻り値<tt><span class="var">FALSE</span></tt>その<tt><span class="func">列</span>()</tt>関数は、列が以下の場合、デフォルト値を返します。<tt>ヌル</tt>次のデフォルト値が使用されます。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  <tr><th>タイプ</th><th>既定値</th></tr>

  <tr><td>
          <tt>
            <a class="type" href="#types_bigInteger">bigInteger</a>
          </tt>
        </td><td>
          <tt>0_</tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_bigRational">bigRational</a>
          </tt>
        </td><td>
          <tt>0_/1_</tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_boolean">ブール</a>
          </tt>
        </td><td>
          <tt>
            <span class="var">FALSE</span>
          </tt>
        </td></tr>
  <tr><td>
          <tt>
            <span class="type">bstring</span>
          </tt>
        </td><td><tt><span class="func">bstring</span>(<span class="stri">&quot;&quot;</span>)</td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_duration">持続時間</a>
          </tt>
        </td><td>
          <tt><a class="type" href="#types_duration">持続時間</a>value</tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_float">浮かぶ</a>
          </tt>
        </td><td>
          <tt>0.0</tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_integer">整数</a>
          </tt>
        </td><td>
          <tt>0</tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_string">文字列</a>
          </tt>
        </td><td>
          <tt>
            <span class="stri">&quot;&quot;</span>
          </tt>
        </td></tr>
  <tr><td>
          <tt>
            <a class="type" href="#types_time">時間</a>
          </tt>
        </td><td>
          <tt><a class="type" href="#types_time">時間</a>value</tt>
        </td></tr>
</table></dd></dl><p></p>
          <a name="graphic_file_start"></a>
        <p></p>
          <a name="graphic_GRAPHIC_LIBRARY">
        <h2>14. 図表ライブラリ</h2>
          </a>
        <p>Seed7はポータブルなグラフィックライブラリを提供します。<a name="graphic_hello_world">以下は、グラフィックな「hello world」プログラムです。</a>:</p><pre class="indent">
$
;

;






);

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">s7i<span class="lib">&quot;</span>const</span><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type" href="#types_proc">is func</a>begin<span class="keywd">messageWindow</span>(<span class="keywd">&quot;hello world&quot;</span>関数終了<span class="func"></span><span class="stri"></span><span class="keywd"></span></pre><p>このプログラムは、「hello world」というメッセージを含むポップアップ・ウィンドウを表示します。 ポップアップウィンドウには、プログラムを終了するOKボタンがあります。 空のウィンドウとメッセージ・ポップアップを作成するプログラムは次のとおりです。</p><pre class="indent">
$
;

;






(640、480);

);

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">s7i<span class="lib">&quot;</span>const</span><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type" href="#types_proc">is func</a>begin<span class="keywd">衝立て</span>messageWindow<span class="keywd">(</span>&quot;hello world&quot;<span class="func">関数終了</span><span class="func"></span><span class="stri"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">衝立て</span>(640、480)</tt>幅640、高さ480のウィンドウが開きます。 窓が変数に割り当てられます。<tt><span class="var">勝利</span></tt>これは描画機能でデフォルトのウィンドウとして使用されます。</p><p>メッセージボックスなしで空のウィンドウを表示するには、次のようにします。</p><pre class="indent">
$
;

;

;






(640、480);

));

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">draw.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<a class="keywd_no_ul" href="#decls_Procedure_declarations">:main</a>is func<a class="type" href="#types_proc">begin</a>衝立て<span class="keywd">無視する</span>(<span class="keywd">getc</span>(<span class="func">グラフ_キーボード</span>関数終了<a class="func" href="#stats_Ignoring_values"></a><span class="func"></span><span class="var"></span><span class="keywd"></span></pre><p>このプログラムはキーが押されるまで待ちます。 キーが読み込まれます。<tt><span class="var">グラフ_キーボード</span></tt>から読まずに<tt><span class="var">グラフ_キーボード</span></tt>プログラムはただちに終了します。 キーボードについて:<ul>
    <li>グラフィックプログラムにおいて、キーボードが接続される<tt><span class="var">グラフ_キーボード</span></tt></li>
    <li>コンソールプログラムでは、キーボードは接続されている<tt><span class="var">コンソール_キーボード</span></tt></li>
</ul><p>このため、グラフィックプログラムは次の割当てを行う必要があります。</p><pre class="indent">;
<span class="var">キーボード</span><a class="op_no_ul" href="#stats_Assignment">:=</a><span class="var">グラフ_キーボード</span></pre><p>その後は変数を使用するだけです。<tt><span class="var">キーボード</span></tt></p><p>以下のプログラムは、押されたキーから計算された色でウィンドウをクリアします。</p><pre class="indent">
$
;

;

;






;



(640、480);

;


命令
);

65536
4999*
65536
9973*
65536));

command=KEY_ESC;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">draw.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">const</span></span>proc<a class="keywd_no_ul" href="#decls_Procedure_declarations">:main</a>is func<a class="type" href="#types_proc">地域の</a>var<span class="keywd"></span>char<span class="keywd">:command</span>は<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>「」<a class="type" href="#types_char">begin</a>衝立て<span class="keywd">キーボード</span><span class="stri">:=</span><span class="keywd">グラフ_キーボード</span>繰り返す<span class="func">:=</span><span class="var">getc</span>(<a class="op_no_ul" href="#stats_Assignment">キーボード</a>晴れた<span class="var">(</span>色<a class="keywd_no_ul" href="#stats_repeat-statement">(1009*</a>ord<a class="op_no_ul" href="#stats_Assignment">(command)</a>mod<span class="func">ord</span>(command)<span class="var">mod</span>ord<span class="func">(command)</span>mod<span class="func">まで</span>関数終了<span class="func"></span><span class="op"></span><span class="func"></span><span class="op"></span><span class="func"></span><span class="op"></span><a class="keywd_no_ul" href="#stats_repeat-statement"></a><span class="keywd"></span></pre><p>機能<tt><span class="func">色</span></tt>を作成します。<tt><a class="type" href="#types_color">色</a></tt>赤、緑、青の光から作られています 赤、緑、青のライトは、0～の範囲の整数値で指定されます。 65535</p><p><a name="graphic_hello_world_with_font">以下は、Seed7フォントを使用する「hello world」プログラムです。</a>:</p><pre class="indent">
$
;

;

;

;

;






value;



(203、45);
textWindow
(curr_win);

(textWindow, stdFont24);

);

));

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">draw.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">含む</span></span>&quot;<span class="keywd">テキスト.s7i</span>&quot;<span class="lib">含む<span class="lib"></span>&quot;stdfont24.s7i&quot;</span>const<span class="keywd"></span>proc<span class="lib">:main</span>is func<a class="keywd_no_ul" href="#decls_Procedure_declarations">地域の</a>var<a class="type" href="#types_proc"></a>テキスト<span class="keywd">:textWindow</span>は<span class="keywd"></span>テキスト<a class="keywd_no_ul" href="#decls_Variable_declarations">begin</a>衝立て<a class="type" href="#types_text">:=</a><span class="keywd">openPixmapFontFile</span>フォントを設定する<a class="type" href="#types_text">writeln</a>(textWindow<span class="keywd">&quot;hello world&quot;</span>無視する<span class="func">(</span>getc<a class="op_no_ul" href="#stats_Assignment">(</a>グラフ_キーボード<span class="func">関数終了</span><span class="func"></span><span class="func"></span><span class="stri"></span><a class="func" href="#stats_Ignoring_values"></a><span class="func"></span><span class="var"></span><span class="keywd"></span></pre><p>機能<tt><span class="func">衝立て</span></tt>は、幅が203ピクセル、高さが45ピクセルのウィンドウを開きます。 ウィンドウはグローバル変数に格納されます。<tt>勝利</tt>・機能<tt><span class="func">openPixmapFontFile</span></tt>を開く。<tt><span class="type">pixmapFontFile</span></tt>の<tt>勝利</tt>・全て書き込み<tt>textWindow</tt>が現行ウィンドウに表示されます。 機能<tt><span class="func">フォントを設定する</span></tt>使用するフォントを定義します。 フォント<tt>stdfont24.s7i</tt>は<tt><span class="type">bitmapFont</span></tt>キャップハイトは24ピクセルです。 機能<tt><span class="func">writeln</span></tt>現在のウィンドウに、指定したフォントでhello worldを表示します。</p><p>Seed7フォントは、業務用フォントほど完全ではありません。 次のような特性があります。</p><ul>
    <li>それらはオープンソースです。</li>
    <li>それらはSeed7で実装されます。</li>
    <li>外部ライブラリは必要ありません。</li>
    <li>Seed7プログラムは常にそれらを使用できます。</li>
    <li>ビットマップフォントとベクトルフォントがあります。</li>
</ul><p>
          <a name="graphic_hello_world_at_clicked_positions">以下は、クリックされた位置に「hello world」を書き込む「hello world」プログラムです。</a>
        </p><pre class="indent">
$
;

;

;

;

;






value;

;



(640、480);
textWindow
(curr_win);

(textWindow, stdFont24);

;


命令
);



(キーボード)

(KEYBOARD));

(0, 65535)

(0, 65535)

(0, 65535)));

);

;

;

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">draw.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">含む</span></span>&quot;<span class="keywd">テキスト.s7i</span>&quot;<span class="lib">含む<span class="lib"></span>&quot;stdfont24.s7i&quot;</span>const<span class="keywd"></span>proc<span class="lib">:main</span>is func<a class="keywd_no_ul" href="#decls_Procedure_declarations">地域の</a>var<a class="type" href="#types_proc"></a>テキスト<span class="keywd">:textWindow</span>は<span class="keywd"></span>テキスト<a class="keywd_no_ul" href="#decls_Variable_declarations">var</a><a class="type" href="#types_text">char</a>:command<span class="keywd">は</span><a class="type" href="#types_text">「」</a>begin<a class="keywd_no_ul" href="#decls_Variable_declarations">衝立て</a>:=<a class="type" href="#types_char"></a>openPixmapFontFile<span class="keywd">フォントを設定する</span>キーボード<span class="stri"></span>:=<span class="keywd"></span>グラフ_キーボード<span class="func">繰り返す</span>:=<a class="op_no_ul" href="#stats_Assignment"></a>getc<span class="func">(</span>キーボード<span class="func">if</span>コマンド=<span class="var">KEY_MOUSE1</span><a class="op_no_ul" href="#stats_Assignment">その時</a>setPosXY<span class="var">(textWindow</span>clickedXPos<a class="keywd_no_ul" href="#stats_repeat-statement">clickedYPos</a>色<a class="op_no_ul" href="#stats_Assignment">(textWindow</a>色<span class="func">(</span>ランド<span class="var">ランド</span>ランド<a class="keywd_no_ul" href="#stats_if-statement">書く</a>(textWindow<a class="var" href="#file_KEY_MOUSE1">&quot;hello world&quot;</a>終わり<a class="keywd_no_ul" href="#stats_if-statement"></a>if<span class="func">まで</span>命令<span class="func">&lt;></span><span class="func">KEY_MOUSE1</span>関数終了<span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="func"></span><span class="stri"></span><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_repeat-statement"></a><span class="op_no_ul"></span><a class="var" href="#file_KEY_MOUSE1"></a><span class="keywd"></span></pre><p>機能<tt><span class="func">clickedXPos</span></tt>および<tt><span class="func">clickedYPos</span></tt>最後にマウスボタンがクリックされたときのマウスカーソルのX座標とY座標を返します。 機能<tt><span class="func">setPosXY</span></tt>テキストウィンドウの現在位置を、指定したXおよびY座標に設定します。 という名前の2つの関数があります。<tt><span class="func">色</span></tt>・内部関数<tt><span class="func">色</span></tt>を作成します。<tt><a class="type" href="#types_color">色</a></tt>ランダムな赤、緑、青の光から。 外部関数<tt><span class="func">色</span></tt>テキストのフォアグラウンドカラーを設定します。</p><p>
          <a name="graphic_hourglass_cursor">以下は、カーソル位置に砂時計を描くプログラムです。</a>
        </p><pre class="indent">
$
;

;

;

;

;

;






value;



(640、480);
砂時計
(curr_win, 1000, 1000

(hourglass_pic[1])

(hourglass_pic));

(hourglass_pic, 1, black));

;

);



2

2);

(30000. MICRO_SECONDS);

);

;
<span class="keywd">含む</span><span class="stri">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="lib">draw.s7i<span class="lib">&quot;</span>含む</span><span class="keywd">&quot;</span>keybd.s7i<span class="lib">&quot;<span class="lib">含む</span></span>&quot;pic32.s7i&quot;<span class="keywd">含む</span><span class="lib">&quot;</span>時間.s7i<span class="keywd">&quot;</span>含む<span class="lib"><span class="lib">&quot;</span>duration.s7i</span>&quot;<span class="keywd">const</span><span class="lib">proc<span class="lib">:main</span>is func</span>地域の<a class="keywd_no_ul" href="#decls_Procedure_declarations">var</a><a class="type" href="#types_proc">PR IMERIC_WINDOW</a>:砂時計<span class="keywd">は</span><span class="keywd">PR IMERIC_WINDOW</span>begin<a class="keywd_no_ul" href="#decls_Variable_declarations">衝立て</a>:=<span class="type"></span>openSubWindow<span class="keywd">長さ</span>長さ<span class="type">置く</span>(砂時計、0、0<span class="keywd">作成ピックスマップ</span>キーボード<span class="func"></span>:=<a class="op_no_ul" href="#stats_Assignment"></a>グラフ_キーボード<span class="func">setCursorVisible</span>(curr_win<span class="func">FALSE</span>繰り返す<span class="func">setPos</span>(砂時計<span class="func">pointerXPos</span>(curr_win)-<span class="func">横</span>(砂時計)<span class="var">div</span>pointerYPos<a class="op_no_ul" href="#stats_Assignment">(curr_win)-</a>高さ<span class="var">(砂時計)</span>div<span class="func">待つ</span>まで<span class="var_no_ul"></span>inputReady<a class="keywd_no_ul" href="#stats_repeat-statement">(</a>キーボード<span class="func">関数終了</span><span class="func"></span><span class="func"></span><span class="op_no_ul"></span><span class="func"></span><span class="func"></span><span class="op_no_ul"></span><span class="func"></span><a class="keywd_no_ul" href="#stats_repeat-statement"></a><span class="func"></span><span class="var"></span><span class="keywd"></span></pre><p>変数<tt>砂時計</tt>のタイプ<tt><span class="type">PR IMERIC_WINDOW</span></tt>この型の変数は、ウィンドウ(画面上)またはピクスマップ(画面外)を保持できます。 機能<tt><span class="func">openSubWindow</span></tt>親ウィンドウの中にサブウィンドウを作成する<tt><span class="var">勝利</span></tt>・窓<tt><span class="var">勝利</span></tt>にはタイトルバーがあります。 作成されたウィンドウ<tt><span class="func">openSubWindow</span></tt>には、タイトルバーもボーダーもありません。 機能<tt><span class="func">作成ピックスマップ</span></tt>ライブラリからのパターンを使用することによって砂時計のピクスマップを作成するために使用される<tt><span class="lib">&quot;pic32.s7i&quot;</span></tt>・機能<tt><span class="func">setCursorVisible</span></tt>でマウスカーソルの可視性を無効にします。<tt><span class="var">勝利</span></tt>機能<tt><span class="func">pointerXPos</span></tt>および<tt><span class="func">pointerYPos</span></tt>現在のマウスカーソルのX座標とY座標を返します。 機能<tt><span class="func">setPos</span></tt>を使用して<tt>砂時計</tt>カーソル位置(砂時計の幅と高さの半分を引いた位置)に移動します。</p><p>他の画像フォーマットに加えて、Seed7は、文字列の配列を使用して画像を表す「貧者の画像」をサポートします。 例:</p><pre class="indent">[](































































);
<a class="keywd_no_ul" href="#decls_Constant_declarations">const</a><a class="type" href="#types_array">配列</a><a class="type" href="#types_string">文字列</a>:hourglass_pic<span class="keywd">は</span>&quot;bbbbb bbbbb bbbbb bbbbb&quot;<span class="stri"></span>#文字から色へのマッピング:<span class="comment">&quot;bbbbb bbbbb bbbbb bbbbb&quot;</span><span class="stri">#char color</span>&quot;bb XWWWWWWWWWWWWWWWWWWX bb&quot;<span class="comment"></span>#------+---------------<span class="stri">&quot;bbXWWWWWWWWWWWWWWWWWWWWXbb&quot;</span><span class="comment">#space background color</span>&quot;bbWWXXXXXXXXXXXXXXXXXXXXWWbb&quot;<span class="stri"></span>#B<span class="comment"></span>淡い青<span class="stri">&quot;bbWWX XWWbb&quot;</span><span class="comment">#G</span><span style="background-color:#0000ff;color:white;">淡い緑色</span>&quot;bbWWX YYYY XWWbb&quot;<span class="stri"></span>#L<span class="comment"></span>ラベンダー<span style="background-color:#00ff00;color:black;">&quot;bbWWX YYYYYY XWWbb&quot;</span><span class="stri">#M</span><span class="comment">light_magenta</span>&quot;bbXWWX YYYYYYYY XWWXbb&quot;<span style="background-color:#8080ff;color:white;"></span>#O<span class="stri"></span>オレンジ<span class="comment">&quot;bb XWWX YYYYYYYYYY XWWX bb&quot;</span><span style="background-color:#ff00ff;color:black;">#P</span><span class="stri">淡いピンク</span>&quot;bb XWWYYYYYYYYYYYYWWX bb&quot;<span class="comment"></span>#R<span style="background-color:#ff8000;color:black;"></span>light_red<span class="stri">&quot;bb XWWYYYYYYYYYYWWX bb&quot;</span><span class="comment">#W</span><span style="background-color:#ff80ff;color:black;">白い</span>&quot;bb XWWYYYYYYYYWWX bb&quot;<span class="stri"></span>#X<span class="comment"></span>黒<span style="background-color:#ff0000;color:black;">&quot;bb XWWYYYYYYWWX bb&quot;</span><span class="stri">#Y</span><span class="comment">黄色</span>&quot;bb XWWYYYYWWX bb&quot;<span style="background-color:#ffffff;color:black;"></span>#b<span class="stri"></span>茶色<span class="comment">&quot;bb XWWYYWWX bb&quot;</span><span style="background-color:#000000;color:white;">#c</span><span class="stri">light_cyan</span>&quot;bb XWWYYWWX bb&quot;<span class="comment"></span>#d<span style="background-color:#ffff00;color:black;"></span>暗い_灰色<span class="stri">&quot;bb XWWXYYXWWX bb&quot;</span><span class="comment">#f</span><span style="background-color:#804000;color:white;">森林緑</span>&quot;bb XWWX YY XWWX bb&quot;<span class="stri"></span>#g<span class="comment"></span>濃い緑<span style="background-color:#80ffff;color:black;">&quot;bb XWWX YY XWWX bb&quot;</span><span class="stri">#i</span><span class="comment">ミント</span>&quot;bb XWWX YY XWWX bb&quot;<span style="background-color:#404040;color:white;"></span>#l<span class="stri"></span>中間の青<span class="comment">&quot;bb XWWX YY XWWX bb&quot;</span><span style="background-color:#228b22;color:white;">#m</span><span class="stri">濃いマゼンタ</span>&quot;bb XWWX YY XWWX bb&quot;<span class="comment"></span>#n<span style="background-color:#008000;color:white;"></span>暗い青<span class="stri">&quot;bbXWWX YYYY XWWXbb&quot;</span><span class="comment">#p</span><span style="background-color:#55df55;color:black;">ピンク</span>&quot;bbWWX YYYYYY XWWbb&quot;<span class="stri"></span>#r<span class="comment"></span>暗い赤<span style="background-color:#0000a8;color:white;">&quot;bbWWX YYYYYYYY XWWbb&quot;</span><span class="stri">#x</span><span class="comment">薄いグレー</span>&quot;bbWWX YYYYYYYYYY XWWbb&quot;<span style="background-color:#800080;color:white;"></span>#y<span class="stri"></span>中間の灰色<span class="comment">&quot;bbWWXXXXYYYYYYYYYYYYXXXXWWbb&quot;</span><span style="background-color:#000080;color:white;">#other</span><span class="stri">黒</span>&quot;bbXWWWWWWWWWWWWWWWWWWWWXbb&quot;<span class="comment">&quot;bb XWWWWWWWWWWWWWWWWWWX bb&quot;</span>&quot;bbbbb bbbbb bbbbb bbbbb&quot;<span style="background-color:#ff8080;color:black;">&quot;bbbbb bbbbb bbbbb bbbbb&quot;</span><span class="stri"></span><span class="comment"></span><span style="background-color:#800000;color:white;"></span><span class="stri"></span><span class="comment"></span><span style="background-color:#c0c0c0;color:black;"></span><span class="stri"></span><span class="comment"></span><span style="background-color:#808080;color:white;"></span><span class="stri"></span><span class="comment"></span><span style="background-color:#000000;color:white;"></span><span class="stri"></span><span class="stri"></span><span class="stri"></span><span class="stri"></span></pre><p></p>
          <a name="actions_file_start"></a>
        <p></p>
          <a name="actions_PRIMITIVE_ACTIONS">
        <h2>15原始的な行為</h2>
          </a>
        <p>すべての関数を同じ言語の他の関数を呼び出して記述できるわけではありません。 この理由とパフォーマンス上の理由から、いくつかの関数はアクションと呼ばれるメカニズムを使用して定義されています。 例: の定義は簡単です。<a class="link" href="#stats_while-statement">while文</a>再帰を使用する。 しかし、これはパフォーマンスを低下させ、ランタイムスタックのために大量のメモリを使用します。 実際には<a class="link" href="#stats_while-statement">while文</a>サブルーチン呼出しの代わりに条件付き飛び越しを使用できます。 Seed7には<tt><span class="keywd">goto</span></tt>これはオプションではありません。 その代わりに原始的な行動が<tt><a class="link" href="#actions_PRC_WHILE">PRC_WHILE</a></tt>も使用できます。 その<a class="link" href="#stats_while-statement">while文</a>は基本Seed7ライブラリで定義されています。<tt><span class="lib">&quot;seed7_05.s7i&quot;</span></tt>変更後:</p><pre class="indent">:condition)do
(
:statement)
whileを終了する
;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type" href="#types_proc">proc</a>:while(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_func">機能</a><a class="type" href="#types_boolean">ブール</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>proc<a class="type" href="#types_proc">は</a><span class="keywd">行動</span><span class="keywd">&quot;PRC_WHILE&quot;</span><a class="stri" href="#actions_PRC_WHILE"></a></pre><p>この宣言は、パラメータの型と位置を示します。<a class="link" href="#stats_while-statement">while文</a>そのようなアクション宣言は、定義された構成体を使用するのに十分な情報を含んでいます。 すべてのプリミティブ・アクションのセマンティクスは、インタプリタとコンパイラでハードコードされています。 ハードコードされたアクションのパラメータとSeed7の対応する定義は一致する必要があります。 プリミティブアクションのSeed7定義に興味がある場合は、ファイルを調べてください。<tt><span class="lib">&quot;seed7_05.s7i&quot;</span></tt></p><p>現在、インタプリタには数百のプリミティブアクションが事前定義されています。 これらはすべて、次の形式の大文字で名前が付けられています。</p><pre class="indent">TYPE_ACTION
</pre><p>これは、たとえば<tt><a class="type" href="#types_integer">整数</a></tt>アクションはで始まる<a class="link" href="#actions_integer">INT_</a>割り当てアクションはすべて_CPYで終了します。 次のリストは、複数のタイプで使用されるアクションを示しています。</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>_ABS<td width="20"></td><td>絶対値</td></tr>
    <tr><td>_ADD<td width="20"></td><td>追加</td></tr>
    <tr><td>CAT<td width="20"></td><td>連結</td></tr>
    <tr><td>_CMP<td width="20"></td><td>比較</td></tr>
    <tr><td>_CPY<td width="20"></td><td><a class="link" href="#stats_Assignment">コピー</a>既存のオブジェクトに対する新しい値(<a class="link" href="#stats_Assignment">譲渡</a>)</td></tr>
    <tr><td>_CREATE<td width="20"></td><td><a class="link" href="#types_creator">作成</a>を呼び出したり、新しいオブジェクト(<a class="type" href="#types_creator">作成者</a>)</td></tr>
    <tr><td>_DETR<td width="20"></td><td><a class="link" href="#types_destroyer">破棄</a>未使用のオブジェクト(<a class="type" href="#types_destroyer">破壊者</a>)</td></tr>
    <tr><td>_DECR<td width="20"></td><td>減分</td></tr>
    <tr><td>_DIV<td width="20"></td><td>部門</td></tr>
    <tr><td>_EQ<td width="20"></td><td>同等</td></tr>
    <tr><td>_GE<td width="20"></td><td>大なり</td></tr>
    <tr><td>_GETC<td width="20"></td><td>から1文字を取得します。<span class="type">ファイルする</span></td></tr>
    <tr><td>_GETS<td width="20"></td><td>取得<tt><a class="type" href="#types_string">文字列</a></tt>からの最大長で<span class="type">ファイルする</span></td></tr>
    <tr><td>_GT<td width="20"></td><td>より大きい</td></tr>
    <tr><td>_HASHCODE<td width="20"></td><td>hashCodeを計算する</td></tr>
    <tr><td>_HEAD<td width="20"></td><td>の長<tt><a class="type" href="#types_string">文字列</a></tt><tt><a class="type" href="#types_array">配列</a></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt></td></tr>
    <tr><td>_ICONV<td width="20"></td><td>の変換<tt><a class="type" href="#types_integer">整数</a></tt>別のタイプに</td></tr>
    <tr><td>IDX<td width="20"></td><td>の索引(要素)<tt><a class="type" href="#types_string">文字列</a></tt><tt><a class="type" href="#types_array">配列</a></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt></td></tr>
    <tr><td>_INCR<td width="20"></td><td>増分</td></tr>
    <tr><td>_IPOW<td width="20"></td><td>パワー<tt><a class="type" href="#types_integer">整数</a></tt>冪指数</td></tr>
    <tr><td>_LE<td width="20"></td><td>同等でない</td></tr>
    <tr><td>_LNG<td width="20"></td><td>長さ</td></tr>
    <tr><td>_LOG2<td width="20"></td><td>2を底とする対数</td></tr>
    <tr><td>_LOWER<td width="20"></td><td>小文字に変換する</td></tr>
    <tr><td>_LSHIFT<td width="20"></td><td>シフトレフト</td></tr>
    <tr><td>_LT<td width="20"></td><td>より小さい</td></tr>
    <tr><td>_MDIV<td width="20"></td><td>モジュロ除算(整数除算を負の無限大に切り捨てたもの)</td></tr>
    <tr><td>_MOD<td width="20"></td><td>Modulo(_MDIV整数除算のリマインダー)</td></tr>
    <tr><td>_MULT<td width="20"></td><td>乗算</td></tr>
    <tr><td>_NE<td width="20"></td><td>等しくない</td></tr>
    <tr><td>_NEGATE<td width="20"></td><td>符号を変える</td></tr>
    <tr><td>_ODD<td width="20"></td><td>奇数</td></tr>
    <tr><td>_ORD<td width="20"></td><td>序数</td></tr>
    <tr><td>_PARSE<td width="20"></td><td>の変換<tt><a class="type" href="#types_string">文字列</a></tt>別のタイプに</td></tr>
    <tr><td>_PLUS<td width="20"></td><td>肯定記号(noop)</td></tr>
    <tr><td>_POW<td width="20"></td><td>電力</td></tr>
    <tr><td>_PRED<td width="20"></td><td>前任者</td></tr>
    <tr><td>RAND<td width="20"></td><td>ランダム値</td></tr>
    <tr><td>_範囲<td width="20"></td><td>範囲<tt><a class="type" href="#types_string">文字列</a></tt><tt><a class="type" href="#types_array">配列</a></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt></td></tr>
    <tr><td>REM<td width="20"></td><td>余り(_DIV整数除算のリマインダー)</td></tr>
    <tr><td>_RSHIFT<td width="20"></td><td>算術右シフト</td></tr>
    <tr><td>_SBTR<td width="20"></td><td>差</td></tr>
    <tr><td>スキャン<td width="20"></td><td>変換元<tt><a class="type" href="#types_string">文字列</a></tt>別のタイプに</td></tr>
    <tr><td>_SEEK<td width="20"></td><td>ファイルの実際の位置を<span class="type">ファイルする</span></td></tr>
    <tr><td>_SQRT<td width="20"></td><td>平方根</td></tr>
    <tr><td>_STR<td width="20"></td><td>変換<tt><a class="type" href="#types_string">文字列</a></tt></td></tr>
    <tr><td>_SUCC<td width="20"></td><td>承継人</td></tr>
    <tr><td>_TAIL<td width="20"></td><td>尾<tt><a class="type" href="#types_string">文字列</a></tt><tt><a class="type" href="#types_array">配列</a></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt></td></tr>
    <tr><td>_語る<td width="20"></td><td>実際の<span class="type">ファイルする</span>地位</td></tr>
    <tr><td>_UPPER<td width="20"></td><td>大文字に変換する</td></tr>
    <tr><td>_VALUE<td width="20"></td><td>aの参照を解除する<tt><a class="type" href="#types_reference">参考</a></tt></td></tr>
    <tr><td>_WRITE<td width="20"></td><td>書き込み<tt><a class="type" href="#types_string">文字列</a></tt>へ<span class="type">ファイルする</span></td></tr>
</table></dd></dl><p>プリミティブ・アクションは多くのタイプに定義されています。 プリミティブなアクションを実装する機能は、*lib.cファイルにまとめられています。 次のリストに、アクションの接頭辞、関数を含むファイル、および説明を示します。</p><dl><dd><table border="0" cellspacing="0">
    <tr><td>
          <a class="link" href="#actions_ACTION"          >ACT_</a>
        </td>  <td width="20"></td><td>actlib.c</td>  <td width="20"></td><td><tt><span class="type">ACTION</span></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_array"           >ARR_</a>
        </td>  <td width="20"></td><td>arrlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_array">配列</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_bigInteger"      >大きい_</a>
        </td>  <td width="20"></td><td>biglib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_binary"          >箱_</a>
        </td>  <td width="20"></td><td>binlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_bin32">ビン32</a></tt>および<tt><a class="type" href="#types_bin64">bin64</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_boolean"         >BLN_</a>
        </td>  <td width="20"></td><td>blnlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_boolean">ブール</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_bstring"         >BST_</a>
        </td>  <td width="20"></td><td>bstlib.c</td>  <td width="20"></td><td>Operations for<tt><a class="type" href="#types_bstring">bstring</a></tt></td></tr>
    <tr><td>
          <a class="link" href="#actions_char"            >CHR_</a>
        </td>  <td width="20"></td><td>chrlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_char">char</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_commands"        >CMD_</a>
        </td>  <td width="20"></td><td>cmdlib.c</td>  <td width="20"></td><td>各種ディレクトリやファイル、その他のコマンド</td></tr>
    <tr><td>
          <a class="link" href="#actions_console_output"  >CON_</a>
        </td>  <td width="20"></td><td>conlib.c</td>  <td width="20"></td><td><tt><span class="type">コンソールファイル</span></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_declarations"    >DCL_</a>
        </td>  <td width="20"></td><td>dcllib.c</td>  <td width="20"></td><td>宣言操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_graphic_output"  >DRW_</a>
        </td>  <td width="20"></td><td>drwlib.c</td>  <td width="20"></td><td>描画操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_enumeration"     >ENU_</a>
        </td>  <td width="20"></td><td>enulib.c</td>  <td width="20"></td><td>列挙演算</td></tr>
    <tr><td>
          <a class="link" href="#actions_clib_file"       >FIL_</a>
        </td>  <td width="20"></td><td>fillib.c</td>  <td width="20"></td><td><tt><span class="type">clib_file</span></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_float"           >FLT_</a>
        </td>  <td width="20"></td><td>flt.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_float">浮かぶ</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_graphic_keyboard">GKB_</a>
        </td>  <td width="20"></td><td>gkblib.c</td>  <td width="20"></td><td>グラフィカルなキーボード操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_hash"            >HSH_</a>
        </td>  <td width="20"></td><td>hshlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_hash">ハッシュ</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_integer"         >INT_</a>
        </td>  <td width="20"></td><td>intlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_integer">整数</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_interface"       >ITF_</a>
        </td>  <td width="20"></td><td>itflib.c</td>  <td width="20"></td><td>インタフェース型に対する操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_console_keyboard">KBD_</a>
        </td>  <td width="20"></td><td>kbdlib.c</td>  <td width="20"></td><td>キーボード操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_list"            >最初</a>
        </td>  <td width="20"></td><td>lstlib.c</td>  <td width="20"></td><td>リスト操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_process"         >PCS_</a>
        </td>  <td width="20"></td><td>pcslib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_process">プロセス</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_pointList"       >PTL_</a>
        </td>  <td width="20"></td><td>drwlib.c</td>  <td width="20"></td><td>pointList操作</td></tr>
    <tr><td>
          <a class="link" href="#actions_pollData"        >POL_</a>
        </td>  <td width="20"></td><td>pollib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_pollData">pollData</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_proc"            >製品</a>
        </td>  <td width="20"></td><td>prclib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_proc">proc</a></tt>操作と文</td></tr>
    <tr><td>
          <a class="link" href="#actions_program"         >PRG_</a>
        </td>  <td width="20"></td><td>prglib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_program">プログラム</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_reference"       >REF_</a>
        </td>  <td width="20"></td><td>reflib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_reference">参考</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_ref_list"        >RFL_</a>
        </td>  <td width="20"></td><td>rfllib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_ref_list">参照リスト</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_struct"          >SCT_</a>
        </td>  <td width="20"></td><td>tsclib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_struct">構造体</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_structElement"   >SEL_</a>
        </td>  <td width="20"></td><td>sellib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_structElement">structElement</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_set"             >SET_</a>
        </td>  <td width="20"></td><td>setlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_set">設定する</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_PRIMITIVE_SOCKET">SOC_</a>
        </td>  <td width="20"></td><td>soclib.c</td>  <td width="20"></td><td><tt><span class="type">PR IMERIC_SOCKET</span></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_database"        >SQL_</a>
        </td>  <td width="20"></td><td>sqllib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_database">データベース</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_string"          >STR_</a>
        </td>  <td width="20"></td><td>strlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_string">文字列</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_time"            >TIM_</a>
        </td>  <td width="20"></td><td>timlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_time">時間</a></tt>および<tt><a class="type" href="#types_duration">持続時間</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_type"            >タイプ_</a>
        </td>  <td width="20"></td><td>typlib.c</td>  <td width="20"></td><td><tt><a class="type" href="#types_type">タイプ</a></tt>オペレーション</td></tr>
    <tr><td>
          <a class="link" href="#actions_utf8File"        >UT8_</a>
        </td>  <td width="20"></td><td>ut8lib.c</td>  <td width="20"></td><td><tt><span class="type">utf 8ファイル</span></tt>オペレーション</td></tr>
</table></dd></dl><p>プリミティブなアクションを実装するC関数は、小文字の名前になっています。 例:アクション<tt><a class="link" href="#actions_PRC_WHILE">PRC_WHILE</a></tt>はC関数で実装されている。<tt>&#39;prc_while()&#39;</tt>ファイル内<tt><span class="lib">&quot;prclib.c&quot;</span></tt>すべてのCアクション関数のパラメータ・リストは同一です。 すべての*lib.cファイルには、アクション関数のプロトタイプを含む*lib.hファイルが対応しています。</p><p>Seed7プログラムでは、オペレータは<tt><span class="op_no_ul">+</span></tt>2を加え<tt><a class="type" href="#types_integer">整数</a></tt>値。 2つの整数の加算を記述するプリミティブ・アクションは次のとおりです。<tt><a class="link" href="#actions_INT_ADD">INT_ADD</a></tt>間の接続<tt><span class="op">+</span></tt>および<tt><a class="link" href="#actions_INT_ADD">INT_ADD</a></tt>図書館で行われる<tt><span class="stri">&quot;integer.s7i&quot;</span></tt>と定義します。</p><pre class="indent">;
<a class="keywd_no_ul" href="#decls_Function_declarations">const</a><a class="type" href="#types_func">機能</a><a class="type" href="#types_integer">整数</a>:(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_integer">整数</a>:summand1)+(<a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_integer">整数</a>:summand2)<span class="keywd">は</span><span class="keywd">行動</span><a class="stri" href="#actions_INT_ADD">&quot;INT_ADD&quot;</a></pre><p>アクションを実行するには、対応するC関数がs7インタプリタ内に存在している必要があります。 作用に対する機能<tt><a class="link" href="#actions_INT_ADD">INT_ADD</a></tt>は<tt><a class="func" href="#actions_int_add">int_add</a>()</tt>・機能<tt><a class="func" href="#actions_int_add">int_add</a>()</tt>がファイル<tt><span class="lib">&quot;intlib.c&quot;</span></tt>変更後:</p><pre class="indent">引数)

{


(arguments));

(arguments));

(

(引数))+

(arguments)));
}

<a class="type" href="#ffi_objectType">objectType</a><a name="actions_int_add">int_add</a>(<a class="type" href="#ffi_listType">リストタイプ</a>/*int_add*/<span class="comment">isit_int</span>(<a class="func" href="#ffi_isit_int">arg_1</a>isit_int<a class="func" href="#ffi_arg_1">(</a>arg_3<a class="func" href="#ffi_isit_int">リターン</a><a class="func" href="#ffi_arg_3">bld_int_temp</a>take_int<span class="keywd">(</span>arg_1<a class="func" href="#ffi_bld_int_temp">take_int</a>(<a class="func" href="#ffi_take_int">arg_3</a>/*int_add*/<a class="func" href="#ffi_arg_1"></a><a class="func" href="#ffi_take_int"></a><a class="func" href="#ffi_arg_3"></a><span class="comment"></span></pre><p>機能<tt><a class="func" href="#actions_int_add">int_add</a>()</tt>は第1引数と第3引数を加算します(第2引数には+記号が含まれます)。 ファイル<tt><span class="lib">&quot;objutl.h&quot;</span></tt>には、Cのプリミティブアクション関数の引数(パラメータリスト)の操作に役立つマクロと関数がいくつか用意されています。<ul>
    <li>マクロ<tt><a class="func" href="#ffi_arg_1">arg_1</a></tt><tt><a class="func" href="#ffi_arg_2">arg_2</a></tt><tt><a class="func" href="#ffi_arg_3">arg_3</a></tt>などを使用すると、個々の引数を取得できます(例:<tt><a class="func" href="#ffi_arg_3">arg_3</a>(引数)</tt>)。</li>

    <li>マクロ<tt><a class="func" href="#ffi_isit_int">isit_int</a></tt><tt><a class="func" href="#ffi_isit_stri">isit_stri</a></tt><tt><a class="func" href="#ffi_isit_file">init_file</a></tt>などを使用して、正しいかどうかをチェックすることができます。<tt><a class="type" href="#types_category">カテゴリ</a></tt>議論の(例:<tt><a class="func" href="#ffi_isit_int">isit_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(引数))</tt>)。</li>

    <li>マクロ<tt><a class="func" href="#ffi_take_char">take_char</a></tt><tt><a class="func" href="#ffi_take_float">take_float</a></tt><tt><a class="func" href="#ffi_take_bigint">take_bigint</a></tt>などは、引数の対応する値を取得するために使用できます(例:<tt><a class="func" href="#ffi_take_int">take_int</a>(<a class="func" href="#ffi_arg_1">arg_1</a>(引数))</tt>)。</li>

    <li>機能<tt><a class="func" href="#ffi_bld_int_temp">bld_int_temp</a></tt><tt><a class="func" href="#ffi_bld_array_temp">bld_array_temp</a></tt><tt><a class="func" href="#ffi_bld_win_temp">bld_win_temp</a></tt>などを使用して<tt><a class="type" href="#ffi_objectType">objectType</a></tt>)プリミティブアクションの結果(例:<tt>リターン<a class="func" href="#ffi_bld_int_temp">bld_int_temp</a>(0);</tt>)。</li>
</ul><p>ファイル<tt><span class="lib">&quot;intlib.h&quot;</span></tt>には<tt><a class="func" href="#actions_int_add">int_add</a>()</tt>機能:</p><pre class="indent">arguments);
<a class="type" href="#ffi_objectType">objectType</a><a class="func" href="#actions_int_add">int_add</a>(<a class="type" href="#ffi_listType">リストタイプ</a></pre><p>さらに、すべてのプリミティブ・アクションが<tt><span class="lib">&quot;primitive.c&quot;</span></tt>を組み込んだライン<tt><a class="link" href="#actions_INT_ADD">INT_ADD</a></tt>は:</p><pre class="indent">
{
、}
<span class="stri">&quot;INT_ADD&quot;</span><a class="func" href="#actions_int_add">int_add</a></pre><p>ファイル内のプリミティブアクションのエントリ<tt><span class="lib">&quot;primitive.c&quot;</span></tt>はアルファベット順にソートされます。 この定義により、s7インタープリターは基本的なアクションを理解します。</p><p>コンパイルされたSeed7プログラムでプリミティブ機能を許可するには、Seed7コンパイラ(s7c)はそのアクションも認識する必要があります。 のコードを作成するコンパイラ関数<tt><a class="link" href="#actions_INT_ADD">INT_ADD</a></tt>action:</p><pre class="indent">:function





c_expr.expr
;
process_expr(params[1],c_expr);
c_expr.expr
;
process_expr(params[3],c_expr);
c_expr.expr
;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type" href="#types_proc">proc</a>:process(<a class="link" href="#actions_INT_ADD">INT_ADD</a><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_reference">参考</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>参照リスト<a class="type" href="#types_ref_list">:params</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>式<span class="type">:c_expr)</span>is func<span class="keywd">begin</span>&amp;:=<span class="keywd"></span>&quot;(&quot;<span class="op_no_ul">&amp;:=</span><span class="stri">&quot;)+(&quot;</span>&amp;:=<span class="op_no_ul"></span>&quot;)&quot;<span class="stri">関数終了</span><span class="op_no_ul"></span><span class="stri"></span><span class="keywd"></span></pre><p>この関数は<tt><span class="lib">&quot;seed7/lib/comp/int_act.s7i&quot;</span></tt>関数から呼び出されます。<tt><span class="func">プロセスアクション</span></tt>変更後:</p><pre class="indent">
プロセス(
,function, params, c_expr);
<span class="keywd">elsif</span>アクション名=<span class="stri">&quot;INT_ADD&quot;</span><span class="keywd">その時</span>INT_ADD<a class="link" href="#actions_INT_ADD"></a></pre><p>一部のプリミティブ・アクションはより複雑であり、インライン・コードはそれに最適なソリューションではありません。 この場合、追加の補助機能が使用されます。 アクション<tt><a class="link" href="#actions_INT_LOG2">INT_LOG2</a></tt>そのような行動です。 関数の定義<tt><span class="func">int_log2</span>()</tt>ファイル内<tt><span class="lib">&quot;intlib.c&quot;</span></tt>は:</p><pre class="indent">引数)

{


(arguments));

(

(arguments))));
}

<a class="type" href="#ffi_objectType">objectType</a><a name="actions_int_log2">int_log2</a>(<a class="type" href="#ffi_listType">リストタイプ</a>/*int_log2*/<span class="comment">isit_int</span>(<a class="func" href="#ffi_isit_int">arg_1</a>リターン<a class="func" href="#ffi_arg_1"></a>bld_int_temp<span class="keywd">intLog2</span>(<a class="func" href="#ffi_bld_int_temp">take_int</a>(<a class="func" href="#actions_intLog2">arg_1</a>/*int_log2*/<a class="func" href="#ffi_take_int"></a><a class="func" href="#ffi_arg_1"></a><span class="comment"></span></pre><p>基本動作の主な作業<tt><a class="link" href="#actions_INT_LOG2">INT_LOG2</a></tt>補助関数で行われる<tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>ヘルパー関数<tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>ファイル内にある<tt><span class="lib">&quot;int_rtl.c&quot;</span></tt>:</p><pre class="indent">/**
※2を底とする切り捨てられた整数の対数を計算します。
*@は、切り捨てられたbase 2対数を返します。
*@exception NUMERIC_ERROR数値は負です。
*/


番号)

{
int result;




(ありそうもない(数字&lt;0)){

);
result=0;
}
{
result=üntMostSignificantBit((
)番号);
}


result;
}

<span class="comment">intType</span><a class="type" href="#ffi_intType">intLog2</a>(<a name="actions_intLog2">intType</a>/*intLog2*/<a class="type" href="#ffi_intType">if</a>raise_error<span class="comment">(</span>NUMERIC_ERROR<span class="keywd">else</span>uintType<a class="func" href="#ffi_raise_error">/*if*/</a>リターン<a class="exception" href="#errors_NUMERIC_ERROR">/*intLog2*/</a><span class="keywd"></span><a class="type" href="#ffi_uintType"></a><span class="comment"></span><span class="keywd"></span><span class="comment"></span></pre><p>ファイル<tt><span class="lib">&quot;int_rtl.h&quot;</span></tt>には<tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>ヘルパー関数:</p><pre class="indent">番号);
<a class="type" href="#ffi_intType">intType</a><a class="func" href="#actions_intLog2">intLog2</a>(<a class="type" href="#ffi_intType">intType</a></pre><p>ヘルパー関数は、Seed7コンパイラによって生成されたコードでも使用されます。</p><pre class="indent">:function





c_expr.expr
;
process_expr(params[1],c_expr);
c_expr.expr
;

;
<a class="keywd_no_ul" href="#decls_Procedure_declarations">const</a><a class="type" href="#types_proc">proc</a>:process(<a class="link" href="#actions_INT_LOG2">INT_LOG2</a><a class="keywd_no_ul" href="#params_in_parameter">で</a><a class="type" href="#types_reference">参考</a>で<a class="keywd_no_ul" href="#params_in_parameter"></a>参照リスト<a class="type" href="#types_ref_list">:params</a>入力する<a class="keywd_no_ul" href="#params_inout_parameter"></a>式<span class="type">:c_expr)</span>is func<span class="keywd">begin</span>&amp;:=<span class="keywd"></span>&quot;intLog2(&quot;<span class="op_no_ul">&amp;:=</span><span class="stri">&quot;)&quot;</span>関数終了<span class="op_no_ul"></span><span class="stri"></span><span class="keywd"></span></pre><p>コンパイラは以下のプロトタイプを記述します。<tt><a class="func" href="#actions_intLog2">intLog2</a>()</tt>関数で<tt><span class="func">write_prototypes</span></tt>:</p><pre class="indent">
declareExtern(
);
<span class="stri">&quot;intType intLog2(intType);&quot;</span></pre><p>プリミティブなアクションを含むすべての*lib.cファイルと、その他のさまざまなファイルおよびその機能は<tt><span class="lib">&quot;s7_comp.a&quot;</span></tt>ライブラリ(GPLライセンス) さらに、*lib.cファイルのCプリミティブアクション関数(例:int_parse)は、*_rtl.cファイルにある対応する関数(例:intParse)を使用することができます(例:<tt><span class="lib">&quot;int_rtl.c&quot;</span></tt>)。 *_rtl.cファイルはディレクトリ<tt><span class="lib">&quot;seed7_05.a&quot;</span></tt>ライブラリ(LGPLライセンス)。 Seed7プログラムをSeed7コンパイラ(s7c)でコンパイルすると、多くのプリミティブアクションに対してインラインコードが生成されます。 残りのプリミティブアクションを実装するには<tt><span class="lib">&quot;seed7_05.a&quot;</span></tt>ライブラリが使用されます。</p>
          <a name="actions_ACTION">
        <h3>15.1タイプACTIONのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>actlib.c関数</th>   <th>act_comp.c関数</th></tr>
    <tr><td>ACT_ILLEGAL</td>         <td>act_illegible</td>         <td> </td></tr>
    <tr><td>ACT_CPY</td>             <td>act_cpy</td>             <td>=</td></tr>
    <tr><td>ACT_CREATE</td>          <td>act_create</td>          <td> </td></tr>
    <tr><td>ACT_EQ</td>              <td>act_eq</td>              <td>==</td></tr>
    <tr><td>ACT_GEN</td>             <td>act_gen</td>             <td> </td></tr>
    <tr><td>ACT_ICONV1</td>          <td>act_iconv1</td>          <td>actIConv</td></tr>
    <tr><td>ACT_ICONV3</td>          <td>act_iconv3</td>          <td>actIConv</td></tr>
    <tr><td>ACT_NE</td>              <td>act_ne</td>              <td>=</td></tr>
    <tr><td>ACT_ORD</td>             <td>act_ord</td>             <td>actOrd</td></tr>
    <tr><td>ACT_STR</td>             <td>act_str</td>             <td>actStr</td></tr>
    <tr><td>ACT_VALUE</td>           <td>act_value</td>           <td>actValue</td></tr>
</table><p></p>
          <a name="actions_array">
        <h3>15.2配列型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>arrlib.c関数arrlib.cかんすう</th>   <th>arr_rtl.c関数</th></tr>
    <tr><td>ARR_APPEND</td>          <td>arr_append</td>          <td>rrAppend</td></tr>
    <tr><td>ARR_ARRLIT</td>          <td>arr_arrlit</td>          <td>aRRrrlit</td></tr>
    <tr><td>ARR_ARRLIT2</td>         <td>arr_arrlit2</td>         <td>aRRrrlit 2</td></tr>
    <tr><td>ARR_BASELIT</td>         <td>arr_baselit</td>         <td>arrBaselit</td></tr>
    <tr><td>ARR_BASELIT2</td>        <td>arr_baselit2</td>        <td>arrBaselit2</td></tr>
    <tr><td>ARR_CAT</td>             <td>猫</td>             <td>arrCat</td></tr>
    <tr><td>ARR_CONV</td>            <td>arr_conv</td>            <td>(noop)</td></tr>
    <tr><td>ARR_CPY</td>             <td>arr_cpy</td>             <td>cpy_.</td></tr>
    <tr><td>ARR_CREATE</td>          <td>作成</td>          <td>作成_.</td></tr>
    <tr><td>ARR_DESTR</td>           <td>arr_detr</td>           <td>デストル_.</td></tr>
    <tr><td>ARR_EMPTY</td>           <td>arr_empty</td>           <td> </td></tr>
    <tr><td>ARR_EXTEND</td>          <td>arr_extend</td>          <td>rrExtend</td></tr>
    <tr><td>ARR_GEN</td>             <td>arr_gen</td>             <td>arrGen</td></tr>
    <tr><td>ARR_HEAD</td>            <td>頭</td>            <td>arrHead</td></tr>
    <tr><td>ARR_IDX</td>             <td>arr_idx</td>             <td>a->arr[b-a->min_position]</td></tr>
    <tr><td>ARR_INSERT</td>          <td>arr_insert</td>          <td>rrInsert</td></tr>
    <tr><td>ARR_INSERT_ARRAY</td>    <td>arr_insert_array</td>    <td>arrInsertArray</td></tr>
    <tr><td>ARR_LNG</td>             <td>arr_lng</td>             <td>a->max_position-a->min_position+1</td></tr>
    <tr><td>ARR_MAXIDX</td>          <td>arr_maxidx</td>          <td>a->max_position</td></tr>
    <tr><td>ARR_MINIDX</td>          <td>arr_minidx</td>          <td>a->min_position</td></tr>
    <tr><td>ARR_PUSH</td>            <td>arr_push</td>            <td>arrPush</td></tr>
    <tr><td>ARR_RANGE</td>           <td>arr_range</td>           <td>rrRange</td></tr>
    <tr><td>ARR_REMOVE</td>          <td>arr_remove</td>          <td>rrRemove</td></tr>
    <tr><td>ARR_REMOVE_ARRAY</td>    <td>arr_remove_array</td>    <td>rrRemoveArray</td></tr>
    <tr><td>ARR_SORT</td>            <td>arr_sort</td>            <td>arrSort</td></tr>
    <tr><td>ARR_SORT_REVERSE</td>    <td>arr_sort_reverse</td>    <td>rrSortReverse</td></tr>
    <tr><td>ARR_SUBARR</td>          <td>arr_subarr</td>          <td>arrSubarr、arrSubarrTemp</td></tr>
    <tr><td>ARR_TAIL</td>            <td>尻尾</td>            <td>rrTail</td></tr>
    <tr><td>ARR_TIMES</td>           <td>arr_times</td>           <td>倍_.</td></tr>
</table><p></p>
          <a name="actions_bigInteger">
        <h3>15.3 bigInteger型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>biglib.c関数</th>   <th>big_rtl.c関数</th></tr>
    <tr><td>BIG_ABS</td>             <td>big_abs</td>             <td>bigAbs</td></tr>
    <tr><td>BIG_ADD</td>             <td>big_add</td>             <td>bigAdd, bigAddTemp</td></tr>
    <tr><td>BIG_ADD_ASSIGN</td>      <td>big_add_assign</td>      <td>bigAddAssign, bigAddAssignSignedDigit</td></tr>
    <tr><td>BIG_BIT_LENGTH</td>      <td>big_bit_length</td>      <td>bigBitLength</td></tr>
    <tr><td>BIG_CMP</td>             <td>big_cmp</td>             <td>bigCmp</td></tr>
    <tr><td>BIG_CONV</td>            <td>big_conv</td>            <td>(noop)</td></tr>
    <tr><td>BIG_CPY</td>             <td>大きいcpy</td>             <td>bigCpy</td></tr>
    <tr><td>BIG_CREATE</td>          <td>big_create</td>          <td>bigCreate</td></tr>
    <tr><td>BIG_DECR</td>            <td>大きいdecr</td>            <td>bigDecr</td></tr>
    <tr><td>BIG_宣言</td>           <td>大きいデストル</td>           <td>bigDestr</td></tr>
    <tr><td>BIG_DIV</td>             <td>big_div</td>             <td>bigDiv</td></tr>
    <tr><td>BIG_DIV_REM</td>         <td>big_div_rem</td>         <td>bigDivRem</td></tr>
    <tr><td>BIG_EQ</td>              <td>大きい_eq</td>              <td>bigEq</td></tr>
    <tr><td>BIG_FROM_BUSRI_BE</td>   <td>bstriから</td>   <td>bigFromBTSTriB</td></tr>
    <tr><td>BIG_FROM_BUSRI_LE</td>   <td>大きなものから小さなものまで</td>   <td>bigFromBsTREIl</td></tr>
    <tr><td>BIG_GCD</td>             <td>big_gcd</td>             <td>ビッグGcd</td></tr>
    <tr><td>BIG_GE</td>              <td>大きい</td>              <td>bigCmp>=0</td></tr>
    <tr><td>BIG_GT</td>              <td>大きい</td>              <td>bigCmp>0</td></tr>
    <tr><td>BIG_HASHCODE</td>        <td>big_hashcode</td>        <td>bigHashCode</td></tr>
    <tr><td>BIG_ICONV1</td>          <td>big_iconv1</td>          <td>bigIConv</td></tr>
    <tr><td>BIG_ICONV3</td>          <td>big_iconv3</td>          <td>bigIConv</td></tr>
    <tr><td>BIG_INCR</td>            <td>大きい増分</td>            <td>bigIncr</td></tr>
    <tr><td>BIG_IPOW</td>            <td>big_ipow</td>            <td>bigIPow</td></tr>
    <tr><td>BIG_LE</td>              <td>大きい</td>              <td>bigCmp&lt;=0</td></tr>
    <tr><td>BIG_LOG10</td>           <td>big_log10</td>           <td>bigLog10</td></tr>
    <tr><td>BIG_LOG2</td>            <td>big_log2</td>            <td>bigLog2</td></tr>
    <tr><td>BIG_LOWEST_SET_BIT</td>  <td>big_lowest_set_bit</td>  <td>bigLowestSetBit</td></tr>
    <tr><td>BIG_LSHIFT</td>          <td>big_lshift</td>          <td>bigLShift</td></tr>
    <tr><td>BIG_LSHIFT_ASSIGN</td>   <td>big_lshift_assign</td>   <td>bigLShiftAssign</td></tr>
    <tr><td>BIG_LT</td>              <td>大きい_lt</td>              <td>bigCmp&lt;0</td></tr>
    <tr><td>BIG_MDIV</td>            <td>big_mdiv</td>            <td>bigMDiv</td></tr>
    <tr><td>BIG_MOD</td>             <td>big_mod</td>             <td>bigMod</td></tr>
    <tr><td>BIG_MULT</td>            <td>big_mult</td>            <td>bigMult</td></tr>
    <tr><td>BIG_MULT_ASSIGN</td>     <td>big_mult_assign</td>     <td>bigMultAssign</td></tr>
    <tr><td>BIG_NE</td>              <td>big_ne</td>              <td>bigNe</td></tr>
    <tr><td>BIG_NEGATE</td>          <td>bignegate</td>          <td>bigNegate</td></tr>
    <tr><td>BIG_ODD</td>             <td>ビッグオッド</td>             <td>bigOdd</td></tr>
    <tr><td>BIG_ORD</td>             <td>ビッグ_オード</td>             <td>bigOrd</td></tr>
    <tr><td>BIG_PARSE1</td>          <td>big_parse1</td>          <td>bigParse</td></tr>
    <tr><td>BIG_PARSE_BASED</td>     <td>big_parse_based</td>     <td>bigParseBased</td></tr>
    <tr><td>BIG_PLUS</td>            <td>ビッグプラス</td>            <td>(noop)</td></tr>
    <tr><td>BIG_PRED</td>            <td>big_pred</td>            <td>bigPred</td></tr>
    <tr><td>BIG_RADIX</td>           <td>big_RADIX</td>           <td>bigRadix</td></tr>
    <tr><td>BIG_RAND</td>            <td>ビッグランド</td>            <td>bigRand</td></tr>
    <tr><td>BIG_REM</td>             <td>大きい_rem</td>             <td>bigRem</td></tr>
    <tr><td>BIG_RSHIFT</td>          <td>big_rshift</td>          <td>bigRWシフト</td></tr>
    <tr><td>BIG_RSHIFT_ASSIGN</td>   <td>big_rshift_assign</td>   <td>bigRShiftAssign</td></tr>
    <tr><td>BIG_SBTR</td>            <td>big_sbtr</td>            <td>bigSbtr, bigSbtrTemp</td></tr>
    <tr><td>BIG_SBTR_ASSIGN</td>     <td>big_sbtr_assign</td>     <td>bigSbtrAssign, bigAddAssignSignedDigit</td></tr>
    <tr><td>BIG_STR</td>             <td>big_str</td>             <td>bigStr</td></tr>
    <tr><td>BIG_SUCC</td>            <td>大きい_succc</td>            <td>bigSuccc</td></tr>
    <tr><td>BIG_TO_BUSRI_BE</td>     <td>big_to_bstri_be</td>     <td>bigToBStriBe</td></tr>
    <tr><td>BIG_TO_BUSRI_LE</td>     <td>大きなものから小さなものまで</td>     <td>bigTobtriSLe</td></tr>
    <tr><td>BIG_VALUE</td>           <td>big_value</td>           <td>bigValue</td></tr>
    <tr><td>BIG_radix</td>           <td>big_radix</td>           <td>bigRadix</td></tr>
</table><p></p>
          <a name="actions_binary">
        <h3>15.4タイプbin32およびbin64に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>binlib.c関数</th>   <th>big_rtl.cまたはint_rtl.c関数</th></tr>
    <tr><td>BIN_AND</td>             <td>そして</td>             <td>&amp;</td></tr>
    <tr><td>BIN_AND_ASSIGN</td>      <td>ビン・アンド・アサイン</td>      <td>&amp;=</td></tr>
    <tr><td>BIN_BIG</td>             <td>大きいゴミ箱</td>             <td>bigFromUInt64</td></tr>
    <tr><td>BIN_BINARY</td>          <td>バイナリ</td>          <td>bigToUInt64</td></tr>
    <tr><td>BIN_BIT_LENGTH</td>      <td>bin_bit_length</td>      <td>uint64MostSignificantBit</td></tr>
    <tr><td>BIN_BYTES_BE_2_UINT</td> <td>bin_bytes_be_2_uint</td> <td>uintBytesBe2UInt</td></tr>
    <tr><td>BIN_BYTES_LE_2_UINT</td> <td>bin_bytes_le_2_uint</td> <td>uintBytesLe2UInt</td></tr>
    <tr><td>BIN_CARD</td>            <td>キャッシュカード</td>            <td>uintCard</td></tr>
    <tr><td>BIN_CMP</td>             <td>bin_cmp</td>             <td>uintCmp</td></tr>
    <tr><td>BIN_GET_BINARY_FROM_SET</td> <td>bin_get_binary_from_set</td> <td>setToUInt</td></tr>
    <tr><td>BIN_LOWEST_SET_BIT</td>  <td>bin_lowest_set_bit</td>  <td>(intType)(bits==0?-1:uint64LeastSignificantBit(bits))</td></tr>
    <tr><td>BIN_LSHIFT</td>          <td>bin_lshift</td>          <td>(intType)((uintType)(a&lt;&amp;ltb))</td></tr>
    <tr><td>BIN_LSHIFT_ASSIGN</td>   <td>bin_lshift_assign</td>   <td>a=(intType)((unintType)(a&lt;&amp;ltb))</td></tr>
    <tr><td>BIN_N_BYTES_BE</td>      <td>bin_n_bytes_be</td>      <td>uintNBytesBe</td></tr>
    <tr><td>BIN_N_BYTES_LE</td>      <td>bin_n_bytes_le</td>      <td>uintNBytesLe</td></tr>
    <tr><td>BIN_OR</td>              <td>または</td>              <td> </td></tr>
    <tr><td>BIN_OR_ASSIGN</td>       <td>ビンまたはアサイン</td>       <td>=</td></tr>
    <tr><td>BIN_RADIX</td>           <td>bin_RADIX</td>           <td>uDontIx</td></tr>
    <tr><td>BIN_RSHIFT</td>          <td>bin_rshift</td>          <td>(intType)((uintType)(a>>b))</td></tr>
    <tr><td>BIN_RSHIFT_ASSIGN</td>   <td>bin_rshift_assign</td>   <td>a=(intType)((unintType)(a>>b))</td></tr>
    <tr><td>BIN_STR</td>             <td>bin_str</td>             <td>uintStr</td></tr>
    <tr><td>BIN_XOR</td>             <td>bin_xor</td>             <td>^</td></tr>
    <tr><td>BIN_XOR_ASSIGN</td>      <td>bin_xor_assign</td>      <td>^=</td></tr>
    <tr><td>BIN_radix</td>           <td>bin_radix</td>           <td>uDontIx</td></tr>
</table><p></p>
          <a name="actions_boolean">
        <h3>15.5 Actions for the type boolean</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>blnlib.c関数</th>   <th>bln_rtl.c関数</th></tr>
    <tr><td>BLN_AND</td>             <td>bln_and</td>             <td>&amp;&amp;</td></tr>
    <tr><td>BLN_CPY</td>             <td>bln_cpy</td>             <td>blnCpy</td></tr>
    <tr><td>BLN_CREATE</td>          <td>bln_create</td>          <td>=またはgenericCreate</td></tr>
    <tr><td>BLN_EQ</td>              <td>bln_eq</td>              <td>==</td></tr>
    <tr><td>BLN_GE</td>              <td>bln_ge</td>              <td>>=</td></tr>
    <tr><td>BLN_GT</td>              <td>bln_gt</td>              <td>></td></tr>
    <tr><td>BLN_ICONV1</td>          <td>bln_iconv1</td>          <td>&amp;1</td></tr>
    <tr><td>BLN_ICONV3</td>          <td>bln_iconv3</td>          <td>&amp;1</td></tr>
    <tr><td>BLN_LE</td>              <td>bln_le</td>              <td>&lt;=</td></tr>
    <tr><td>BLN_LT</td>              <td>bln_lt</td>              <td>&lt;</td></tr>
    <tr><td>BLN_NE</td>              <td>bln_ne</td>              <td>=</td></tr>
    <tr><td>BLN_NOT</td>             <td>bln_not</td>             <td> </td></tr>
    <tr><td>BLN_OR</td>              <td>bln_or</td>              <td> </td></tr>
    <tr><td>BLN_ORD</td>             <td>bln_ord</td>             <td>(intType)</td></tr>
    <tr><td>BLN_PRED</td>            <td>bln_pred</td>            <td>-1</td></tr>
    <tr><td>BLN_SUCC</td>            <td>bln_succc</td>            <td>+1</td></tr>
    <tr><td>BLN_TERNARY</td>         <td>bln_ternary</td>         <td>((cond)?(theExpr):(elsEpr))</td></tr>
    <tr><td>BLN_VALUE</td>           <td>bln_value</td>           <td>blnValue</td></tr>
</table><p></p>
          <a name="actions_bstring">
        <h3>15.6バイト列に対する操作</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>bstlib.c関数</th>   <th>bst_rtl.c関数</th></tr>
    <tr><td>BST_APPEND</td>          <td>bst_append</td>          <td>bstAppend</td></tr>
    <tr><td>BST_CAT</td>             <td>bst_cat</td>             <td>bstCat</td></tr>
    <tr><td>BST_CMP</td>             <td>bst_cmp</td>             <td>bstCmp</td></tr>
    <tr><td>BST_CPY</td>             <td>bst_cpy</td>             <td>bstCpy</td></tr>
    <tr><td>BST_CREATE</td>          <td>bst_create</td>          <td>bstCreate</td></tr>
    <tr><td>BST_DESTR</td>           <td>bst_detr</td>           <td>bstDestr</td></tr>
    <tr><td>BST_EMPTY</td>           <td>bst_empty</td>           <td> </td></tr>
    <tr><td>BST_EQ</td>              <td>bst_eq</td>              <td>a->size==b->size&amp;&amp;memcmp(a,b,a->size*sizeof(unsigned char))==0</td></tr>
    <tr><td>BST_HASHCODE</td>        <td>bst_hashcode</td>        <td>bstHashCode</td></tr>
    <tr><td>BST_IDX</td>             <td>bst_idx</td>             <td>a→mem[b-1]</td></tr>
    <tr><td>BST_LNG</td>             <td>bst_lng</td>             <td>a->size</td></tr>
    <tr><td>BST_NE</td>              <td>bst_ne</td>              <td>a->size!=b->size memcmp(a,b,a->size*sizeof(unsigned char))!=0</td></tr>
    <tr><td>BST_PARSE1</td>          <td>bst_parse1</td>          <td>bstParse</td></tr>
    <tr><td>BST_STR</td>             <td>bst_str</td>             <td>bstStr</td></tr>
    <tr><td>BST_VALUE</td>           <td>bst_value</td>           <td>bstValue</td></tr>
</table><p></p>
          <a name="actions_char">
        <h3>15.7 char型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>chrlib.c関数</th>   <th>chr_rtl.c関数</th></tr>
    <tr><td>CHR_CLIT</td>            <td>chr_clit</td>            <td>chrCLit</td></tr>
    <tr><td>CHR_CMP</td>             <td>chr_cmp</td>             <td>chrCmp</td></tr>
    <tr><td>CHR_CPY</td>             <td>chr_cpy</td>             <td>chrCpy</td></tr>
    <tr><td>CHR_CREATE</td>          <td>chr_create</td>          <td>=またはgenericCreate</td></tr>
    <tr><td>CHR_DECR</td>            <td>chr_decr</td>            <td>--</td></tr>
    <tr><td>CHR_EQ</td>              <td>chr_eq</td>              <td>==</td></tr>
    <tr><td>CHR_GE</td>              <td>chr_ge</td>              <td>>=</td></tr>
    <tr><td>CHR_GT</td>              <td>chr_gt</td>              <td>></td></tr>
    <tr><td>CHR_HASHCODE</td>        <td>chr_hashcode</td>        <td>(intType)((scharType)a)</td></tr>
    <tr><td>CHR_ICONV1</td>          <td>chr_iconv1</td>          <td>(charType)</td></tr>
    <tr><td>CHR_ICONV3</td>          <td>chr_iconv3</td>          <td>(charType)</td></tr>
    <tr><td>CHR_INCR</td>            <td>chr_incr</td>            <td>++</td></tr>
    <tr><td>CHR_IS_LETTER</td>       <td>chr_is_letter</td>       <td>ChristLetter</td></tr>
    <tr><td>CHR_LE</td>              <td>chr_le</td>              <td>&lt;=</td></tr>
    <tr><td>CHR_LOW</td>             <td>chr_low</td>             <td>chrLow</td></tr>
    <tr><td>CHR_LT</td>              <td>chr_lt</td>              <td>&lt;</td></tr>
    <tr><td>CHR_NE</td>              <td>chr_ne</td>              <td>=</td></tr>
    <tr><td>CHR_ORD</td>             <td>chr_ord</td>             <td>(intType)</td></tr>
    <tr><td>CHR_PRED</td>            <td>chr_pred</td>            <td>-1</td></tr>
    <tr><td>CHR_STR</td>             <td>chr_str</td>             <td>chrStr</td></tr>
    <tr><td>CHR_SUCC</td>            <td>chr_succc</td>            <td>+1</td></tr>
    <tr><td>CHR_UP</td>              <td>chr_up</td>              <td>chrUp</td></tr>
    <tr><td>CHR_VALUE</td>           <td>chr_value</td>           <td>chrValue</td></tr>
    <tr><td>CHR_WIDTH</td>           <td>chr_width</td>           <td>chrWidth</td></tr>
</table><p></p>
          <a name="actions_commands">
        <h3>15.8各種のディレクトリやファイルなどのコマンドに対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>cmdlib.c関数</th>   <th>cmd_rtl.c関数</th></tr>
    <tr><td>CMD_BIG_FILESIZE</td>    <td>cmd_big_filesize</td>    <td>cmdBigFileSize</td></tr>
    <tr><td>CMD_CHDIR</td>           <td>cmd_chdir</td>           <td>cmdCdir</td></tr>
    <tr><td>CMD_CLONE_FILE</td>      <td>cmd_clone_file</td>      <td>cmdCloneFile</td></tr>
    <tr><td>CMD_CONFIG_VALUE</td>    <td>cmd_config_value</td>    <td>cmdConfigValue</td></tr>
    <tr><td>CMD_COPY_FILE</td>       <td>cmd_copy_file</td>       <td>cmdCopyFile</td></tr>
    <tr><td>CMD_ENVIRONMENT</td>     <td>cmd_environment</td>     <td>cmd環境</td></tr>
    <tr><td>CMD_FILESIZE</td>        <td>cmd_filesize</td>        <td>cmdFileSize</td></tr>
    <tr><td>CMD_FILETYPE</td>        <td>cmd_filetype</td>        <td>cmdFileType</td></tr>
    <tr><td>CMD_FILETYPE_SL</td>     <td>cmd_filetype_sl</td>     <td>cmdFileTypeSL</td></tr>
    <tr><td>CMD_FINAL_PATH</td>      <td>cmd_final_path</td>      <td>cmdFinalPath</td></tr>
    <tr><td>CMD_GETCWD</td>          <td>cmd_getcwd</td>          <td>cmdGetcwd</td></tr>
    <tr><td>CMD_GETENV</td>          <td>cmd_getenv</td>          <td>cmdGetenv</td></tr>
    <tr><td>CMD_GET_ATIME</td>       <td>cmd_get_atime</td>       <td>cmdGetATime</td></tr>
    <tr><td>CMD_GET_ATIME_OF_SYMLINK</td> <td>cmd_get_atime_of_symlink</td> <td>cmdGetATimeOfSymlink</td></tr>
    <tr><td>CMD_GET_CTIME</td>       <td>cmd_get_ctime</td>       <td>cmdGetCTime</td></tr>
    <tr><td>CMD_GET_FILE_MODE</td>   <td>cmd_get_file_mode</td>   <td>cmdGetFileMode</td></tr>
    <tr><td>CMD_GET_FILE_MODE_OF_SYMLINK</td> <td>cmd_get_file_mode_of_symlink</td> <td>cmdGetFileModeOfSymlink</td></tr>
    <tr><td>CMD_GET_GROUP</td>       <td>cmd_get_group</td>       <td>cmdGetGroup</td></tr>
    <tr><td>CMD_GET_GROUP_OF_SYMLINK</td> <td>cmd_get_group_of_symlink</td> <td>cmdGetGroupOfSymlink</td></tr>
    <tr><td>CMD_GET_MTIME</td>       <td>cmd_get_mtime</td>       <td>cmdGetMTime</td></tr>
    <tr><td>CMD_GET_MTIME_OF_SYMLINK</td> <td>cmd_get_mtime_of_symlink</td> <td>cmdGetMTimeOfSymlink</td></tr>
    <tr><td>CMD_GET_OWNER</td>       <td>cmd_get_owner</td>       <td>cmdGetOwner</td></tr>
    <tr><td>CMD_GET_OWNER_OF_SYMLINK</td> <td>cmd_get_owner_of_symlink</td> <td>cmdGetOwnerOfSymlink</td></tr>
    <tr><td>CMD_GET_SEARCH_PATH</td> <td>cmd_get_search_path</td> <td>cmdGetSearchPath</td></tr>
    <tr><td>CMD_HOME_DIR</td>        <td>cmd_home_dir</td>        <td>cmdホームディレクトリ</td></tr>
    <tr><td>CMD_MAKE_DIR</td>        <td>cmd_make_dir</td>        <td>cmdMakeDir</td></tr>
    <tr><td>CMD_MAKE_LINK</td>       <td>cmd_make_link</td>       <td>cmdMakeLink</td></tr>
    <tr><td>CMD_MOVE</td>            <td>cmd_move</td>            <td>cmd移動</td></tr>
    <tr><td>CMD_READ_DIR</td>        <td>cmd_read_dir</td>        <td>cmdReadDir</td></tr>
    <tr><td>CMD_READ_LINK</td>       <td>cmd_read_link</td>       <td>cmdReadLink</td></tr>
    <tr><td>CMD_READ_LINK_ABSOLUTE</td> <td>cmd_read_link_absolute</td> <td>cmdReadLinkAbsolute</td></tr>
    <tr><td>CMD_REMOVE_FILE</td>     <td>cmd_remove_file</td>     <td>cmdRemoveFile</td></tr>
    <tr><td>CMD_REMOVE_TREE</td>     <td>cmd_remove_tree</td>     <td>cmdRemoveTree</td></tr>
    <tr><td>CMD_SETENV</td>          <td>cmd_setenv</td>          <td>cmdSetenv</td></tr>
    <tr><td>CMD_SET_ATIME</td>       <td>cmd_set_atime</td>       <td>cmdSetATime</td></tr>
    <tr><td>CMD_SET_FILEMODE</td>    <td>cmd_set_filemode</td>    <td>cmdSetFileMode</td></tr>
    <tr><td>CMD_SET_GROUP</td>       <td>cmd_set_group</td>       <td>cmdSetGroup</td></tr>
    <tr><td>CMD_SET_GROUP_OF_SYMLINK</td> <td>cmd_set_group_of_symlink</td> <td>cmdSetGroupOfSymlink</td></tr>
    <tr><td>CMD_SET_MTIME</td>       <td>cmd_set_mtime</td>       <td>cmdSetMTime</td></tr>
    <tr><td>CMD_SET_MTIME_OF_SYMLINK</td> <td>cmd_set_mtime_of_symlink</td> <td>cmdSetMTimeOfSymlink</td></tr>
    <tr><td>CMD_SET_OWNER</td>       <td>cmd_set_owner</td>       <td>cmdSetOwner</td></tr>
    <tr><td>CMD_SET_OWNER_OF_SYMLINK</td> <td>cmd_set_owner_of_symlink</td> <td>cmdSetOwnerOfSymlink</td></tr>
    <tr><td>CMD_SET_SEARCH_PATH</td> <td>cmd_set_search_path</td> <td>cmdSetSearchPath</td></tr>
    <tr><td>CMD_SHELL</td>           <td>cmd_shell</td>           <td>cmdShell</td></tr>
    <tr><td>CMD_SHELL_ESCAPE</td>    <td>cmd_shell_escape</td>    <td>cmdShellEscape</td></tr>
    <tr><td>CMD_TO_OS_PATH</td>      <td>cmd_to_os_path</td>      <td>cmdToOsPath</td></tr>
    <tr><td>CMD_UNSETENV</td>        <td>cmd_unsetenv</td>        <td>cmdUnsetenv</td></tr>
</table><p></p>
          <a name="actions_console_output">
        <h3>15.9テキスト(コンソール)画面出力時の操作</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>scrlib.c関数</th>   <th>con_inf.c/con_rtl.c/con_win.c関数</th></tr>
    <tr><td>CON_CLEAR</td>           <td>con_clear</td>           <td>conClear</td></tr>
    <tr><td>CON_COLUMN</td>          <td>con_column</td>          <td>conColumn</td></tr>
    <tr><td>CON_CURSOR</td>          <td>con_cursor</td>          <td>conCursor</td></tr>
    <tr><td>CON_FLUSH</td>           <td>con_flush</td>           <td>conFlush</td></tr>
    <tr><td>CON_HEIGHT</td>          <td>上から下</td>          <td>conHeight</td></tr>
    <tr><td>CON_H_SCL</td>           <td>閉じて</td>           <td>conHScroll</td></tr>
    <tr><td>CON_LINE</td>            <td>本文</td>            <td>オンライン</td></tr>
    <tr><td>CON_OPEN</td>            <td>con_open</td>            <td>conOpen</td></tr>
    <tr><td>CON_SE TT POS</td>          <td>con_setpos</td>          <td>conSetpos</td></tr>
    <tr><td>CON_V_SCL</td>           <td>con_v_scl</td>           <td>conVScroll</td></tr>
    <tr><td>CON_WIDTH</td>           <td>接続幅</td>           <td>conWidth</td></tr>
    <tr><td>CON_WRITE</td>           <td>con_write</td>           <td>conWrite</td></tr>
</table><p></p>
          <a name="actions_declarations">
        <h3>15.10申告の措置</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>dcllib.c関数</th></tr>
    <tr><td>DCL_ATTR</td>            <td>dcl_attr</td></tr>
    <tr><td>DCL_CONST</td>           <td>dcl_const</td></tr>
    <tr><td>DCL_ELEMENTS</td>        <td>dcl_elements</td></tr>
    <tr><td>DCL_FWD</td>             <td>dcl_fwd</td></tr>
    <tr><td>DCL_FWDVAR</td>          <td>dcl_fwdvar</td></tr>
    <tr><td>DCL_GETFUNC</td>         <td>dcl_getfunc</td></tr>
    <tr><td>DCL_GETOBJ</td>          <td>dcl_getobj</td></tr>
    <tr><td>DCL_GLOBAL</td>          <td>dcl_global</td></tr>
    <tr><td>DCL_IN1</td>             <td>dcl_in1</td></tr>
    <tr><td>DCL_IN1VAR</td>          <td>dcl_in1var</td></tr>
    <tr><td>DCL_IN2</td>             <td>dcl_in2</td></tr>
    <tr><td>DCL_IN2VAR</td>          <td>dcl_in2var</td></tr>
    <tr><td>DCL_INOUT1</td>          <td>dcl_inout1</td></tr>
    <tr><td>DCL_INOUT2</td>          <td>dcl_inout2</td></tr>
    <tr><td>DCL_PARAM_ATTR</td>      <td>dcl_param_attr</td></tr>
    <tr><td>DCL_REF1</td>            <td>dcl_ref1</td></tr>
    <tr><td>DCL_REF2</td>            <td>dcl_ref2</td></tr>
    <tr><td>DCL_SYMBOL</td>            <td>dcl_symbol</td></tr>
    <tr><td>DCL構文</td>          <td>dcl_syntax</td></tr>
    <tr><td>DCL_VAL1</td>            <td>dcl_val1</td></tr>
    <tr><td>DCL_VAL2</td>            <td>dcl_val2</td></tr>
    <tr><td>DCL_VAR</td>             <td>dcl_var</td></tr>
</table><p></p>
          <a name="actions_graphic_output">
        <h3>15.11グラフィック出力を行うためのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>drwlib.c関数</th>   <th>drw_rtl.c/drw_x11.c/drw_win.c関数</th></tr>
    <tr><td>DRW_BORDER</td>          <td>drw_border</td>          <td>drwBorder</td></tr>
    <tr><td>DRW_CAPTURE</td>         <td>drw_capture</td>         <td>drwCapture</td></tr>
    <tr><td>DRW_CLEAR</td>           <td>drw_clear</td>           <td>drwClear</td></tr>
    <tr><td>DRW_CMP</td>             <td>drw_cmp</td>             <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>DRW_CONV_POINT_LIST</td> <td>drw_conv_point_list</td> <td>drwConvPointList</td></tr>
    <tr><td>DRW_COPYAREA</td>        <td>drw_copyarea</td>        <td>drwCopyArea</td></tr>
    <tr><td>DRW_CPY</td>             <td>drw_cpy</td>             <td>drwCpy</td></tr>
    <tr><td>DRW_CREATE</td>          <td>drw_create</td>          <td>drwCreate</td></tr>
    <tr><td>DRW_DETR</td>           <td>drw_detr</td>           <td>drwDestr</td></tr>
    <tr><td>DRW_EMPTY</td>           <td>drw_empty</td>           <td> </td></tr>
    <tr><td>DRW_EQ</td>              <td>drw_eq</td>              <td>==</td></tr>
    <tr><td>DRW_FLUSH</td>           <td>drw_flush</td>           <td>drwFlush</td></tr>
    <tr><td>DRW_FPOLY_LINE</td>      <td>drw_fpoly_line</td>      <td>drwFPolyLine</td></tr>
    <tr><td>DRW_GEN_POINT_LIST</td>  <td>drw_gen_point_list</td>  <td>drwGenPointList</td></tr>
    <tr><td>DRW_GET_IMAGE_PIXEL</td> <td>drw_get_image_pixel</td> <td>drwGetImagePixel</td></tr>
    <tr><td>DRW_GET_PIXEL</td>       <td>drw_get_pixel</td>       <td>drwGetPixel</td></tr>
    <tr><td>DRW_GET_PIXEL_ARRAY</td> <td>drw_get_pixel_array</td> <td>drwGetPixelArray</td></tr>
    <tr><td>DRW_GET_PIXEL_DATA</td>  <td>drw_get_pixel_data</td>  <td>drwGetPixelData</td></tr>
    <tr><td>DRW_GET_PIXEL_DATA_FROM_ARRAY</td> <td>drw_get_pixel_data_from_array</td> <td>drwGetPixelDataFromArray</td></tr>
    <tr><td>DRW_GET_PIXMAP</td>      <td>drw_get_pixmap</td>      <td>drwGetPixmap</td></tr>
    <tr><td>DRW_GET_PIXMAP_FROM_PIXELS</td> <td>drw_get_pixmap_from_pixels</td> <td>drwGetPixmapFromPixels</td></tr>
    <tr><td>DRW_HASHCODE</td>        <td>drw_hashcode</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>DRW_HEIGHT</td>          <td>drw_height</td>          <td>drwHeight</td></tr>
    <tr><td>DRW_NE</td>              <td>drw_ne</td>              <td>=</td></tr>
    <tr><td>DRW_NEW_PIXMAP</td>      <td>drw_new_pixmap</td>      <td>drwNewPixmap</td></tr>
    <tr><td>DRW_OPEN</td>            <td>drw_open</td>            <td>drwOpen</td></tr>
    <tr><td>DRW_OPEN_SUB_WINDOW</td> <td>drw_open_sub_window</td> <td>drwOpenSubWindow</td></tr>
    <tr><td>DRW_PARC</td>            <td>drw_parc</td>            <td>drwPArc</td></tr>
    <tr><td>DRW_PCIRCLE</td>         <td>drw_pcircle</td>         <td>drwPCircle</td></tr>
    <tr><td>DRW_PFARC</td>           <td>drw_pfarc</td>           <td>drwPFArc</td></tr>
    <tr><td>DRW_PFARCCHORD</td>      <td>drw_pcharchord</td>      <td>drwPfARcCord</td></tr>
    <tr><td>DRW_PFARCPIESLICE</td>   <td>drw_pfpgarsice</td>   <td>drwFArcPieSlice</td></tr>
    <tr><td>DRW_PFCIRCLE</td>        <td>drw_pfcircle</td>        <td>drwPFCircle</td></tr>
    <tr><td>DRW_PFELEX</td>       <td>drw_pfelex</td>       <td>drwPFEllex</td></tr>
    <tr><td>DRW_PIXEL_TO_RGB</td>    <td>drw_pixel_to_rgb</td>    <td>drwPixelToRgb</td></tr>
    <tr><td>DRW_PLINE</td>           <td>drw_pline</td>           <td>drwPLine</td></tr>
    <tr><td>DRW_POINTER_XPOS</td>    <td>drw_pointer_xpos</td>    <td>drwPointerXpos</td></tr>
    <tr><td>DRW_POINTER_YPOS</td>    <td>drw_pointer_ypos</td>    <td>drwPointerYpos</td></tr>
    <tr><td>DRW_POLY_LINE</td>       <td>drw_poly_line</td>       <td>drwPolyLine</td></tr>
    <tr><td>DRW_PPOINT</td>          <td>drw_ppoint</td>          <td>drwPPoint</td></tr>
    <tr><td>DRW_PRECT</td>           <td>drw_prect</td>           <td>drwPRect</td></tr>
    <tr><td>DRW_PUT</td>             <td>drw_put</td>             <td>drwPut</td></tr>
    <tr><td>DRW_PUT_SCALED</td>      <td>drw_put_scaled</td>      <td>drwPutScaled</td></tr>
    <tr><td>DRW_RGBCOL</td>          <td>drw_rgbcol</td>          <td>drwRgbColor</td></tr>
    <tr><td>DRW_SCREEN_HEIGHT</td>   <td>drw_screen_height</td>   <td>drwScreenHeight</td></tr>
    <tr><td>DRW_SCREEN_WIDTH</td>    <td>drw_screen_width</td>    <td>drwScreenWidth</td></tr>
    <tr><td>DRW_SET_CLOSE_ACTION</td> <td>drw_set_close_action</td> <td>drwSetCloseAction</td></tr>
    <tr><td>DRW_SET_CONTENT</td>     <td>drw_set_content</td>     <td>drwSetContent</td></tr>
    <tr><td>DRW_SET_CURSOR_VISIBLE</td> <td>drw_set_cursor_visible</td> <td>drwSetCursorVisible</td></tr>
    <tr><td>DRW_SET_POINTER_POS</td> <td>drw_set_pointer_pos</td> <td>drwSetPointerPos</td></tr>
    <tr><td>DRW_SET_POS</td>         <td>drw_set_pos</td>         <td>drwSetPos</td></tr>
    <tr><td>DRW_SET_TRANSPARENT_COLOR</td> <td>drw_set_transparent_color</td> <td>drwSetTransparentColor</td></tr>
    <tr><td>DRW_SET_WINDOW_NAME</td> <td>drw_set_window_name</td> <td>drwSetWindowName</td></tr>
    <tr><td>DRW_TEXT</td>            <td>drw_text</td>            <td>drwText</td></tr>
    <tr><td>DRW_TO_BOTTOM</td>       <td>drw_to_bottom</td>       <td>drwTo下</td></tr>
    <tr><td>DRW_TO_TOP</td>          <td>drw_to_top</td>          <td>drwToトップ</td></tr>
    <tr><td>DRW_VALUE</td>           <td>drw_value</td>           <td>drwValue</td></tr>
    <tr><td>DRW_WIDTH</td>           <td>drw_width</td>           <td>drwWidth</td></tr>
    <tr><td>DRW_XPOS</td>            <td>drw_xpos</td>            <td>drwXPos</td></tr>
    <tr><td>DRW_YPOS</td>            <td>drw_ypos</td>            <td>drwYPos</td></tr>
</table><p></p>
          <a name="actions_enumeration">
        <h3>15.12列挙型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>enulib.c関数</th>   <th> </th></tr>
    <tr><td>ENU_CONV</td>            <td>jpn_conv</td>            <td>(noop)</td></tr>
    <tr><td>ENU_CPY</td>             <td>jpn_cpy</td>             <td>=</td></tr>
    <tr><td>ENU_CREATE</td>          <td>enu_create</td>          <td>=またはgenericCreate</td></tr>
    <tr><td>ENU_EQ</td>              <td>jpn_eq</td>              <td>==</td></tr>
    <tr><td>ENU_GENLIT</td>          <td>jpn_genlit</td>          <td> </td></tr>
    <tr><td>ENU_ICONV2</td>          <td>enu_iconv2</td>          <td>(noop)</td></tr>
    <tr><td>ENU_LIT</td>             <td>enu_lit</td>             <td> </td></tr>
    <tr><td>ENU_NE</td>              <td>enu_ne</td>              <td>=</td></tr>
    <tr><td>ENU_ORD2</td>            <td>jpn_ord2</td>            <td>(noop)</td></tr>
    <tr><td>ENU_VALUE</td>           <td>jpn_value</td>           <td>enuValue</td></tr>
</table><p></p>
          <a name="actions_clib_file">
        <h3>15.13 clib_fileタイプのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>fillib.c関数</th>   <th>fil_rtl.c関数</th></tr>
    <tr><td>FIL_BIG_LNG</td>         <td>fil_big_lng</td>         <td>filBigLng</td></tr>
    <tr><td>FIL_BIG_SEEK</td>        <td>fil_big_seek</td>        <td>filBigSeek</td></tr>
    <tr><td>FIL_BIG_TELL</td>        <td>fil_big_tell</td>        <td>filBigTell</td></tr>
    <tr><td>FIL_CLOSE</td>           <td>fil_close</td>           <td>寝る</td></tr>
    <tr><td>FIL_CPY</td>             <td>fil_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FIL_CREATE</td>          <td>fil_create</td>          <td>flt作成</td></tr>
    <tr><td>FIL_DESTR</td>           <td>fil_detr</td>           <td>filDestr</td></tr>
    <tr><td>FIL_EMPTY</td>           <td>fil_empty</td>           <td> </td></tr>
    <tr><td>FIL_EOF</td>             <td>fil_eof</td>             <td>feof</td></tr>
    <tr><td>FIL_EQ</td>              <td>fil_eq</td>              <td>==</td></tr>
    <tr><td>FIL_ERR</td>             <td>fil_err</td>             <td>stderr</td></tr>
    <tr><td>FIL_FLUSH</td>           <td>fil_flush</td>           <td>どっと飛ぶ</td></tr>
    <tr><td>FIL_GETC</td>            <td>fil_getc</td>            <td>fgetc</td></tr>
    <tr><td>FIL_GETS</td>            <td>fil_gets</td>            <td>filGets</td></tr>
    <tr><td>FIL_HAS_NEXT</td>        <td>fil_has_next</td>        <td>filHasNext</td></tr>
    <tr><td>FIL_IN</td>              <td>fil_in</td>              <td>stdin</td></tr>
    <tr><td>FIL_INPUT_READY</td>     <td>fil_input_ready</td>     <td>filInputReady</td></tr>
    <tr><td>FIL_LINE_READ</td>       <td>fil_line_read</td>       <td>filLineRead</td></tr>
    <tr><td>FIL_LIT</td>             <td>fil_lit</td>             <td>filLit</td></tr>
    <tr><td>FIL_LNG</td>             <td>fil_lng</td>             <td>filLng</td></tr>
    <tr><td>FIL_NE</td>              <td>fil_ne</td>              <td>=</td></tr>
    <tr><td>FIL_OPEN</td>            <td>fil_open</td>            <td>filOpen</td></tr>
    <tr><td>FIL_OPEN_NULL_DEVICE</td> <td>fil_open_null_device</td> <td>filOpenNullDevice</td></tr>
    <tr><td>FIL_OUT</td>             <td>fil_out</td>             <td>標準出力</td></tr>
    <tr><td>FIL_PCLOSE</td>          <td>fil_pclose</td>          <td>filPclose</td></tr>
    <tr><td>FIL_PIPE</td>            <td>fil_pipe</td>            <td>filPipe</td></tr>
    <tr><td>FIL_POPEN</td>           <td>fil_popen</td>           <td>filPopen</td></tr>
    <tr><td>FIL_PRINT</td>           <td>fil_print</td>           <td>filPrint</td></tr>
    <tr><td>FIL_SEEK</td>            <td>fil_seek</td>            <td>filSeek</td></tr>
    <tr><td>FIL_SEEKABLE</td>        <td>fil_seekable</td>        <td>filSeekable</td></tr>
    <tr><td>FIL_SETBUF</td>          <td>fil_setbuf</td>          <td>filSetbuf</td></tr>
    <tr><td>FIL_TELL</td>            <td>fil_tell</td>            <td>filTell</td></tr>
    <tr><td>FIL_TERMINATED_READ</td> <td>fil_terminated_read</td> <td>filTerminatedRead</td></tr>
    <tr><td>FIL_TRUNCATE</td>        <td>fil_truncate</td>        <td>filTruncate</td></tr>
    <tr><td>FIL_VALUE</td>           <td>fil_value</td>           <td>filValue</td></tr>
    <tr><td>FIL_WORD_READ</td>       <td>fil_word_read</td>       <td>filWordRead</td></tr>
    <tr><td>FIL_WRITE</td>           <td>fil_write</td>           <td>filWrite</td></tr>
</table><p></p>
          <a name="actions_float">
        <h3>15.14 float型の処理</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>flt.c関数</th>   <th>flt_rtl.c関数</th></tr>
    <tr><td>FLT_ABS</td>             <td>flt_abs</td>             <td>ファブ</td></tr>
    <tr><td>FLT_ACOS</td>            <td>flt_acos</td>            <td>acos</td></tr>
    <tr><td>FLT_ADD</td>             <td>flt_add</td>             <td>+</td></tr>
    <tr><td>FLT_ADD_ASSIGN</td>      <td>flt_add_assign</td>      <td>+=</td></tr>
    <tr><td>FLT_ASIN</td>            <td>flt_asin</td>            <td>asin</td></tr>
    <tr><td>FLT_ATAN</td>            <td>flt_atan</td>            <td>アタン</td></tr>
    <tr><td>FLT_ATAN2</td>           <td>flt_atan2</td>           <td>atan2</td></tr>
    <tr><td>FLT_BITS2DOUBLE</td>     <td>flt_bits2double</td>     <td>(x.bits=a, x.aDouble)</td></tr>
    <tr><td>FLT_BITS2SINGLE</td>     <td>flt_bits2single</td>     <td>(x.bits=a, x.aSingle)</td></tr>
    <tr><td>FLT_CEIL</td>            <td>flt_ceil</td>            <td>天井</td></tr>
    <tr><td>FLT_CMP</td>             <td>flt_cmp</td>             <td>fltCmp</td></tr>
    <tr><td>FLT_COS</td>             <td>flt_cos</td>             <td>cos</td></tr>
    <tr><td>FLT_COSH</td>            <td>flt_cosh</td>            <td>cosh</td></tr>
    <tr><td>FLT_CPY</td>             <td>flt_cpy</td>             <td>fltCpy</td></tr>
    <tr><td>FLT_CREATE</td>          <td>flt_create</td>          <td>=またはgenericCreate</td></tr>
    <tr><td>FLT_DECOMPOSE</td>       <td>flt_decompose</td>       <td>フリーズ</td></tr>
    <tr><td>FLT_DGTS</td>            <td>flt_dgts</td>            <td>円Dgts</td></tr>
    <tr><td>FLT_DIV</td>             <td>flt_div</td>             <td>/</td></tr>
    <tr><td>FLT_DIV_ASSIGN</td>      <td>flt_div_assign</td>      <td>/=</td></tr>
    <tr><td>FLT_DOUBLE 2ビット</td>     <td>flt_double 2ビット</td>     <td>(x.aDouble=a, x.bits)</td></tr>
    <tr><td>FLT_EQ</td>              <td>flt_eq</td>              <td>==</td></tr>
    <tr><td>FLT_EXP</td>             <td>flt_exp</td>             <td>exp</td></tr>
    <tr><td>FLT_EXPM1</td>           <td>flt_expm1</td>           <td>expm1</td></tr>
    <tr><td>FLT_FLOOR</td>           <td>床面</td>           <td>床</td></tr>
    <tr><td>FLT_GE</td>              <td>flt_ge</td>              <td>>=</td></tr>
    <tr><td>FLT_GT</td>              <td>flt_gt</td>              <td>></td></tr>
    <tr><td>FLT_HASHCODE</td>        <td>flt_hashcode</td>        <td>(x.floatValue=a, x.intValue)</td></tr>
    <tr><td>FLT_ICONV1</td>          <td>flt_iconv1</td>          <td>(float)</td></tr>
    <tr><td>FLT_ICONV3</td>          <td>flt_iconv3</td>          <td>(float)</td></tr>
    <tr><td>FLT_IPOW</td>            <td>flt_ipow</td>            <td>flt</td></tr>
    <tr><td>FLT_ISNAN</td>           <td>flt_isnan</td>           <td>イスナン</td></tr>
    <tr><td>FLT_ISNEGATIVE 0</td>  <td>flt_isnegative 0</td>  <td>flt 1ネガティブゼロ</td></tr>
    <tr><td>FLT_LE</td>              <td>flt_le</td>              <td>&lt;=</td></tr>
    <tr><td>FLT_LOG</td>             <td>flt_log</td>             <td>丸太</td></tr>
    <tr><td>FLT_LOG10</td>           <td>flt_log10</td>           <td>log10</td></tr>
    <tr><td>FLT_LOG1P</td>           <td>flt_log1p</td>           <td>log1p</td></tr>
    <tr><td>FLT_LOG2</td>            <td>flt_log2</td>            <td>log2</td></tr>
    <tr><td>FLT_LSHIFT</td>          <td>flt_lshift</td>          <td>ldexp</td></tr>
    <tr><td>FLT_LT</td>              <td>flt_lt</td>              <td>&lt;</td></tr>
    <tr><td>FLT_MOD</td>             <td>flt_mod</td>             <td>fltMod</td></tr>
    <tr><td>FLT_MULT</td>            <td>flt_mult</td>            <td>*</td></tr>
    <tr><td>FLT_MULT_ASSIGN</td>     <td>flt_mult_assign</td>     <td>*=</td></tr>
    <tr><td>FLT_NE</td>              <td>flt_ne</td>              <td>=</td></tr>
    <tr><td>FLT_NEGATE</td>          <td>flt_negate</td>          <td>-</td></tr>
    <tr><td>FLT_PARSE1</td>          <td>flt_parse1</td>          <td>flt解析</td></tr>
    <tr><td>FLT_PLUS</td>            <td>flt_plus</td>            <td>(noop)</td></tr>
    <tr><td>FLT_POW</td>             <td>flt_pow</td>             <td>pow</td></tr>
    <tr><td>FLT_RAND</td>            <td>flt_rand</td>            <td>fltRand</td></tr>
    <tr><td>FLT_REM</td>             <td>flt_rem</td>             <td>fmod</td></tr>
    <tr><td>FLT_ROUND</td>           <td>回転</td>           <td>a&lt;0.0?-((intType)(0.5-a)):(intType)(0.5+a)</td></tr>
    <tr><td>FLT_RSHIFT</td>          <td>flt_rshift</td>          <td>ldexp</td></tr>
    <tr><td>FLT_SBTR</td>            <td>flt_sbtr</td>            <td>-</td></tr>
    <tr><td>FLT_SBTR_ASSIGN</td>     <td>flt_sbtr_assign</td>     <td>-=</td></tr>
    <tr><td>FLT_SCI</td>             <td>flt_sci</td>             <td>fltSci</td></tr>
    <tr><td>FLT_SIN</td>             <td>flt_sin</td>             <td>罪</td></tr>
    <tr><td>FLT_SINGLE 2ビット</td>     <td>flt_single 2ビット</td>     <td>(x.aSingle=a, x.bits)</td></tr>
    <tr><td>FLT_SINH</td>            <td>flt_sinh</td>            <td>シン</td></tr>
    <tr><td>FLT_SQRT</td>            <td>flt_sqrt</td>            <td>sqrt</td></tr>
    <tr><td>FLT_STR</td>             <td>flt_str</td>             <td>flt</td></tr>
    <tr><td>FLT_STR_SCIENTIFIC</td>  <td>flt_str_scientific</td>  <td>flt科学</td></tr>
    <tr><td>FLT_TAN</td>             <td>flt_tan</td>             <td>日焼けする</td></tr>
    <tr><td>FLT_TANH</td>            <td>flt_tanh</td>            <td>タン</td></tr>
    <tr><td>FLT_TRUNC</td>           <td>flt_trunc</td>           <td>(intType)</td></tr>
    <tr><td>FLT_VALUE</td>           <td>flt_value</td>           <td>flt値</td></tr>
</table><p></p>
          <a name="actions_graphic_keyboard">
        <h3>15.15グラフィックキーボードをサポートするためのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>drwlib.c関数</th>   <th>kbd_rtl.c/drw_x11.c/drw_win.c関数</th></tr>
    <tr><td>GKB_BUTTON_PRESSED</td>  <td>gkb_button_pressed</td>  <td>gkbButtonPressed</td></tr>
    <tr><td>GKB_CLICKED_XPOS</td>    <td>gkb_clicked_xpos</td>    <td>gkbClickedXpos</td></tr>
    <tr><td>GKB_CLICKED_YPOS</td>    <td>gkb_clicked_ypos</td>    <td>gkbClickedYpos</td></tr>
    <tr><td>GKB_GETC</td>            <td>gkb_getc</td>            <td>gkbGetc</td></tr>
    <tr><td>GKB_GETS</td>            <td>gkb_gets</td>            <td>gkbGets</td></tr>
    <tr><td>GKB_INPUT_READY</td>     <td>gkb_input_ready</td>     <td>gkbInputReady</td></tr>
    <tr><td>GKB_LINE_READ</td>       <td>gkb_line_read</td>       <td>gkbLineRead</td></tr>
    <tr><td>GKB_RAW_GETC</td>        <td>gkb_raw_getc</td>        <td>gkbRawGetc</td></tr>
    <tr><td>GKB_SELECT_INPUT</td>    <td>gkb_select_input</td>    <td>gkbSelectInput</td></tr>
    <tr><td>GKB_WINDOW</td>          <td>gkb_window</td>          <td>gkbWindow</td></tr>
    <tr><td>GKB_WORD_READ</td>       <td>gkb_word_read</td>       <td>gkbWordRead</td></tr>
</table><p></p>
          <a name="actions_hash">
        <h3>15.16ハッシュタイプに対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>hshlib.c関数</th>   <th>hsh_rtl.c関数</th></tr>
    <tr><td>HSH_CONCAT_KEY_VALUE</td> <td>hsh_concat_key_value</td> <td>hshConcatKeyValue</td></tr>
    <tr><td>HSH_CONTAINS</td>        <td>hsh_contains</td>        <td>hsh内容</td></tr>
    <tr><td>HSH_CPY</td>             <td>hsh_cpy</td>             <td>hshCpy</td></tr>
    <tr><td>HSH_CREATE</td>          <td>hsh_create</td>          <td>hshCreate</td></tr>
    <tr><td>HSH_DESTR</td>           <td>hsh_detr</td>           <td>hshDestr</td></tr>
    <tr><td>HSH_EMPTY</td>           <td>hsh_empty</td>           <td>hshEmpty</td></tr>
    <tr><td>HSH_EXCL</td>            <td>hsh_ex</td>            <td>hsh除外</td></tr>
    <tr><td>HSH_FOR</td>             <td>hsh_for</td>             <td>の</td></tr>
    <tr><td>HSH_FOR_DATA_KEY</td>    <td>hsh_for_data_key</td>    <td>の</td></tr>
    <tr><td>HSH_FOR_KEY</td>         <td>hsh_for_key</td>         <td>の</td></tr>
    <tr><td>HSH_GEN_HASH</td>        <td>hsh_gen_hash</td>        <td>hshGenHash</td></tr>
    <tr><td>HSH_GEN_KEY_VALUE</td>   <td>hsh_gen_key_value</td>   <td>hshGenKeyValue</td></tr>
    <tr><td>HSH_IDX</td>             <td>hsh_idx</td>             <td>hshIdx, hshIdxAddr</td></tr>
    <tr><td>HSH_IDX2</td>            <td>hsh_idx2</td>            <td> </td></tr>
    <tr><td>HSH_INCL</td>            <td>hsh_incl</td>            <td>hshIncl</td></tr>
    <tr><td>HSH_KEYS</td>            <td>hsh_keys</td>            <td>hshKeys</td></tr>
    <tr><td>HSH_LNG</td>             <td>hsh_lng</td>             <td>a->size</td></tr>
    <tr><td>HSH_RAND_KEY</td>        <td>hsh_rand_key</td>        <td>hshRand</td></tr>
    <tr><td>HSH_REFIDX</td>          <td>hsh_refidx</td>          <td> </td></tr>
    <tr><td>HSH_UPDATE</td>          <td>hsh_update</td>          <td>hshUpdate</td></tr>
    <tr><td>HSH_VALUES</td>          <td>hsh_values</td>          <td>hshValues</td></tr>
</table><p></p>
          <a name="actions_integer">
        <h3>15.17 integer型のアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>intlib.c関数</th>   <th>int_rtl.c関数</th></tr>
    <tr><td>INT_ABS</td>             <td>int_abs</td>             <td>ラボ</td></tr>
    <tr><td>
          <a name="actions_INT_ADD"        >INT_ADD</a>
        </td>             <td>int_add</td>             <td>+</td></tr>
    <tr><td>INT_ADD_ASSIGN</td>      <td>int_add_assign</td>      <td>+=</td></tr>
    <tr><td>INT_BINOM</td>           <td>int_binom</td>           <td>intBinom</td></tr>
    <tr><td>INT_BIT_LENGTH</td>      <td>int_bit_length</td>      <td>intBitLength</td></tr>
    <tr><td>INT_BYTES_BE_2_INT</td>  <td>int_bytes_be_2_int</td>  <td>intBytesBe2Int</td></tr>
    <tr><td>INT_BYTES_BE_2_UINT</td> <td>int_bytes_be_2_uint</td> <td>intBytesBe2UInt</td></tr>
    <tr><td>INT_BYTES_BE_SIGNED</td> <td>int_bytes_be_signed</td> <td>intBytesBe</td></tr>
    <tr><td>INT_BYTES_BE_UNSIGNED</td> <td>int_bytes_be_unsigned</td> <td>intBytesBe</td></tr>
    <tr><td>INT_BYTES_LE_2_INT</td>  <td>int_bytes_le_2_int</td>  <td>intBytesLe2Int</td></tr>
    <tr><td>INT_BYTES_LE_2_UINT</td> <td>int_bytes_le_2_uint</td> <td>intBytesLe2UInt</td></tr>
    <tr><td>INT_BYTES_LE_SIGNED</td> <td>int_bytes_le_signed</td> <td>intBytesLe</td></tr>
    <tr><td>INT_BYTES_LE_UNSIGNED</td> <td>int_bytes_le_unsigned</td> <td>intBytesLe</td></tr>
    <tr><td>INT_CMP</td>             <td>int_cmp</td>             <td>intCmp</td></tr>
    <tr><td>INT_CPY</td>             <td>int_cpy</td>             <td>intCpy</td></tr>
    <tr><td>INT_CREATE</td>          <td>int_create</td>          <td>=またはgenericCreate</td></tr>
    <tr><td>INT_DECR</td>            <td>int_decr</td>            <td>--</td></tr>
    <tr><td>INT_DIV</td>             <td>int_div</td>             <td>/</td></tr>
    <tr><td>INT_EQ</td>              <td>int_eq</td>              <td>==</td></tr>
    <tr><td>INT_FACT</td>            <td>int_fact</td>            <td>事実[a]</td></tr>
    <tr><td>INT_GE</td>              <td>整数値</td>              <td>>=</td></tr>
    <tr><td>INT_GT</td>              <td>int_gt</td>              <td>></td></tr>
    <tr><td>INT_HASHCODE</td>        <td>int_hashcode</td>        <td>(noop)</td></tr>
    <tr><td>INT_ICONV1</td>          <td>int_iconv1</td>          <td>(noop)</td></tr>
    <tr><td>INT_ICONV3</td>          <td>int_iconv3</td>          <td>(noop)</td></tr>
    <tr><td>INT_INCR</td>            <td>int_incr</td>            <td>++</td></tr>
    <tr><td>INT_LE</td>              <td>int_le</td>              <td>&lt;=</td></tr>
    <tr><td>
          <a name="actions_INT_LOG10"      >INT_LOG10</a>
        </td>           <td>int_log10</td>           <td>intLog10</td></tr>
    <tr><td>
          <a name="actions_INT_LOG2"       >INT_LOG2</a>
        </td>            <td>int_log2</td>            <td>intLog2</td></tr>
    <tr><td>INT_LOWEST_SET_BIT</td>  <td>int_lowest_set_bit</td>  <td>intLowestSetBit</td></tr>
    <tr><td>INT_LPAD0</td>           <td>int_lpad0</td>           <td>intLpad0</td></tr>
    <tr><td>INT_LSHIFT</td>          <td>int_lshift</td>          <td>&lt;&lt;</td></tr>
    <tr><td>INT_LSHIFT_ASSIGN</td>   <td>int_lshift_assign</td>   <td>&lt;&lt;=</td></tr>
    <tr><td>INT_LT</td>              <td>int_lt</td>              <td>&lt;</td></tr>
    <tr><td>INT_MDIV</td>            <td>int_mdiv</td>            <td>a>0&amp;&amp;b&lt;0?(a-1)/b-1:a&lt;0&amp;&amp;b>0?(a+1)/b-1:a/b</td></tr>
    <tr><td>INT_MOD</td>             <td>int_mod</td>             <td>c=a%b, ((a>0&amp;&amp;b&lt;0)(a&lt;0&amp;&amp;b>0))&amp;&amp;c!=0?c+b:c</td></tr>
    <tr><td>INT_MULT</td>            <td>int_mult</td>            <td>*</td></tr>
    <tr><td>INT_MULT_ASSIGN</td>     <td>int_mult_assign</td>     <td>*=</td></tr>
    <tr><td>INT_NE</td>              <td>int_ne</td>              <td>=</td></tr>
    <tr><td>INT_NEGATE</td>          <td>int_negate</td>          <td>-</td></tr>
    <tr><td>INT_N_BYTES_BE_SIGNED</td>   <td>int_n_bytes_be_signed</td>   <td>intNBytesBeSigned</td></tr>
    <tr><td>INT_N_BYTES_BE_UNSIGNED</td> <td>int_n_bytes_be_unsigned</td> <td>intNBytesBeUnsigned</td></tr>
    <tr><td>INT_N_BYTES_LE_SIGNED</td>   <td>int_n_bytes_le_signed</td>   <td>intNBytesLeSigned</td></tr>
    <tr><td>INT_N_BYTES_LE_UNSIGNED</td> <td>int_n_bytes_le_unsigned</td> <td>intNBytesLeUnsigned</td></tr>
    <tr><td>INT_ODD</td>             <td>整数奇数</td>             <td>&amp;1</td></tr>
    <tr><td>INT_PARSE1</td>          <td>int_parse1</td>          <td>intParse</td></tr>
    <tr><td>INT_PLUS</td>            <td>int_plus</td>            <td>(noop)</td></tr>
    <tr><td>INT_POW</td>             <td>int_pow</td>             <td>intPow</td></tr>
    <tr><td>INT_PRED</td>            <td>int_pred</td>            <td>--</td></tr>
    <tr><td>INT_RADIX</td>           <td>int_RADIX</td>           <td>intrOdix</td></tr>
    <tr><td>INT_RAND</td>            <td>int_rand</td>            <td>intRand</td></tr>
    <tr><td>INT_REM</td>             <td>int_rem</td>             <td>%</td></tr>
    <tr><td>INT_RSHIFT</td>          <td>int_rshift</td>          <td>a>>b<span class="comment">/*C with arithmetic shift*/</span><br />a&lt;0?~(~a>>b):a>>b<span class="comment">/*C言語+論理シフト*/</span></td></tr>
    <tr><td>INT_RSHIFT_ASSIGN</td>   <td>int_rshift_assign</td>   <td>a>>=b<span class="comment">/*C with arithmetic shift*/</span><br />if(a&lt;0) a= ~(~a>>b);それ以外の場合a>>=b;<span class="comment">/*C言語+論理シフト*/</span></td></tr>
    <tr><td>INT_SBTR</td>            <td>int_sbtr</td>            <td>-</td></tr>
    <tr><td>INT_SBTR_ASSIGN</td>     <td>int_sbtr_assign</td>     <td>-=</td></tr>
    <tr><td>INT_SQRT</td>            <td>int_sqrt</td>            <td>intSqrt</td></tr>
    <tr><td>INT_STR</td>             <td>int_str</td>             <td>intStr</td></tr>
    <tr><td>INT_SUCC</td>            <td>int_succc</td>            <td>+1</td></tr>
    <tr><td>INT_VALUE</td>           <td>int_value</td>           <td>intValue</td></tr>
    <tr><td>INT_radix</td>           <td>int_radix</td>           <td>intrOdix</td></tr>
</table><p></p>
          <a name="actions_interface">
        <h3>15.18インタフェースの種類に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>itflib.c関数</th>   <th> </th></tr>
    <tr><td>ITF_CMP</td>             <td>itf_cmp</td>             <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>ITF_CONV2</td>           <td>itf_conv2</td>           <td>(noop)</td></tr>
    <tr><td>ITF_CPY</td>             <td>itf_cpy</td>             <td>=</td></tr>
    <tr><td>ITF_CPY2</td>            <td>itf_cpy2</td>            <td>=</td></tr>
    <tr><td>ITF_CREATE</td>          <td>itf_create</td>          <td> </td></tr>
    <tr><td>ITF_CREATE2</td>         <td>itf_create2</td>         <td> </td></tr>
    <tr><td>ITF_DETR</td>           <td>します</td>           <td>itfDestr</td></tr>
    <tr><td>ITF_EQ</td>              <td>itf_eq</td>              <td>==</td></tr>
    <tr><td>ITF_HASHCODE</td>        <td>itf_hashcode</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>ITF_NE</td>              <td>itf_ne</td>              <td>=</td></tr>
    <tr><td>ITF_SELECT</td>          <td>itf_select</td>          <td> </td></tr>
    <tr><td>ITF_TO_INTERFACE</td>    <td>itf_to_interface</td>    <td> </td></tr>
</table><p></p>
          <a name="actions_console_keyboard">
        <h3>15.19テキスト(コンソール)画面のキーボードをサポートするためのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>kbdlib.c関数</th>   <th>kbd_rtl.c/kbd_inf.c関数</th></tr>
    <tr><td>KBD_GETC</td>            <td>kbd_getc</td>            <td>kbdGetc</td></tr>
    <tr><td>KBD_GETS</td>            <td>kbd_gets</td>            <td>kbdGets</td></tr>
    <tr><td>KBD_INPUT_READY</td>     <td>kbd_input_ready</td>     <td>kbdInputReady</td></tr>
    <tr><td>KBD_LINE_READ</td>       <td>kbd_line_read</td>       <td>kbdLineRead</td></tr>
    <tr><td>KBD_RAW_GETC</td>        <td>kbd_raw_getc</td>        <td>kbdRawGetc</td></tr>
    <tr><td>KBD_WORD_READ</td>       <td>kbd_word_read</td>       <td>kbdWordRead</td></tr>
</table><p></p>
          <a name="actions_list">
        <h3>15.20リストタイプのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>lstlib.c関数</th></tr>
    <tr><td>ベースライン</td>             <td>最初の猫</td></tr>
    <tr><td>最初のCPY</td>             <td>最初のパスワード</td></tr>
    <tr><td>LST_CREATE</td>          <td>最初の作成</td></tr>
    <tr><td>LST_DETR</td>           <td>最初のデストル</td></tr>
    <tr><td>最初の空</td>           <td>最初の空</td></tr>
    <tr><td>最初の除外</td>            <td>最初_除く</td></tr>
    <tr><td>先頭</td>            <td>頭</td></tr>
    <tr><td>LST_IDX</td>             <td>最初</td></tr>
    <tr><td>最初の_含む</td>            <td>含む</td></tr>
    <tr><td>最初のLNG</td>             <td>はじめに</td></tr>
    <tr><td>最初の範囲</td>           <td>第1範囲</td></tr>
    <tr><td>末尾</td>            <td>尾</td></tr>
</table><p></p>
          <a name="actions_process">
        <h3>15.21型プロセスのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>pcslib.c関数</th>   <th>pcs_rtl.c関数</th></tr>
    <tr><td>PCS_CHILD_STDERR</td>    <td>pcs_child_stderr</td>    <td>pcsChildStdErr</td></tr>
    <tr><td>PCS_CHILD_STDIN</td>     <td>pcs_child_stdin</td>     <td>pcsChildStdIn</td></tr>
    <tr><td>PCS_CHILD_STDOUT</td>    <td>pcs_child_stdout</td>    <td>pcsChildStdOut</td></tr>
    <tr><td>PCS_CMP</td>             <td>pcs_cmp</td>             <td>pcsCmp</td></tr>
    <tr><td>PCS_CPY</td>             <td>pcs_cpy</td>             <td>pcsCpy</td></tr>
    <tr><td>PCS_CREATE</td>          <td>pcs_create</td>          <td>pcs作成</td></tr>
    <tr><td>PCS_DETR</td>           <td>pcs_detr</td>           <td>pcsDestr</td></tr>
    <tr><td>PCS_EMPTY</td>           <td>pcs_empty</td>           <td> </td></tr>
    <tr><td>PCS_EQ</td>              <td>pcs_eq</td>              <td>pcsEq</td></tr>
    <tr><td>PCS_EXIT_VALUE</td>      <td>pcs_exit_value</td>      <td>pcs出力値</td></tr>
    <tr><td>PCS_HASHCODE</td>        <td>pcs_hashcode</td>        <td>pcsハッシュコード</td></tr>
    <tr><td>PCS_IS_ALIVE</td>        <td>プレイヤー達は生きている</td>        <td>pcsIsAlive</td></tr>
    <tr><td>PCS_KILL</td>            <td>pcs_kill</td>            <td>pCKill</td></tr>
    <tr><td>PCS_NE</td>              <td>pcs_ne</td>              <td>pcsEq</td></tr>
    <tr><td>PCS_PIPE2</td>           <td>pcs_pipe2</td>           <td>pcsパイプ2</td></tr>
    <tr><td>PCS_PTY</td>             <td>pcs_pty</td>             <td>pcs</td></tr>
    <tr><td>PCS_START</td>           <td>pcs_start</td>           <td>pcs開始</td></tr>
    <tr><td>PCS_START_PIPE</td>      <td>pcs_start_pipe</td>      <td>pcs開始パイプ</td></tr>
    <tr><td>PCS_STR</td>             <td>pcs_str</td>             <td>pcsStr</td></tr>
    <tr><td>PCS_VALUE</td>           <td>pcs_value</td>           <td>pcs値</td></tr>
    <tr><td>PCS_WAIT_FOR</td>        <td>pcs_wait_for</td>        <td>pcs待機</td></tr>
</table><p></p>
          <a name="actions_pointList">
        <h3>15.22 pointList型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>drwlib.c関数</th>   <th>bst_rtl.c関数</th></tr>
    <tr><td>PLT_BSTRING</td>         <td>plt_bstring</td>         <td>(noop)</td></tr>
    <tr><td>PLT_CMP</td>             <td>plt_cmp</td>             <td>bstCmp</td></tr>
    <tr><td>PLT_CPY</td>             <td>plt_cpy</td>             <td>bstCpy</td></tr>
    <tr><td>PLT_CREATE</td>          <td>plt_create</td>          <td>bstCreate</td></tr>
    <tr><td>PLT_DESTR</td>           <td>plt_detr</td>           <td>bstDestr</td></tr>
    <tr><td>PLT_EMPTY</td>           <td>plt_empty</td>           <td> </td></tr>
    <tr><td>PLT_EQ</td>              <td>plt_eq</td>              <td>a->size==b->size&amp;&amp;memcmp(a,b,a->size*sizeof(unsigned char))==0</td></tr>
    <tr><td>PLT_HASHCODE</td>        <td>plt_hashcode</td>        <td>bstHashCode</td></tr>
    <tr><td>PLT_NE</td>              <td>plt_ne</td>              <td>a->size!=b->size memcmp(a,b,a->size*sizeof(unsigned char))!=0</td></tr>
    <tr><td>PLT_POINT_LIST</td>      <td>plt_point_list</td>      <td>(noop)</td></tr>
    <tr><td>PLT_VALUE</td>           <td>plt_value</td>           <td>pltValue</td></tr>
</table><p></p>
          <a name="actions_pollData">
        <h3>15.23 pollDataタイプに対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>pollib.c関数</th>   <th>pol_unx.c/pol_sel.c関数</th></tr>
    <tr><td>POL_ADD_CHECK</td>       <td>pol_add_check</td>       <td>polAddCheck</td></tr>
    <tr><td>POL_CLEAR</td>           <td>pol_clear</td>           <td>polClear</td></tr>
    <tr><td>POL_CPY</td>             <td>pol_cpy</td>             <td>polCpy</td></tr>
    <tr><td>POL_CREATE</td>          <td>pol_create</td>          <td>polCreate</td></tr>
    <tr><td>POL_DETR</td>           <td>pol_detr</td>           <td>最も古い</td></tr>
    <tr><td>POL_EMPTY</td>           <td>pol_empty</td>           <td>polEmpty</td></tr>
    <tr><td>POL_GET_CHECK</td>       <td>pol_get_check</td>       <td>polGetCheck</td></tr>
    <tr><td>POL_GET_FINDING</td>     <td>pol_get_finding</td>     <td>polGetFinding</td></tr>
    <tr><td>POL_HAS_NEXT</td>        <td>pol_has_next</td>        <td>polHasNext</td></tr>
    <tr><td>POL_ITER_CHECKS</td>     <td>pol_iter_checks</td>     <td>ポリテリチェック</td></tr>
    <tr><td>POL_ITER_FINDINGS</td>   <td>pol_iter_findings</td>   <td>調査結果</td></tr>
    <tr><td>POL_NEXT_FILE</td>       <td>pol_next_file</td>       <td>polNextFile</td></tr>
    <tr><td>POL_POLL</td>            <td>pol_poll</td>            <td>polPoll</td></tr>
    <tr><td>POL_REMOVE_CHECK</td>    <td>pol_remove_check</td>    <td>polRemoveCheck</td></tr>
    <tr><td>POL_VALUE</td>           <td>pol_value</td>           <td>polValue</td></tr>
</table><p></p>
          <a name="actions_proc">
        <h3>15.24 proc操作とステートメントのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>prclib.c関数prclib.cかん</th>   <th> </th></tr>
    <tr><td>PRC_ARGS</td>            <td>prc_args</td>            <td>arg_v</td></tr>
    <tr><td>
          <a name="actions_PRC_BEGIN"      >PRC_BEGIN</a>
        </td>           <td>pr_begin</td>           <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_BEGIN_NOOP" >PRC_BEGIN_NOOP</a>
        </td>      <td>prc_begin_noop</td>      <td>コンパイル時に実行</td></tr>
    <tr><td>PRC_BLOCK</td>           <td>prc_block</td>           <td> </td></tr>
    <tr><td>PRC_BLOCK_CATCH_ALL</td> <td>prc_block_catch_all</td> <td> </td></tr>
    <tr><td>PRC_BLOCK_OTHERWISE</td> <td>prc_block_otherwise</td> <td> </td></tr>
    <tr><td>ケース</td>            <td>ケース</td>            <td>スイッチ</td></tr>
    <tr><td>PRC_CASE_DEF</td>        <td>prc_case_def</td>        <td>スイッチ</td></tr>
    <tr><td>PRC_CASE_HASHSET</td>    <td>prc_case_hashset</td>    <td>switch(hshIdxDefault0(.)</td></tr>
    <tr><td>PRC_CASE_HASHSET_DEF</td> <td>prc_case_hashset_def</td> <td>switch(hshIdxDefault0(.)</td></tr>
    <tr><td>PRC_CPY</td>             <td>prc_cpy</td>             <td> </td></tr>
    <tr><td>作成</td>          <td>prc_create</td>          <td> </td></tr>
    <tr><td>PRC_DECLS</td>           <td>prc_decls</td>           <td> </td></tr>
    <tr><td>PRC_DESTR</td>           <td>prc_detr</td>           <td> </td></tr>
    <tr><td>動的</td>         <td>prc_dynamic</td>         <td> </td></tr>
    <tr><td>PRC_EXIT</td>            <td>prc_exit</td>            <td>出口</td></tr>
    <tr><td>印刷する</td>      <td>prc_for_downto</td>      <td>の</td></tr>
    <tr><td>PRC_FOR_DOWNTO_STEP</td> <td>prc_for_downto_step</td> <td>の</td></tr>
    <tr><td>コピー</td>          <td>prc_for_to</td>          <td>の</td></tr>
    <tr><td>PRC_FOR_TO_STEP</td>     <td>prc_for_to_step</td>     <td>の</td></tr>
    <tr><td>PRC_HEAPSTAT</td>        <td>prc_heapstat</td>        <td> </td></tr>
    <tr><td>PRC_HSIZE</td>           <td>prc_hsize</td>           <td>ヒープサイズ</td></tr>
    <tr><td>PRC_IF</td>              <td>prc_if</td>              <td>if</td></tr>
    <tr><td>PRC_IF_ELSIF</td>        <td>prc_if_elsif</td>        <td>if</td></tr>
    <tr><td>PRC_IF_NOOP</td>         <td>prc_if_noop</td>         <td>if</td></tr>
    <tr><td>
          <a name="actions_PRC_INCLUDE"    >PRC_INCLUDE</a>
        </td>         <td>prc_include</td>         <td>コンパイル時に実行</td></tr>
    <tr><td>製品ライン</td>            <td>製品</td>            <td> </td></tr>
    <tr><td>
          <a name="actions_PRC_LOCAL"      >ローカル</a>
        </td>           <td>prc_local</td>           <td>コンパイル時に実行</td></tr>
    <tr><td>PRC_NOOP</td>            <td>prc_noop</td>            <td>prcNoop</td></tr>
    <tr><td>PRC_RAISE</td>           <td>prc_raise</td>           <td>raise_error</td></tr>
    <tr><td>
          <a name="actions_PRC_REPEAT"     >PRC_REPEAT</a>
        </td>          <td>prc_repeat</td>          <td>do{stmts}while(!(cond));</td></tr>
    <tr><td>
          <a name="actions_PRC_REPEAT_NOOP">PRC_REPEAT_NOOP</a>
        </td>     <td>prc_repeat_noop</td>     <td>do{}while(!(cond));</td></tr>
    <tr><td>
          <a name="actions_PRC_RES_BEGIN"  >PRC_RES_BEGIN</a>
        </td>       <td>pr_res_begin</td>       <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_RES_LOCAL"  >PRC_RES_LOCAL</a>
        </td>       <td>prc_res_local</td>       <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_RETURN"     >返品</a>
        </td>          <td>prc_return</td>          <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_RETURN2"    >PRC_RETURN2</a>
        </td>         <td>prc_return2</td>         <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_RETURN_VAR" >PRC_RETURN_VAR</a>
        </td>      <td>prc_return_var</td>      <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_RETURN_VAR2">PRC_RETURN_VAR2</a>
        </td>     <td>prc_return_var2</td>     <td>コンパイル時に実行</td></tr>
    <tr><td>
          <a name="actions_PRC_SEMICOLON"  >PRC_SEMICOLON</a>
        </td>       <td>prc_セミコロン</td>       <td>statement1;statement2;</td></tr>
    <tr><td>PRC_SETTRACE</td>        <td>pr_settrace</td>        <td> </td></tr>
    <tr><td>追跡</td>           <td>prc_trace</td>           <td> </td></tr>
    <tr><td>
          <a name="actions_PRC_WHILE"      >PRC_WHILE</a>
        </td>           <td>prc_while</td>           <td>while(cond){stmts}</td></tr>
    <tr><td>
          <a name="actions_PRC_WHILE_NOOP" >PRC_WHILE_NOOP</a>
        </td>      <td>prc_while_noop</td>      <td>while(cond){}</td></tr>
</table><p></p>
          <a name="actions_program">
        <h3>15.25型プログラムのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>prglib.c関数prglib.cかんすう</th>   <th>prg_comp.c関数prg_comp.cかんすう</th></tr>
    <tr><td>PRG_BUSRI_PARSE</td>     <td>prg_bstri_parse</td>     <td>prgBStriParse</td></tr>
    <tr><td>PRG_CMP</td>             <td>prg_cmp</td>             <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>PRG_CPY</td>             <td>prg_cpy</td>             <td>prGcP</td></tr>
    <tr><td>PRG_CREATE</td>          <td>prg_create</td>          <td> </td></tr>
    <tr><td>PRG_DESTR</td>           <td>prg_detr</td>           <td> </td></tr>
    <tr><td>PRG_EMPTY</td>           <td>prg_empty</td>           <td> </td></tr>
    <tr><td>PRG_EQ</td>              <td>prg_eq</td>              <td>==</td></tr>
    <tr><td>PRG_ERROR_COUNT</td>     <td>prg_error_count</td>     <td>prgErrorCount</td></tr>
    <tr><td>PRG_EVAL</td>            <td>prg_eval</td>            <td>prgEval</td></tr>
    <tr><td>PRG_EVAL_WITH_ARGS</td>  <td>prg_eval_with_args</td>  <td>prgEvalWithArgs</td></tr>
    <tr><td>PRG_EXEC</td>            <td>prg_exec</td>            <td>prgExec</td></tr>
    <tr><td>PRG_FIL_PARSE</td>       <td>prg_fil_parse</td>       <td>prgFilParse</td></tr>
    <tr><td>PRG_GET_ERROR</td>       <td>prg_get_error</td>       <td>prgGetError</td></tr>
    <tr><td>PRG_GLOBAL_OBJECTS</td>  <td>prg_global_objects</td>  <td>prgGlobalObjects</td></tr>
    <tr><td>PRG_HASHCODE</td>        <td>prg_hashcode</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>PRG_MATCH</td>           <td>prg_match</td>           <td>prgMatch</td></tr>
    <tr><td>PRG_MATCH_EXPR</td>      <td>prg_match_expr</td>      <td>prgMatchExpr</td></tr>
    <tr><td>PRG_NAME</td>            <td>プログラム名</td>            <td>arg_0</td></tr>
    <tr><td>PRG_NE</td>              <td>prg_ne</td>              <td>=</td></tr>
    <tr><td>PRG_OWN_NAME</td>        <td>prg_own_name</td>        <td>プログラム名</td></tr>
    <tr><td>PRG_OWN_PATH</td>        <td>prg_own_path</td>        <td>programPath</td></tr>
    <tr><td>PRG_PATH</td>            <td>prg_path</td>            <td>programPath</td></tr>
    <tr><td>PRG_STRUCT_SYMBOLS</td>  <td>prg_struct_symbols</td>  <td>prgStructSymbols</td></tr>
    <tr><td>PRG_STR_PARSE</td>       <td>prg_str_parse</td>       <td>prgStrParse</td></tr>
    <tr><td>PRG_SYOBJECT</td>        <td>prg_syobject</td>        <td>prgSyobject</td></tr>
    <tr><td>PRG_SYSVAR</td>          <td>prg_sysvar</td>          <td>prgSysvar</td></tr>
    <tr><td>PRG_VALUE</td>           <td>prg_value</td>           <td>prgValue</td></tr>
</table><p></p>
          <a name="actions_reference">
        <h3>15.26タイプ参照のアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>reflib.c関数</th>   <th>ref_data.c関数</th></tr>
    <tr><td>REF_ADDR</td>            <td>参照アドレス</td>            <td>&amp;</td></tr>
    <tr><td>REF_ALLOC</td>           <td>参照指定</td>           <td>refAlloc</td></tr>
    <tr><td>REF_ALLOC_INT</td>       <td>ref_alloc_int</td>       <td>refAllocInt</td></tr>
    <tr><td>REF_ALLOC_STRI</td>      <td>参照割り当て</td>      <td>refAllocStri</td></tr>
    <tr><td>REF_ALLOC_VAR</td>       <td>参照割り当て変数</td>       <td>refAllocVar</td></tr>
    <tr><td>REF_APPEND_PARAMS</td>   <td>ref_append_params</td>   <td>refAppendParams</td></tr>
    <tr><td>REF_ARRMAXIDX</td>       <td>ref_arrmaxidx</td>       <td>refArrmaxidx</td></tr>
    <tr><td>REF_ARRRMINIDX</td>       <td>ref_arrrminidx</td>       <td>refArrminidx</td></tr>
    <tr><td>REF_ARRTOLIST</td>       <td>ref_arrtolist</td>       <td>refArrtolist</td></tr>
    <tr><td>REF_BODY</td>            <td>本文</td>            <td>refBody</td></tr>
    <tr><td>REF_CAST</td>            <td>参照キャスト</td>            <td> </td></tr>
    <tr><td>REF_CATEGORY</td>        <td>参照カテゴリ</td>        <td>refCategory</td></tr>
    <tr><td>REF_CAT_PARSE</td>       <td>参照解析</td>       <td>refCatParse</td></tr>
    <tr><td>REF_CAT_STR</td>         <td>参照文字</td>         <td>refCatStr</td></tr>
    <tr><td>REF_CMP</td>             <td>参照_cmp</td>             <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>REF_CONTENT</td>         <td>参照内容</td>         <td> </td></tr>
    <tr><td>REF_CPY</td>             <td>参照_cpy</td>             <td>=</td></tr>
    <tr><td>REF_CREATE</td>          <td>参照作成</td>          <td>=またはptrCreateGeneric</td></tr>
    <tr><td>REF_DEREF</td>           <td>参照</td>           <td> </td></tr>
    <tr><td>REF_EQ</td>              <td>参照_eq</td>              <td>==</td></tr>
    <tr><td>参照ファイル</td>            <td>参照ファイル</td>            <td>refFile</td></tr>
    <tr><td>REF_GETREF</td>          <td>ref_getref</td>          <td>refGetRef</td></tr>
    <tr><td>REF_HASHCODE</td>        <td>ref_hashcode</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>REF_HSHDATATOLIST</td>   <td>ref_hshdatatolist</td>   <td>refHshDataToList</td></tr>
    <tr><td>REF_HSHKEYSTOLIST</td>   <td>ref_hshkeystolist</td>   <td>refHshKeysToList</td></tr>
    <tr><td>REF_HSHLENGTH</td>       <td>ref_hshlength</td>       <td>refHshLength</td></tr>
    <tr><td>REF_ISSYMBOL</td>          <td>ref_issymbol</td>          <td> </td></tr>
    <tr><td>REF_ISTEMP</td>          <td>ref_istemp</td>          <td>refIsTemp</td></tr>
    <tr><td>REF_ISVAR</td>           <td>ref_isvar</td>           <td>refIsvar</td></tr>
    <tr><td>REF_ITFTOSCT</td>        <td>参照先</td>        <td>FiTftosct</td></tr>
    <tr><td>基準線</td>            <td>参照線</td>            <td>参照線</td></tr>
    <tr><td>REF_LOCAL_CONSTSS</td>    <td>ref_local_consts</td>    <td>refLocalConsts</td></tr>
    <tr><td>REF_LOCAL_VARS</td>      <td>ref_local_vars</td>      <td>refLocalVars</td></tr>
    <tr><td>REF_MKREF</td>           <td>参照_mkref</td>           <td> </td></tr>
    <tr><td>REF_NE</td>              <td>参照</td>              <td>=</td></tr>
    <tr><td>REF_NIL</td>             <td>参照_nil</td>             <td> </td></tr>
    <tr><td>参照番号</td>             <td>参照番号</td>             <td>参照番号</td></tr>
    <tr><td>REF_PARAMS</td>          <td>ref_params</td>          <td>refParams</td></tr>
    <tr><td>REF_PATH</td>            <td>参照パス</td>            <td>refPath</td></tr>
    <tr><td>REF_PROG</td>            <td>ref_prog</td>            <td> </td></tr>
    <tr><td>REF_RESINI</td>          <td>ref_resini</td>          <td>Re Refini</td></tr>
    <tr><td>REF_RESULT</td>          <td>参照結果</td>          <td>refResult</td></tr>
    <tr><td>REF_SCAN</td>            <td>参照スキャン</td>            <td> </td></tr>
    <tr><td>REF_SCTOLIST</td>       <td>参考文献</td>       <td>refSctolist</td></tr>
    <tr><td>REF_SELECT</td>          <td>参照選択</td>          <td>a→b</td></tr>
    <tr><td>REF_SETCATEGORY</td>     <td>ref_setcategory</td>     <td>refSetCategory</td></tr>
    <tr><td>REF_SETPARAMS</td>       <td>ref_setparams</td>       <td>refSetParams</td></tr>
    <tr><td>REF_SETTYPE</td>         <td>ref_settype</td>         <td>refSetType</td></tr>
    <tr><td>REF_SETVAR</td>          <td>ref_setvar</td>          <td>refSetVar</td></tr>
    <tr><td>REF_STR</td>             <td>参照str</td>             <td>refStr</td></tr>
    <tr><td>REF_SYMBOL</td>            <td>ref_symbol</td>            <td> </td></tr>
    <tr><td>REF_TRACE</td>           <td>参照トレース</td>           <td>printf</td></tr>
    <tr><td>REF_TYPE</td>            <td>参照タイプ</td>            <td>refType</td></tr>
    <tr><td>REF_VALUE</td>           <td>参照値</td>           <td>refValue</td></tr>
</table><p></p>
          <a name="actions_ref_list">
        <h3>15.27型のアクションref_list</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>rfllib.c関数</th>   <th>rfl_data.c関数</th></tr>
    <tr><td>RFL_APPEND</td>          <td>rfl_append</td>          <td>rflAppend</td></tr>
    <tr><td>RFL_CAT</td>             <td>猫</td>             <td>rfCat</td></tr>
    <tr><td>RFL_CPY</td>             <td>送信</td>             <td>rflCpy</td></tr>
    <tr><td>RFL_CREATE</td>          <td>rfl_create</td>          <td>rflCreate</td></tr>
    <tr><td>RFL_DESTR</td>           <td>rfl_detr</td>           <td>rflDestr</td></tr>
    <tr><td>RFL_ELEM</td>            <td>要素</td>            <td>レム</td></tr>
    <tr><td>RFL_ELEMCPY</td>         <td>電子メール</td>         <td>ラジオ</td></tr>
    <tr><td>RFL_EMPTY</td>           <td>空</td>           <td> </td></tr>
    <tr><td>RFL_EQ</td>              <td>翻訳不要</td>              <td>rflEq</td></tr>
    <tr><td>RFL_EXCL</td>            <td>無視</td>            <td> </td></tr>
    <tr><td>RFL_EXPR</td>            <td>rfl_expr</td>            <td> </td></tr>
    <tr><td>RFL_FOR</td>             <td>rfl_for</td>             <td>の</td></tr>
    <tr><td>RFL_FOR_UNTIL</td>       <td>それまで</td>       <td>の</td></tr>
    <tr><td>RFL_HEAD</td>            <td>風切羽</td>            <td>rflHead</td></tr>
    <tr><td>RFL_IDX</td>             <td>rfl_idx</td>             <td>rflIdx</td></tr>
    <tr><td>RFL_INCL</td>            <td>rfl_incl</td>            <td>英語</td></tr>
    <tr><td>RFL_IPOS</td>            <td>rfl_ipos</td>            <td>rflIpos</td></tr>
    <tr><td>RFL_LNG</td>             <td>見つからない</td>             <td>rfl</td></tr>
    <tr><td>RFL_MKLIST</td>          <td>rfl_mklist</td>          <td>rflMklist</td></tr>
    <tr><td>RFL_NE</td>              <td>無線</td>              <td>rflNe</td></tr>
    <tr><td>要素以外</td>        <td>要素以外</td>        <td> </td></tr>
    <tr><td>RFL_POS</td>             <td>rfl_pos</td>             <td>RFLp</td></tr>
    <tr><td>RFL_RANGE</td>           <td>rfl_range</td>           <td>URL範囲</td></tr>
    <tr><td>RFL_SET_VALUE</td>       <td>rfl_set_value</td>       <td>rflSetValue</td></tr>
    <tr><td>RFL_TAIL</td>            <td>尾</td>            <td>尾</td></tr>
    <tr><td>RFL_TRACE</td>           <td>rfl_trace</td>           <td> </td></tr>
    <tr><td>RFL_VALUE</td>           <td>rfl_value</td>           <td>rfl値</td></tr>
</table><p></p>
          <a name="actions_struct">
        <h3>15.28構造体型に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>tsclib.c関数</th>   <th> </th></tr>
    <tr><td>SCT_ALLOC</td>           <td>sct_alloc</td>           <td> </td></tr>
    <tr><td>SCT_CAT</td>             <td>猫</td>             <td> </td></tr>
    <tr><td>SCT_CONV</td>            <td>sct_conv</td>            <td> </td></tr>
    <tr><td>SCT_CPY</td>             <td>sct_cpy</td>             <td>cpy_.</td></tr>
    <tr><td>SCT_CREATE</td>          <td>sct_create</td>          <td>作成_.</td></tr>
    <tr><td>SCT_DETR</td>           <td>sct_detr</td>           <td>デストル_.</td></tr>
    <tr><td>SCT_EMPTY</td>           <td>sct_empty</td>           <td> </td></tr>
    <tr><td>SCT_INCL</td>            <td>含む</td>            <td> </td></tr>
    <tr><td>SCT_LNG</td>             <td>sct_lng</td>             <td> </td></tr>
    <tr><td>SCT_REFIDX</td>          <td>sct_refidx</td>          <td> </td></tr>
    <tr><td>SCT_SELECT</td>          <td>sct_select</td>          <td>a→b</td></tr>
</table><p></p>
          <a name="actions_structElement">
        <h3>15.29型のstructElementに対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>tsclib.c関数</th>   <th> </th></tr>
    <tr><td>SEL_CMP</td>             <td>sel_cmp</td>             <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>SEL_CONV1</td>           <td>sel_conv1</td>           <td> </td></tr>
    <tr><td>SEL_CPY</td>             <td>sel_cpy</td>             <td>=</td></tr>
    <tr><td>SEL_CREATE</td>          <td>sel_create</td>          <td>=</td></tr>
    <tr><td>SEL_EQ</td>              <td>sel_eq</td>              <td>==</td></tr>
    <tr><td>SEL_HASHCODE</td>        <td>sel_hashcode</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>SEL_NAME</td>            <td>セル名</td>            <td>refStr</td></tr>
    <tr><td>SEL_NE</td>              <td>セル</td>              <td>=</td></tr>
    <tr><td>SEL_SYMBOL</td>            <td>セル_シンボル</td>            <td>参照記号</td></tr>
    <tr><td>選択タイプ</td>            <td>セルのタイプ</td>            <td>refType</td></tr>
</table><p></p>
          <a name="actions_set">
        <h3>15.30設定した種別に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>setlib.c関数</th>   <th>set_rtl.c関数</th></tr>
    <tr><td>SET_ARRLIT</td>          <td>set_arrlit</td>          <td>setArrlit</td></tr>
    <tr><td>SET_BASELIT</td>         <td>set_baselit</td>         <td>setBaselit</td></tr>
    <tr><td>SET_CARD</td>            <td>セットカード</td>            <td>setCard</td></tr>
    <tr><td>SET_CMP</td>             <td>set_cmp</td>             <td>setCmp</td></tr>
    <tr><td>SET_CONV1</td>           <td>set_conv1</td>           <td>(noop)</td></tr>
    <tr><td>SET_CONV3</td>           <td>set_conv3</td>           <td>(noop)</td></tr>
    <tr><td>SET_CPY</td>             <td>set_cpy</td>             <td>setCpy</td></tr>
    <tr><td>SET_CREATE</td>          <td>set_create</td>          <td>setCreate</td></tr>
    <tr><td>SET_DESTR</td>           <td>set_detr</td>           <td>setDestr</td></tr>
    <tr><td>SET_DIFF</td>            <td>set_diff</td>            <td>setDiff</td></tr>
    <tr><td>SET_DIFF_ASSIGN</td>     <td>set_diff_assign</td>     <td>setDiffAssign</td></tr>
    <tr><td>要素設定</td>            <td>要素設定</td>            <td>要素設定</td></tr>
    <tr><td>SET_EMPTY</td>           <td>set_empty</td>           <td> </td></tr>
    <tr><td>SET_EQ</td>              <td>set_eq</td>              <td>setEq</td></tr>
    <tr><td>除外設定</td>            <td>除外を設定する</td>            <td>除外を設定</td></tr>
    <tr><td>SET_GE</td>              <td>set_ge</td>              <td>setIsSubset(b, a)</td></tr>
    <tr><td>SET_GT</td>              <td>set_gt</td>              <td>setIsProperSubset(b, a)</td></tr>
    <tr><td>SET_HASHCODE</td>        <td>set_hashcode</td>        <td>setHashCode</td></tr>
    <tr><td>SET_ICONV1</td>          <td>set_iconv1</td>          <td>setIConv</td></tr>
    <tr><td>SET_ICONV3</td>          <td>set_iconv3</td>          <td>setIConv</td></tr>
    <tr><td>SET_INCL</td>            <td>含む</td>            <td>setIncl</td></tr>
    <tr><td>SET_INTERSECT</td>       <td>交差を設定</td>       <td>setIntersect</td></tr>
    <tr><td>SET_INTERSECT_ASSIGN</td> <td>set_intersect_assign</td> <td>setIntersectAssign</td></tr>
    <tr><td>SET_LE</td>              <td>セット</td>              <td>サブセットを設定する</td></tr>
    <tr><td>SET_LT</td>              <td>set_lt</td>              <td>setIsProperSubset</td></tr>
    <tr><td>SET_MAX</td>             <td>最大設定</td>             <td>最大設定</td></tr>
    <tr><td>最小設定</td>             <td>最小設定(set_min)</td>             <td>setMin</td></tr>
    <tr><td>SET_NE</td>              <td>set_ne</td>              <td>設定</td></tr>
    <tr><td>SET_NEXT</td>            <td>次を設定</td>            <td>setNext</td></tr>
    <tr><td>要素以外設定</td>        <td>要素以外を設定</td>        <td>セット要素</td></tr>
    <tr><td>SET_RAND</td>            <td>set_rand</td>            <td>ランダム偏差の設定(setRand</td></tr>
    <tr><td>SET_RANGELIT</td>        <td>set_rangelit</td>        <td>setRangelit</td></tr>
    <tr><td>SET_SCONV1</td>          <td>set_sconv1</td>          <td>ETsConv</td></tr>
    <tr><td>SET_SCONV3</td>          <td>set_sconv3</td>          <td>ETsConv</td></tr>
    <tr><td>SET_SYMDIFF</td>         <td>set_symdiff</td>         <td>setSymdiff</td></tr>
    <tr><td>SET_UNION</td>           <td>和集合</td>           <td>和集合を設定する</td></tr>
    <tr><td>SET_UNION_ASSIGN</td>    <td>set_union_assign</td>    <td>setUnionAssign</td></tr>
    <tr><td>SET_VALUE</td>           <td>set_value</td>           <td>setValue</td></tr>
</table><p></p>
          <a name="actions_PRIMITIVE_SOCKET">
        <h3>15.31 PRIMITIVE_SOCKETタイプのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>strlib.c関数</th>   <th>str_rtl.c関数</th></tr>
    <tr><td>SOC_ACCEPT</td>          <td>soc_accept</td>          <td>socAccept</td></tr>
    <tr><td>SOC_ADDR_FAMILY</td>     <td>soc_addr_family</td>     <td>socAddrFamily</td></tr>
    <tr><td>SOC_ADDR_NUMERIC</td>    <td>soc_addr_numeric</td>    <td>socAddrNumeric</td></tr>
    <tr><td>SOC_ADDR_SERVICE</td>    <td>soc_addr_service</td>    <td>socAddrService</td></tr>
    <tr><td>SOC_BIND</td>            <td>soc_bind</td>            <td>sockBind</td></tr>
    <tr><td>SOC_CLOSE</td>           <td>soc_close</td>           <td>socClose</td></tr>
    <tr><td>SOC_CONNECT</td>         <td>soc_connect</td>         <td>socConnect</td></tr>
    <tr><td>SOC_CPY</td>             <td>soc_cpy</td>             <td>=</td></tr>
    <tr><td>SOC_CREATE</td>          <td>soc_create</td>          <td> </td></tr>
    <tr><td>SOC_EMPTY</td>           <td>soc_empty</td>           <td> </td></tr>
    <tr><td>SOC_EQ</td>              <td>soc_eq</td>              <td>==</td></tr>
    <tr><td>SOC_GETC</td>            <td>soc_getc</td>            <td>socGetc</td></tr>
    <tr><td>SOC_GETS</td>            <td>soc_gets</td>            <td>socGets</td></tr>
    <tr><td>SOC_GET_HOSTNAME</td>    <td>soc_get_hostname</td>    <td>socGetHostname</td></tr>
    <tr><td>SOC_GET_LOCAL_ADDR</td>  <td>soc_get_local_addr</td>  <td>socGetLocalAddr</td></tr>
    <tr><td>SOC_GET_PEER_ADDR</td>   <td>soc_get_peer_addr</td>   <td>socGetPeerAddr</td></tr>
    <tr><td>SOC_HAS_NEXT</td>        <td>soc_has_next</td>        <td>socHasNext</td></tr>
    <tr><td>SOC_INET_ADDR</td>       <td>soc_inet_addr</td>       <td>socInetAddr</td></tr>
    <tr><td>SOC_INET_LOCAL_ADDR</td> <td>soc_inet_local_addr</td> <td>socInetLocalAddr</td></tr>
    <tr><td>SOC_INET_SERV_ADDR</td>  <td>soc_inet_serv_addr</td>  <td>socInetServAddr</td></tr>
    <tr><td>SOC_INPUT_READY</td>     <td>soc_input_ready</td>     <td>socInputReady</td></tr>
    <tr><td>SOC_LINE_READ</td>       <td>soc_line_read</td>       <td>socLineRead</td></tr>
    <tr><td>SOC_LISTEN</td>          <td>soc_listen</td>          <td>socListen</td></tr>
    <tr><td>SOC_NE</td>              <td>関連項目</td>              <td>=</td></tr>
    <tr><td>SOC_ORD</td>             <td>soc_ord</td>             <td>(intType)</td></tr>
    <tr><td>SOC_RECV</td>            <td>soc_recv</td>            <td>socRecv</td></tr>
    <tr><td>SOC_RECVFROM</td>        <td>soc_recvfrom</td>        <td>socRecvfrom</td></tr>
    <tr><td>SOC_SEND</td>            <td>soc_send</td>            <td>socsSend</td></tr>
    <tr><td>SOC_SENDTO</td>          <td>soc_sendto</td>          <td>socSendto</td></tr>
    <tr><td>SOC_SET_OPT_BOOL</td>    <td>soc_set_opt_bool</td>    <td>socSetOptBool</td></tr>
    <tr><td>SOC_SOCKET</td>          <td>soc_socket</td>          <td>socSocket</td></tr>
    <tr><td>SOC_WORD_READ</td>       <td>soc_word_read</td>       <td>socWordRead</td></tr>
    <tr><td>SOC_WRITE</td>           <td>soc_write</td>           <td>socWrite</td></tr>
</table><p></p>
          <a name="actions_database">
        <h3>15.32タイプのデータベースとsqlStatementのアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>sqllib.c関数</th>   <th>sql_rtl.c関数</th></tr>
    <tr><td>SQL_BIND_BIGINT</td>     <td>sql_bind_bigint</td>     <td>sqlBindBigInt</td></tr>
    <tr><td>SQL_BIND_BIGRAT</td>     <td>sql_bind_bigrat</td>     <td>sqlBindBigRat</td></tr>
    <tr><td>SQL_BIND_BOOL</td>       <td>sql_bind_bool</td>       <td>sqlBindBool</td></tr>
    <tr><td>SQL_BIND_BUSRI</td>      <td>sql_bind_bstri</td>      <td>sqlBindBStri</td></tr>
    <tr><td>SQL_BIND_DURATION</td>   <td>sql_bind_duration</td>   <td>sqlBindDuration</td></tr>
    <tr><td>SQL_BIND_FLOAT</td>      <td>sql_bind_float</td>      <td>sqlBindFloat</td></tr>
    <tr><td>SQL_BIND_INT</td>        <td>sql_bind_int</td>        <td>sqlBindInt</td></tr>
    <tr><td>SQL_BIND_NULL</td>       <td>sql_bind_null</td>       <td>sqlBindNull</td></tr>
    <tr><td>SQL_BIND_STRI</td>       <td>sql_bind_stri</td>       <td>sqlBindStri</td></tr>
    <tr><td>SQL_BIND_TIME</td>       <td>sql_bind_time</td>       <td>sqlBindTime</td></tr>
    <tr><td>SQL_CLOSE</td>           <td>sql_close</td>           <td>sqlClose</td></tr>
    <tr><td>SQL_CMP_DB</td>          <td>sql_cmp_db</td>          <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>SQL_CMP_STMT</td>        <td>sql_cmp_stmt</td>        <td>ptrCmp/ptrCmpGeneric</td></tr>
    <tr><td>SQL_COLUMN_BIGINT</td>   <td>sql_column_bigint</td>   <td>sqlColumnBigInt</td></tr>
    <tr><td>SQL_COLUMN_BIGRAT</td>   <td>sql_column_bigrat</td>   <td>sqlColumnBigRat</td></tr>
    <tr><td>SQL_COLUMN_BOOL</td>     <td>sql_column_bool</td>     <td>sqlColumnBool</td></tr>
    <tr><td>SQL_COLUMN_BUSRI</td>    <td>sql_column_bstri</td>    <td>sqlColumnBStri</td></tr>
    <tr><td>SQL_COLUMN_DURATION</td> <td>sql_column_duration</td> <td>sqlColumnDuration</td></tr>
    <tr><td>SQL_COLUMN_FLOAT</td>    <td>sql_column_float</td>    <td>sqlColumnFloat</td></tr>
    <tr><td>SQL_COLUMN_INT</td>      <td>sql_column_int</td>      <td>sqlColumnInt</td></tr>
    <tr><td>SQL_COLUMN_STRI</td>     <td>sql_column_stri</td>     <td>sqlColumnStri</td></tr>
    <tr><td>SQL_COLUMN_TIME</td>     <td>sql_column_time</td>     <td>sqlColumnTime</td></tr>
    <tr><td>SQL_COMMIT</td>          <td>sql_commit</td>          <td>sqlCommit</td></tr>
    <tr><td>SQL_CPY_DB</td>          <td>sql_cpy_db</td>          <td>sqlCpyDb</td></tr>
    <tr><td>SQL_CPY_STMT</td>        <td>sql_cpy_stmt</td>        <td>sqlCpyTmt</td></tr>
    <tr><td>SQL_CREATE_DB</td>       <td>sql_create_db</td>       <td>sqlCreateDb</td></tr>
    <tr><td>SQL_CREATE_STMT</td>     <td>sql_create_stmt</td>     <td>sqlCreateStmt</td></tr>
    <tr><td>SQL_DESTR_DB</td>        <td>sql_detr_db</td>        <td>sqlDestrDb</td></tr>
    <tr><td>SQL_DETR_STMT</td>      <td>sql_detr_stmt</td>      <td>sqlDestrStmt</td></tr>
    <tr><td>SQL_DRIVER</td>          <td>sql_driver</td>          <td>sqlDriver</td></tr>
    <tr><td>SQL_EMPTY_DB</td>        <td>sql_empty_db</td>        <td> </td></tr>
    <tr><td>SQL_EMPTY_STMT</td>      <td>sql_empty_stmt</td>      <td> </td></tr>
    <tr><td>SQL_EQ_DB</td>           <td>sql_eq_db</td>           <td>==</td></tr>
    <tr><td>SQL_EQ_STMT</td>         <td>sql_eq_stmt</td>         <td>==</td></tr>
    <tr><td>SQL_ERR_CODE</td>        <td>sql_err_code</td>        <td>sqlErrCode</td></tr>
    <tr><td>SQL_ERR_DB_FUNC</td>     <td>sql_err_db_func</td>     <td>sqlErrDbFunc</td></tr>
    <tr><td>SQL_ERR_LIB_FUNC</td>    <td>sql_err_lib_func</td>    <td>sqlErrLibFunc</td></tr>
    <tr><td>SQL_ERR_MESSAGE</td>     <td>sql_err_message</td>     <td>sqlErrMessage</td></tr>
    <tr><td>SQL_EXECUTE</td>         <td>sql_execute</td>         <td>sqlExecute</td></tr>
    <tr><td>SQL_FETCH</td>           <td>sql_fetch</td>           <td>sqlFetch</td></tr>
    <tr><td>SQL_GET_AUTO_COMMIT</td> <td>sql_get_auto_commit</td> <td>sqlGetAutoCommit</td></tr>
    <tr><td>SQL_IS_NULL</td>         <td>sql_is_null</td>         <td>sqlIsNull</td></tr>
    <tr><td>SQL_NE_DB</td>           <td>sql_ne_db</td>           <td>=</td></tr>
    <tr><td>SQL_NE_STMT</td>         <td>sql_ne_stmt</td>         <td>=</td></tr>
    <tr><td>SQL_OPEN_DB2</td>        <td>sql_open_db2</td>        <td>sqlOpenDb2</td></tr>
    <tr><td>SQL_OPEN_FIRE</td>       <td>sql_open_fire</td>       <td>sqlOpenFire</td></tr>
    <tr><td>SQL_OPEN_INFORMIX</td>   <td>sql_open_informix</td>   <td>sqlOpenInformix</td></tr>
    <tr><td>SQL_OPEN_LITE</td>       <td>sql_open_lite</td>       <td>sqlOpenLite</td></tr>
    <tr><td>SQL_OPEN_MY</td>         <td>sql_open_my</td>         <td>sqlOpenMy</td></tr>
    <tr><td>SQL_OPEN_OCI</td>        <td>sql_open_oci</td>        <td>sqlOpenOci</td></tr>
    <tr><td>SQL_OPEN_ODBC</td>       <td>sql_open_odbc</td>       <td>sqlOpenOdbc</td></tr>
    <tr><td>SQL_OPEN_POST</td>       <td>sql_open_post</td>       <td>sqlOpenPost</td></tr>
    <tr><td>SQL_OPEN_SQLSRV</td>     <td>sql_open_sqlsrv</td>     <td>sqlOpenSqlServer</td></tr>
    <tr><td>SQL_OPEN_TDS</td>        <td>sql_open_tds</td>        <td>sqlOpenTds</td></tr>
    <tr><td>SQL_PREPARE</td>         <td>sql_prepare</td>         <td>sqlPrepare</td></tr>
    <tr><td>SQL_ROLLBACK</td>        <td>sql_rollback</td>        <td>sqlRollback</td></tr>
    <tr><td>SQL_SET_AUTO_COMMIT</td> <td>sql_set_auto_commit</td> <td>sqlSetAutoCommit</td></tr>
    <tr><td>SQL_STMT_COLUMN_COUNT</td> <td>sql_stmt_column_count</td> <td>sqlStmtColumnCount</td></tr>
    <tr><td>SQL_STMT_COLUMN_NAME</td>  <td>sql_stmt_column_name</td>  <td>sqlStmtColumnName</td></tr>
</table><p></p>
          <a name="actions_string">
        <h3>15.33 type文字列に対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>strlib.c関数</th>   <th>str_rtl.c関数</th></tr>
    <tr><td>STR_APPEND</td>          <td>str_append</td>          <td>strAppend</td></tr>
    <tr><td>STR_CAT</td>             <td>str_cat</td>             <td>strConcat、strConcatTemp</td></tr>
    <tr><td>STR_CHIPOS</td>          <td>str_chipos</td>          <td>strChIpos</td></tr>
    <tr><td>STR_CHPOS</td>           <td>str_chpos</td>           <td>strChPos</td></tr>
    <tr><td>STR_CHSPLIT</td>         <td>str_chsplit</td>         <td>strChSplit</td></tr>
    <tr><td>STR_CLIT</td>            <td>str_clit</td>            <td>strCLit</td></tr>
    <tr><td>STR_CMP</td>             <td>str_cmp</td>             <td>strCompare</td></tr>
    <tr><td>STR_CPY</td>             <td>str_cpy</td>             <td>strCopy</td></tr>
    <tr><td>STR_CREATE</td>          <td>str_create</td>          <td>strCreate</td></tr>
    <tr><td>STR_DESTR</td>           <td>str_destr</td>           <td>strDestr</td></tr>
    <tr><td>STR_ELEMCPY</td>         <td>str_elemcpy</td>         <td>a→mem[b-1]=c</td></tr>
    <tr><td>STR_EQ</td>              <td>str_eq</td>              <td>a->size==b->size&amp;&amp;memcmp(a,b,a->size*sizeof(strElemType))==0</td></tr>
    <tr><td>STR_FOR</td>             <td>str_for</td>             <td>の</td></tr>
    <tr><td>STR_FOR_KEY</td>         <td>str_for_key</td>         <td>の</td></tr>
    <tr><td>STR_FOR_VAR_KEY</td>     <td>str_for_var_key</td>     <td>の</td></tr>
    <tr><td>STR_FROM_UTF8</td>       <td>str_from_utf8</td>       <td>strFromUtf8</td></tr>
    <tr><td>STR_GE</td>              <td>str_ge</td>              <td>strGe</td></tr>
    <tr><td>STR_GT</td>              <td>str_gt</td>              <td>strGt</td></tr>
    <tr><td>STR_HASHCODE</td>        <td>str_hashcode</td>        <td>strHashCode</td></tr>
    <tr><td>STR_HEAD</td>            <td>str_head</td>            <td>strHead</td></tr>
    <tr><td>STR_IDX</td>             <td>str_idx</td>             <td>a→mem[b-1]</td></tr>
    <tr><td>STR_IPOS</td>            <td>str_ipos</td>            <td>strIpos</td></tr>
    <tr><td>STR_LE</td>              <td>str_le</td>              <td>strLe</td></tr>
    <tr><td>STR_LIT</td>             <td>str_lit</td>             <td>strLit</td></tr>
    <tr><td>STR_LNG</td>             <td>str_lng</td>             <td>a->size</td></tr>
    <tr><td>STR_LOW</td>             <td>低</td>             <td>strLow, strLowTemp</td></tr>
    <tr><td>STR_LPAD</td>            <td>str_lpad</td>            <td>strLpad</td></tr>
    <tr><td>STR_LPAD0</td>           <td>str_lpad0</td>           <td>strLpad0, strLpad0Temp</td></tr>
    <tr><td>STR_LT</td>              <td>str_lt</td>              <td>strLt</td></tr>
    <tr><td>STR_LTRIM</td>           <td>str_ltrim</td>           <td>strLtrim</td></tr>
    <tr><td>STR_MULT</td>            <td>str_mult</td>            <td>strMult</td></tr>
    <tr><td>STR_NE</td>              <td>str_ne</td>              <td>a->size!=b->size memcmp(a,b,a->size*sizeof(strElemType))!=0</td></tr>
    <tr><td>STR_POS</td>             <td>str_pos</td>             <td>strPos</td></tr>
    <tr><td>STR_POSCPY</td>          <td>str_poscpy</td>          <td>memcpy</td></tr>
    <tr><td>STR_PUSH</td>            <td>str_push</td>            <td>strPush</td></tr>
    <tr><td>追跡範囲</td>           <td>str_range</td>           <td>strRange</td></tr>
    <tr><td>STR_RCHIPOS</td>         <td>str_rchipos</td>         <td>strRChIpos</td></tr>
    <tr><td>STR_RCHPOS</td>          <td>str_rchpos</td>          <td>strRChPos</td></tr>
    <tr><td>STR_REPL</td>            <td>str_repl</td>            <td>strRepl</td></tr>
    <tr><td>STR_RIPOS</td>           <td>str_ripos</td>           <td>strRIPos</td></tr>
    <tr><td>STR_RPAD</td>            <td>str_rpad</td>            <td>strRpad</td></tr>
    <tr><td>STR_RPOS</td>            <td>str_rpos</td>            <td>strRpos</td></tr>
    <tr><td>STR_RTRIM</td>           <td>str_rtrim</td>           <td>strRtrim</td></tr>
    <tr><td>STR_SPLIT</td>           <td>str_split</td>           <td>strSplit</td></tr>
    <tr><td>STR_STR</td>             <td>str_str</td>             <td>(noop)</td></tr>
    <tr><td>STR_SUBSTR</td>          <td>str_substr</td>          <td>strSubstr</td></tr>
    <tr><td>STR_SUBSTR_FIXLEN</td>   <td>str_substr_fixlen</td>   <td>strSubstrationFixLen</td></tr>
    <tr><td>STR_TAIL</td>            <td>str_tail</td>            <td>strTail</td></tr>
    <tr><td>STR_TO_UTF8</td>         <td>str_to_utf8</td>         <td>strToUtf8</td></tr>
    <tr><td>STR_TRIM</td>            <td>str_trim</td>            <td>strTrim</td></tr>
    <tr><td>上</td>              <td>str_up</td>              <td>strUp, strUpTemp</td></tr>
    <tr><td>STR_VALUE</td>           <td>str_value</td>           <td>strValue</td></tr>
</table><p></p>
          <a name="actions_time">
        <h3>15.34機種時間に対する処置</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>timlib.c関数</th>   <th>tim_unx.c/tim_win.c関数</th></tr>
    <tr><td>TIM_AWAIT</td>           <td>tim_await</td>           <td>timAwait</td></tr>
    <tr><td>TIM_FROM_TIMESTAMP</td>  <td>tim_from_timestamp</td>  <td>timFromTimestamp</td></tr>
    <tr><td>今すぐ</td>             <td>今</td>             <td>timNow</td></tr>
    <tr><td>TIM_SET_LOCAL_TZ</td>    <td>tim_set_local_tz</td>    <td>timSetLocalTZ</td></tr>
</table><p></p>
          <a name="actions_type">
        <h3>15.35型式に対する処置</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>typlib.c関数</th>   <th>typ_data.c関数</th></tr>
    <tr><td>TYP_ADDINTERFACE</td>    <td>タイプ_追加インターフェース</td>    <td> </td></tr>
    <tr><td>TYP_CMP</td>             <td>タイプ_cmp</td>             <td>typCmp</td></tr>
    <tr><td>TYP_CPY</td>             <td>タイプ_cpy</td>             <td>typCpy</td></tr>
    <tr><td>タイプ作成</td>          <td>タイプ作成</td>          <td>typCreate</td></tr>
    <tr><td>種類表示</td>           <td>タイプ</td>           <td>typDestr</td></tr>
    <tr><td>TYP_EQ</td>              <td>タイプ_eq</td>              <td>==</td></tr>
    <tr><td>TYP_FUNC</td>            <td>タイプ機能</td>            <td>typFunc</td></tr>
    <tr><td>TYP_GENSUB</td>          <td>タイプ_gensub</td>          <td> </td></tr>
    <tr><td>TYP_GENTYPE</td>         <td>タイプ_gentype</td>         <td> </td></tr>
    <tr><td>TYP_HASHCODE</td>        <td>タイプ_ハッシュコード</td>        <td>(intType)(((memSizeType)a)>>6)</td></tr>
    <tr><td>TYP_ISDECLARED</td>      <td>タイプ_isdeclared</td>      <td> </td></tr>
    <tr><td>TYP_ISDERIVED</td>       <td>タイプ_is派生</td>       <td>typIsDerived</td></tr>
    <tr><td>TYP_ISFORWARD</td>       <td>タイプ_isforward</td>       <td> </td></tr>
    <tr><td>TYP_ISFUNC</td>          <td>タイプ_isfunc</td>          <td>typIsFunc</td></tr>
    <tr><td>TYP_ISVARFUNC</td>       <td>type_isvarfunc</td>       <td>typIsVarfunc</td></tr>
    <tr><td>TYP_MATCHOBJ</td>        <td>タイプマッチオブジェクト</td>        <td>typMatchobj</td></tr>
    <tr><td>TYP_META</td>            <td>タイプ_メタ</td>            <td>typMeta</td></tr>
    <tr><td>TYP_NE</td>              <td>タイプ</td>              <td>=</td></tr>
    <tr><td>タイプ番号</td>             <td>タイプ</td>             <td>typNum</td></tr>
    <tr><td>TYP_RESULT</td>          <td>タイプ結果</td>          <td>typResult</td></tr>
    <tr><td>TYP_SET_IN_PARAM_REF</td>   <td>type_set_in_param_ref</td>    <td> </td></tr>
    <tr><td>TYP_SET_IN_PARAM_VALUE</td> <td>type_set_in_param_value</td>  <td> </td></tr>
    <tr><td>タイプ</td>             <td>タイプ_str</td>             <td>typStr</td></tr>
    <tr><td>タイプ値</td>           <td>タイプ値</td>           <td>typValue</td></tr>
    <tr><td>TYP_VARCONV</td>         <td>タイプ_varconv</td>         <td> </td></tr>
    <tr><td>TYP_VARFUNC</td>         <td>タイプ変数</td>         <td>typVarfunc</td></tr>
</table><p></p>
          <a name="actions_utf8File">
        <h3>15.36 utf 8型ファイルに対するアクション</h3>
          </a>
        <p></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>アクション名</th>         <th>ut8lib.c関数</th>   <th>ut8_rtl.c関数</th></tr>
    <tr><td>UT8_GETC</td>            <td>ut8_getc</td>            <td>ut8Getc</td></tr>
    <tr><td>UT8_GETS</td>            <td>ut8_gets</td>            <td>ut8Gets</td></tr>
    <tr><td>UT8_LINE_READ</td>       <td>ut8_line_read</td>       <td>ut8LineRead</td></tr>
    <tr><td>UT8_SEEK</td>            <td>ut8_seek</td>            <td>ut8Seek</td></tr>
    <tr><td>UT8_WORD_READ</td>       <td>ut8_word_read</td>       <td>ut8WordRead</td></tr>
    <tr><td>UT8_WRITE</td>           <td>ut8_write</td>           <td>ut 8書き込み</td></tr>
</table><p></p>
          <a name="ffi_file_start"></a>
        <p></p>
          <a name="ffi_FOREIGN_FUNCTION_INTERFACE">
        <h2>16. 外部機能インターフェース</h2>
          </a>
        <p>外部関数を直接呼び出すことはできません。 ラッパー関数を記述する必要があります。 外部関数を呼び出すには、いくつかのことを行う必要があります。</p><ul>
    <li>その<a class="link" href="#ffi_C_types_used_by_the_implementation">Seed7が使用するC type</a>しなければならない<a class="link" href="#ffi_String_conversions">Cタイプに変換される</a>外部ファンクションによって使用される(例:<tt><a class="type" href="#types_string">文字列</a></tt>および<a class="link" href="#os_Standard_path_representation">経路</a>変換)。 値を返す外部関数とパラメータの結果は、変換して戻す必要があります。 この変換は通常、ラッパー関数で行われます。</li>
    <li>が付いた関数<a class="link" href="#actions_file_start">行動</a>prototype(<tt><a class="type" href="#ffi_listType">リストタイプ</a></tt>パラメータと<tt><a class="type" href="#ffi_objectType">objectType</a></tt>結果)を定義する必要があります。 定義済みマクロを使用すると、次のことが<a class="link" href="#ffi_Macros_to_access_the_action_parameters">アクション引数にアクセスする</a>および<a class="link" href="#ffi_Functions_to_create_action_results">結果値を作成する</a>・アクション関数をファイルに登録する必要があります<tt><span class="lib">&quot;primitiv.c&quot;</span></tt></li>
    <li>新しいアクションをSeed7に導入する必要があります。 これは通常<tt>*.s7i</tt>ライブラリーファイルを作成します。</li>
</ul><p>一般に、次の2つの関数が必要です。 ラッパー関数とアクション関数です。 対応する関数定義は、2つの<tt>*.c</tt>ファイル。 対応する<tt>*.h</tt>ファイルにはプロトタイプが含まれています。 ライブラリがあるとします。<tt><span class="lib">「superlib」</span></tt>そしてその機能は<tt><a class="func" href="#ffi_doWurx1">dWurx 1</a></tt>から<tt><span class="lib">「superlib」</span></tt>はSeed7プログラムから呼び出されるべきである。 3文字の略語<tt><b>上</b></tt>は、ラッパーとアクションのファイル名と関数名を決定するために使用されます。 以下のファイルと関数が使われています。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  <tr><th>ファイル</th><th>機能</th><th>コメント</th></tr>

  <tr><td>superlib.a</td><td>
          <tt>
            <a class="func" href="#ffi_doWurx1">dWurx 1</a>
          </tt>
        </td><td>外部ライブラリ(拡張が異なる場合があります)</td></tr>
  <tr><td>superlib.h</td><td>
          <tt>
            <a class="func" href="#ffi_doWurx1">dWurx 1</a>
          </tt>
        </td><td>外部C関数のプロトタイプ</td></tr>
  <tr><td>sup_rtl.c</td><td>
          <tt>
            <a class="func" href="#ffi_supDoWurx1">supDoWurx1</a>
          </tt>
        </td><td>ラッパー関数</td></tr>
  <tr><td>sup_rtl.h</td><td>
          <tt>
            <a class="func" href="#ffi_supDoWurx1">supDoWurx1</a>
          </tt>
        </td><td>ラッパー関数のプロトタイプ</td></tr>
  <tr><td>suplib.c</td><td>
          <tt>
            <a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a>
          </tt>
        </td><td>作用機能</td></tr>
  <tr><td>suplib.h</td><td>
          <tt>
            <a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a>
          </tt>
        </td><td>アクション機能のプロトタイプ</td></tr>
  <tr><td>primitiv.c</td><td> </td><td>全プリミティブアクションのアルファベット順リスト</td></tr>
  <tr><td>メイクファイル</td><td> </td><td>メイクファイル名はオペレーティングシステムおよびCコンパイラによって異なります</td></tr>
  <tr><td>superlib.s7i</td><td>
          <tt>dWurx 1</tt>
        </td><td>Seed7プログラムに外部関数を導入します。</td></tr>
</table></dd></dl><p>のCプロトタイプ<tt><a class="func" href="#ffi_doWurx1">dWurx 1</a></tt>がファイル<tt><span class="lib">&quot;superlib.h&quot;</span></tt>:</p><pre class="indent">*name);
<span class="type">int</span><a name="ffi_doWurx1">dWurx 1</a>(<span class="type">char</span></pre><p>この関数は、UTF-8形式の<tt>&#39;name&#39;</tt>成功した場合0を返す。 他のすべての戻り値は、文字列が長すぎることを示しています。 この場合、例外は<tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt>上げる必要があります。 ラッパー関数はファイル<tt><span class="lib">&quot;sup_rtl.c&quot;</span></tt>変更後:</p><pre class="indent">
#

#

#

#

#

#



名前)
{

cName;

;

wurxResult;

cName=
(name, &amp;err_info);

(cName==NULL){

(err_info);
}
{
wurxResult=
(cName);

(cName, name);

(wurxResult!=0){

);
}
}
}
<span class="keywd">含む</span><span class="lib">&quot;version.h&quot;</span>含む<span class="keywd"></span>&quot;staudio.h&quot;<span class="lib">含む</span><span class="keywd">&quot;superlib.h&quot;</span>含む<span class="lib"></span>&quot;common.h&quot;<span class="keywd">含む</span><span class="lib">&quot;stritutl.h&quot;</span>含む<span class="keywd"></span>&quot;rtl_err.h&quot;<span class="lib">無</span><span class="keywd">supDoWurx1</span>(<span class="lib">const</span><span class="type">striType</span>cstriType<a name="ffi_supDoWurx1">errInfoType</a>err_info=<span class="keywd">OK OK_NO_ERROR</span>int<a class="type" href="#ffi_striType">stri_to_cstri8</a>if<a class="type" href="#ffi_cstriType">raise_error</a>else<a class="type" href="#ffi_errInfoType">dWurx 1</a>free_cstri8<a class="exception" href="#ffi_errInfoType_OKAY_NO_ERROR">if</a>raise_error<span class="type">(</span>範囲エラー<a class="func" href="#ffi_stri_to_cstri8"></a><span class="keywd"></span><a class="func" href="#ffi_raise_error"></a><span class="keywd"></span><a class="func" href="#ffi_doWurx1"></a><a class="func" href="#ffi_free_cstri8"></a><span class="keywd"></span><a class="func" href="#ffi_raise_error"></a><a class="exception" href="#ffi_errInfoType_RANGE_ERROR"></a></pre><p>のプロトタイプ<tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt>がファイル<tt><span class="lib">&quot;sup_rtl.h&quot;</span></tt>変更後:</p><pre class="indent">名前);
<span class="type">無</span><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a>(<span class="keywd">const</span><a class="type" href="#ffi_striType">striType</a></pre><p>のアクション関数<tt><a class="func" href="#ffi_supDoWurx1">supDoWurx1</a></tt>がファイル<tt><span class="lib">&quot;suplib.c&quot;</span></tt>変更後:</p><pre class="indent">
#

#

#

#

#

#

#



引数)
{

(arguments));

(arguments)));

;
}
<span class="keywd">含む</span><span class="lib">&quot;version.h&quot;</span>含む<span class="keywd"></span>&quot;staudio.h&quot;<span class="lib">含む</span><span class="keywd">&quot;common.h&quot;</span>含む<span class="lib"></span>&quot;data.h&quot;<span class="keywd">含む</span><span class="lib">&quot;syvarutl.h&quot;</span>含む<span class="keywd"></span>&quot;objutl.h&quot;<span class="lib">含む</span><span class="keywd">&quot;sup_rtl.h&quot;</span>objectType<span class="lib"></span>sup_doWurx1<span class="keywd">(</span>リストタイプ<span class="lib">isit_stri</span>(<a class="type" href="#ffi_objectType">arg_1</a>supDoWurx1<a name="ffi_sup_doWurx1">(</a>take_stri<a class="type" href="#ffi_listType">(</a>arg_1<a class="func" href="#ffi_isit_stri">リターン</a><a class="func" href="#ffi_arg_1">SYS_EMPTY_OBJECT</a><a class="func" href="#ffi_supDoWurx1"></a><a class="func" href="#ffi_take_stri"></a><a class="func" href="#ffi_arg_1"></a><span class="keywd"></span><a class="func_no_ul" href="#ffi_SYS_EMPTY_OBJECT"></a></pre><p>のプロトタイプ<tt><a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a></tt>がファイル<tt><span class="lib">&quot;suplib.h&quot;</span></tt>変更後:</p><pre class="indent">arguments);
<a class="type" href="#ffi_objectType">objectType</a><a class="func" href="#ffi_sup_doWurx1">sup_doWurx1</a>(<a class="type" href="#ffi_listType">リストタイプ</a></pre><p>アクションは、ファイルを変更することによって、インタプリタに導入されます。<tt><span class="lib">&quot;primitiv.c&quot;</span></tt>includeディレクティブ<tt><span class="lib">&quot;suplib.h&quot;</span></tt>を追加しなければならない:</p><pre class="indent">
#



#

<span class="keywd">含む</span><span class="lib">&quot;strlib.h&quot;</span>#<b>含む<span class="keywd"></span>&quot;suplib.h&quot;<span class="lib">含む</span></b><span class="keywd">&quot;timlib.h&quot;</span><span class="lib"></span></pre><p>ファイル<tt><span class="lib">&quot;primitiv.c&quot;</span></tt>に、プリミティブアクションをアルファベット順にソートしたリストを示します。 各アクションエントリは1行です。 新しいアクションを加えることが重要だ。<tt><span class="stri">&quot;SUP_DO_WURX&quot;</span></tt>正しい場所で:</p><pre class="indent">
{
、}




{
、}
<span class="stri">&quot;STR_VALUE&quot;</span><span class="func">str_value</span>{<b>&quot;SUP_DO_WURX&quot;<span class="stri"></span>sup_doWurx1<a class="func" href="#ffi_sup_doWurx1">、}</a>&quot;TIM_AWAIT&quot;</b><span class="stri">tim_await</span><span class="func"></span></pre><p>新しいファイルをメイクファイルに追加しなければなりません。 Cコンパイラとオペレーティングシステムによっては、Seed7はいくつかのmakefilesを使用します。 正しい<tt>&quot;makefile&quot;</tt><tt>供給</tt>および<tt>sup_rtl</tt>をソース・ファイルとオブジェクト・ファイルのリストに追加する必要があります。 の追加<tt>供給</tt>オブジェクトファイルにより、次のようになります。</p><pre class="indent">
LOBJ=actlib.o arrlib.o biglib.o blnlib.o bstlib.o chrlib.o cmdlib.o conlib.o dcllib.o drwlib.o\
enulib.o fillib.o flt.o hshlib.o intlib.o itflib.o kbdlib.o lstlib.o pollib.o prclib.o\
prglib.o reflib.o rfllib.o sctlib.o setlib.o soclib.o strlib.o
timlib.o typlib.o ut8lib.o
<b>suplib.o</b></pre><p>の追加<tt>&quot;suplib&quot;</tt>ソースファイルは次のようになります。</p><pre class="indent">
LSRC=actlib.c arrlib.c biglib.c blnlib.c bstlib.c chrlib.c cmdlib.c conlib.c dcllib.c drwlib.c\
enulib.c fillib.c fltlib.c hshlib.c intlib.c itflib.c kbdlib.c lstlib.c pollib.c prclib.c\
prglib.c reflib.c rfllib.c sctlib.c setlib.c soclib.c strlib.c
timlib.c typlib.c ut8lib.c
<b>suplib.c</b></pre><p>オブジェクトファイル。 の追加<tt>sup_rtl</tt>オブジェクトファイルにより、次のようになります。</p><pre class="indent">
ROBJ=arr_rtl.o bln_rtl.o bst_rtl.o chr_rtl.o cmd_rtl.o con_rtl.o dir_rtl.o drw_rtl.o fil_rtl.o\
flt_rtl.o hsh_rtl.o int_rtl.o set_rtl.o soc_rtl.o str_rtl.o
tim_rtl.o ut8_rtl.o\
heaputl.o striutl.o
<b>sup_rtl.o</b></pre><p>の追加<tt>&quot;sup_rtl&quot;</tt>ソースファイルは次のようになります。</p><pre class="indent">
RSRC=arr_rtl.c bln_rtl.c bst_rtl.c chr_rtl.c cmd_rtl.c con_rtl.c dir_rtl.c drw_rtl.c fil_rtl.c\
flt_rtl.c hsh_rtl.c int_rtl.c set_rtl.c soc_rtl.c str_rtl.c
tim_rtl.c ut8_rtl.c\
heaputl.c striutl.c
<b>sup_rtl.c</b></pre><p>外部ライブラリ<tt>「superlib」</tt>それ自体は次のように追加されます。</p><pre class="indent">
SYSTEM_LIBS=-lm

<b>superlib.a</b></pre><p>変更を有効にするには、インタプリタをコンパイルする必要があります。 新しい関数を実際に呼び出すには、Seed7ライブラリに導入する必要があります。 これはライブラリで行われます。<tt><span class="lib">&quot;super.s7i&quot;</span></tt>:</p><pre class="indent">;
<span class="keywd">const</span><a class="type" href="#types_proc">proc</a>:dWurx 1(<span class="keywd">で</span><a class="type" href="#types_string">文字列</a>:名前)<span class="keywd">は</span><span class="keywd">行動</span><span class="stri">&quot;SUP_DO_WURX&quot;</span></pre><p></p>
          <a name="ffi_C_types_used_by_the_implementation">
        <h3>16.1実装で使用されるCタイプ</h3>
          </a>
        <p>いくつかのSeed7型は単純なC型に対応しており、それらは<tt><span class="lib">&quot;common.h&quot;</span></tt>:</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7型</th>       <th>C型</th>     <th>C定義</th>       <th>コメント</th></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_boolean">ブール</a>
          </tt>
        </td>          <td>
          <a name="ffi_boolType">boolType</a>
        </td>   <td><tt><span class="type">ブール</span></tt><tt><span class="type">ブール</span></tt>または<tt><span class="type">int</span></tt></td> <td>chkcomp.cによって決定されます。</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_integer">整数</a>
          </tt>
        </td>          <td>
          <a name="ffi_intType">intType</a>
        </td>    <td>
          <tt><a class="type" href="#ffi_int64Type">int 64型</tt>
        </td>          <td>64ビット符号付きint</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_float">浮かぶ</a>
          </tt>
        </td>            <td>
          <a name="ffi_floatType">floatType</a>
        </td>  <td>
          <tt>
            <span class="type">二倍の</span>
          </tt>
        </td>             <td>64ビット倍精度</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_char">char</a>
          </tt>
        </td>             <td>
          <a name="ffi_charType">charType</a>
        </td>   <td>
          <tt>
            <a class="type" href="#ffi_uint32Type">uint 32型</a>
          </tt>
        </td>         <td>32ビット符号なしint</td></tr>
    <tr><td>
          <tt>
            <span class="type">PR IMERIC_SOCKET</span>
          </tt>
        </td> <td>
          <a name="ffi_socketType">socketType</a>
        </td> <td>
          <tt>
            <span class="type">int</span>
          </tt>
        </td>                <td>キャスト元<tt><span class="type">os_socketType</span></tt></td></tr>
</table><p>他のSeed7タイプは構造体を指すCポインタに対応しています。 これらの構造体のいくつかは、あらゆる状況で使用されます。 インタプリタとコンパイラで、異なるオペレーティングシステムの下で、異なるランタイムライブラリを使用する。 この不変構造体は以下のように定義されている。<tt><span class="lib">&quot;common.h&quot;</span></tt>および<tt><span class="lib">&quot;data.h&quot;</span></tt>:</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7型</th>   <th>C型</th>      <th>C構造体</th>             <th>コメント</th></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_string">文字列</a>
          </tt>
        </td>       <td>
          <a name="ffi_striType">striType</a>
        </td>    <td>struct striStruct</td>    <td>UTF-32エンコード、ヌル文字を使用可能</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_set">設定する</a>
          </tt>
        </td>          <td>
          <a name="ffi_setType">setType</a>
        </td>     <td>struct setStruct</td>     <td> </td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_bstring">bstring</a>
          </tt>
        </td>      <td>
          <a name="ffi_bstriType">bstriType</a>
        </td>   <td>struct bstriStruct</td>   <td>バイト列、ヌルバイトを含むことが可能</td></tr>
    <tr><td>
          <tt>
            <span class="type">clib_file</span>
          </tt>
        </td>    <td>
          <a name="ffi_fileType">ファイルタイプ</a>
        </td>    <td>struct fileStruct</td>    <td>C<tt>ファイル*</tt>使用状況のカウントと権限を追加する</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_reference">参考</a>
          </tt>
        </td>    <td>
          <a name="ffi_objectType">objectType</a>
        </td>  <td>struct objectStruct</td>  <td>Seed7オブジェクトのインタプリタ型</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_ref_list">参照リスト</a>
          </tt>
        </td>     <td>
          <a name="ffi_listType">リストタイプ</a>
        </td>    <td>struct listStruct</td>    <td>Seed7オブジェクトリストのインタプリタ型</td></tr>
</table><p>他のSeed7タイプもstructポインタに対応しますが、その構造体はインタプリタ型とコンパイル型のSeed7プログラムで異なります。 インタプリタ型プログラムの構造体は以下で定義されている。<tt><span class="lib">&quot;data.h&quot;</span></tt>であり、コンパイルされたプログラムの構造体は<tt><span class="lib">&quot;data_rtl.h&quot;</span></tt>:</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7型</th>  <th>C言語(インタプリタ型)</th>  <th>C struct(インタプリタ型)</th>  <th>Cタイプ(コンパイル済み)</th>  <th>C struct(コンパイル済み)</th></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_array">配列</a>
          </tt>
        </td>       <td>
          <a name="ffi_arrayType">arrayType</a>
        </td>             <td>struct arrayStruct</td>      <td>rtlArrayType</td>       <td>struct rtlArrayStruct</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_hash">ハッシュ</a>
          </tt>
        </td>        <td>
          <a name="ffi_hashType">hashType</a>
        </td>              <td>struct hashStruct</td>       <td>rtlHashType</td>        <td>struct rtlHashStruct</td></tr>
    <tr><td>
          <tt>
            <a class="type" href="#types_struct">構造体</a>
          </tt>
        </td>      <td>
          <a name="ffi_structType">structType</a>
        </td>            <td>struct structStruct</td>     <td>rtlStructType</td>      <td>struct rtlStructStruct</td></tr>
</table><p>インタプリタとコンパイラは異なる構造体を使用するので<tt><span class="lib">&quot;arrlib.c&quot;</span></tt>から関数を使用することはできない<tt><span class="lib">&quot;arr_rtl.c&quot;</span></tt></p><p>一部のSeed7タイプは、使用されるオペレーティングシステムまたはランタイムライブラリに依存します。</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>Seed7型</th>       <th>C型</th>       <th>定義</th>                        <th>ソースファイル</th>  <th>コメント</th></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" href="#types_bigInteger">bigInteger</a>
          </tt>
        </td>       <td rowspan="2">
          <a name="ffi_bigIntType">bigIntType</a>
        </td>   <td>struct bigIntStruct*</td>             <td>big_rtl.c</td>   <td>ビルトインbigIntegerライブラリ</td></tr>
    <tr><td>mpz_ptr</td>                           <td>big_gmp.c</td>   <td>GNU Multi-Precision Library</td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" href="#types_pollData">pollData</a>
          </tt>
        </td>         <td rowspan="2">
          <a name="ffi_pollType">pollType</a>
        </td>     <td>struct select_based_pollStruct*</td>  <td>pol_sel.c</td>   <td>関数はそれを実装依存の構造体にキャストする。</td></tr>
    <tr><td>struct poll_based_pollStruct*</td>    <td>pol_unx.c</td>   <td>関数はそれを実装依存の構造体にキャストする。</td></tr>
    <tr><td rowspan="3">
          <tt>
            <a name="ffi_PRIMITIVE_WINDOW"></a>
            <span class="type">PR IMERIC_WINDOW</span>
          </tt>
        </td> <td rowspan="3">
          <a name="ffi_winType">winType</a>
        </td>      <td>x11_winRecord*</td>                   <td>drw_x11.c</td>   <td>winTypeからx11_winRecord*へキャストされた関数</td></tr>
    <tr><td>win_winRecord*</td>                   <td>drw_win.c</td>   <td>winTypeからwin_winRecord*へキャストされる関数</td></tr>
    <tr><td>emc_winRecord*</td>                   <td>drw_emc.c</td>   <td>関数がwinTypeからemc_winRecordにキャストされる*</td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" href="#types_process">プロセス</a>
          </tt>
        </td>          <td rowspan="2">
          <a name="ffi_processType">processType</a>
        </td>  <td>unx_processRecord*</td>               <td>pcs_unx.c</td>   <td>processTypeからunx_processRecord*へキャストされた関数</td></tr>
    <tr><td>win_processRecord*</td>               <td>pcs_win.c</td>   <td>processTypeからwin_processRecord*へキャストされた関数</td></tr>
    <tr><td rowspan="7">
          <tt>
            <a class="type" href="#types_database">データベース</a>
          </tt>
        </td>         <td rowspan="7">
          <a name="ffi_databaseType">databaseType</a>
        </td> <td>dbRecordCli*</td>                     <td>sql_cli.c</td>   <td>databaseTypeからdbRecordCliにキャストされた関数*</td></tr>
    <tr><td>dbRecordFire*</td>                    <td>sql_fire.c</td>  <td>databaseTypeからdbRecordFire*へキャストされた関数</td></tr>
    <tr><td>dbRecordLite*</td>                    <td>sql_lite.c</td>  <td>databaseTypeからdbRecordLite*へキャストされた関数</td></tr>
    <tr><td>dbRecordMy*</td>                      <td>sql_my.c</td>    <td>databaseTypeからdbRecordMy*へキャストされた関数</td></tr>
    <tr><td>dbRecordOci*</td>                     <td>sql_oci.c</td>   <td>databaseTypeからdbRecordOciへキャストされた関数*</td></tr>
    <tr><td>dbRecordPost*</td>                    <td>sql_post.c</td>  <td>databaseTypeからdbRecordPostへキャストされた関数*</td></tr>
    <tr><td>dbRecordTds*</td>                     <td>sql_tds.c</td>   <td>databaseTypeからdbRecordTds*へキャストされた関数</td></tr>
    <tr><td rowspan="7">
          <tt>
            <a class="type" href="#types_sqlStatement">sqlStatement</a>
          </tt>
        </td>     <td rowspan="7">
          <a name="ffi_sqlStmtType">sqlStmtType</a>
        </td>  <td>preparedStmtRecordCli*</td>           <td>sql_cli.c</td>   <td>sqlStmtTypeからpreparedStmtRecordCli*へキャストされた関数</td></tr>
    <tr><td>preparedStmtRecordFire*</td>          <td>sql_fire.c</td>  <td>sqlStmtTypeからpreparedStmtRecordFire*へキャストされた関数</td></tr>
    <tr><td>preparedStmtRecordLite*</td>          <td>sql_lite.c</td>  <td>sqlStmtTypeからpreparedStmtRecordLite*へキャストされた関数</td></tr>
    <tr><td>preparedStmtRecordMy*</td>            <td>sql_my.c</td>    <td>sqlStmtTypeからpreparedStmtRecordMy*へキャストされた関数</td></tr>
    <tr><td>preparedStmtRecordOci*</td>           <td>sql_oci.c</td>   <td>sqlStmtTypeからpreparedStmtRecordOciへキャストされた関数*</td></tr>
    <tr><td>preparedStmtRecordPost*</td>          <td>sql_post.c</td>  <td>sqlStmtTypeからpreparedStmtRecordPost*へキャストされた関数</td></tr>
    <tr><td>preparedStmtRecordTds*</td>           <td>sql_tds.c</td>   <td>sqlStmtTypeからpreparedStmtRecordTds*へキャストされた関数</td></tr>
</table><p>対応するSeed7型がないCタイプもあります。 それらは<tt><span class="lib">&quot;common.h&quot;</span></tt>:</p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>C型</th>        <th>C定義</th>        <th>コメント</th></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_int8Type">int 8型</a>
          </tt>
        </td>      <td>符号付き文字</td>         <td>1文字が8ビットで構成されるものとします。</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_uint8Type">uint 8型</a>
          </tt>
        </td>     <td>符号なし文字</td>       <td>サイズの符号なし整数型<tt><a class="type" href="#ffi_int8Type">int 8型</a></tt></td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_int16Type">int 16型</a>
          </tt>
        </td>     <td>short int</td>           <td>sizeof(short int)==2と仮定。</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_uint16Type">uint 16型</a>
          </tt>
        </td>    <td>unsigned short int</td>  <td>サイズの符号なし整数型<tt><a class="type" href="#ffi_int16Type">int 16型</a></tt></td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" name="ffi_int32Type">int 32型</a>
          </tt>
        </td>     <td>int</td>                 <td>If sizeof(int)==4</td></tr>
    <tr><td>長い</td>                <td>If sizeof(long)==4</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_uint32Type">uint 32型</a>
          </tt>
        </td>    <td>unsigned int 32型</td>  <td>サイズの符号なし整数型<tt><a class="type" href="#ffi_int32Type">int 32型</a></tt></td></tr>
    <tr><td rowspan="3">
          <tt>
            <a class="type" name="ffi_int64Type">int 64型</a>
          </tt>
        </td>     <td>長い</td>                <td>If sizeof(long)==8</td></tr>
    <tr><td>長い長い</td>           <td>If sizeof(long long)==8</td></tr>
    <tr><td>__int64</td>             <td>If sizeof(__int64)==8</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_uint64Type">uint 64型</a>
          </tt>
        </td>    <td>unsigned int 64型</td>  <td>サイズの符号なし整数型<tt><a class="type" href="#ffi_int64Type">int 64型</a></tt></td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" name="ffi_int128Type">int 128型</a>
          </tt>
        </td>    <td>__int128</td>            <td>If sizeof(__int128)==16</td></tr>
    <tr><td>__int128_t</td>          <td>If sizeof(__int128_t)==16</td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" name="ffi_uint128Type">uint 128型</a>
          </tt>
        </td>   <td>unsigned__int128</td>   <td>If sizeof(unsigned__int128)==16</td></tr>
    <tr><td>__uint128_t</td>         <td>If sizeof(__uint128_t)==16</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_uintType">uintType</a>
          </tt>
        </td>      <td>unsigned intType</td>    <td>サイズの符号なし整数型<tt><a class="type" href="#ffi_intType">intType</a></tt></td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_bitSetType">bitSetType</a>
          </tt>
        </td>    <td>uint 64型</td>          <td>使用<tt><a class="type" href="#ffi_setType">struct setStruct</a></tt></td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_timeStampType">timeStampType</a>
          </tt>
        </td> <td>int 64型</td>           <td>64ビットタイムスタンプに使用</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_cstriType">cstriType</a>
          </tt>
        </td>     <td>char*</td>              <td>Cコンパイラのstring型</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_ustriType">オーストリタイプ</a>
          </tt>
        </td>     <td>unsigned char*</td>     <td>符号なし比較に役立ちます。</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_utf16striType">utf 16 stritType</a>
          </tt>
        </td> <td>uint 16型*</td>        <td>UTF-16文字列</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_utf32striType">utf32striType</a>
          </tt>
        </td> <td>uint 32型*</td>        <td>UTF-32文字列</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_strElemType">strElemType</a>
          </tt>
        </td>   <td>charType</td>            <td>UTF-32文字要素<tt><a class="type" href="#ffi_striType">文字列</a></tt></td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_scharType">scharType</a>
          </tt>
        </td>     <td>int 32型</td>           <td>署名<tt><a class="type" href="#ffi_charType">charType</a></tt></td></tr>
    <tr><td>
          <tt><a class="type" name="ffi_cFileType">cFileType</tt>
        </td>     <td>ファイル*</td>              <td>C言語のrun-tmeライブラリで使用されるファイルタイプ</td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" name="ffi_os_striType">os_stritType</a>
          </tt>
        </td>   <td>char*</td>              <td>OSがUTF-8文字を使用している場合</td></tr>
    <tr><td>wchar_t*</td>           <td>OSがUTF-16文字を使用している場合</td></tr>
    <tr><td rowspan="2">
          <tt>
            <a class="type" name="ffi_memSizeType">memSizeType</a>
          </tt>
        </td>   <td>uint 32型</td>          <td>Cが32ビットポインタを使用し</td></tr>
    <tr><td>uint 64型</td>          <td>Cが64ビットポインタを使用し</td></tr>
    <tr><td>
          <tt>
            <a class="type" name="ffi_errInfoType">errInfoType</a>
          </tt>
        </td>   <td>int</td>                 <td>定義済みの例外を表します。</td></tr>
</table><p></p>
          <a name="ffi_System_variables">
        <h3>16.2システム変数</h3>
          </a>
        <p>インタプリタは、から初期化されるいくつかのシステム変数を使用します。<a class="link" href="#decls_System_declarations">システム宣言</a></p><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>
          <a class="link" href="#decls_System_declarations">システム宣言</a>
        </th>  <th>Seed7名</th>      <th>C<a class="type_no_ul" href="#ffi_objectType">objectType</a>マクロ</th>         <th><a class="type_no_ul" href="#ffi_objectType">objectType</a>引数のあるマクロ</th></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_empty"         >「空」</a>
          </tt>
        </td>             <td>
          <tt>
            <a class="var_no_ul" href="#types_empty"               >空の</a>
          </tt>
        </td>           <td>
          <tt>
            <a name="ffi_SYS_EMPTY_OBJECT"         >SYS_EMPTY_OBJECT</a>
          </tt>
        </td>           <td>
          <tt>EMPTY_OBJECT(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_memory_error"  >&quot;memory_error&quot;</a>
          </tt>
        </td>      <td>
          <tt>
            <a class="exception" href="#errors_MEMORY_ERROR"       >メモリエラー</a>
          </tt>
        </td>    <td>
          <tt>
            <a name="ffi_SYS_MEM_EXCEPTION"        >SYS_MEM_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>MEM_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_numeric_error" >&quot;数値エラー&quot;</a>
          </tt>
        </td>     <td>
          <tt>
            <a class="exception" href="#errors_NUMERIC_ERROR"      >NUMERIC_ERROR</a>
          </tt>
        </td>   <td>
          <tt>
            <a name="ffi_SYS_NUM_EXCEPTION"        >SYS_NUM_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>NUM_EXCEPTION(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_overflow_error">&quot;overflow_error&quot;</a>
          </tt>
        </td>    <td>
          <tt>
            <a class="exception" href="#errors_OVERFLOW_ERROR"     >OVERFLOW_ERROR</a>
          </tt>
        </td>  <td>
          <tt>
            <a name="ffi_SYS_OVF_EXCEPTION"        >SYS_OVF_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>OVF_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_range_error"   >&quot;範囲エラー&quot;</a>
          </tt>
        </td>       <td>
          <tt>
            <a class="exception" href="#errors_RANGE_ERROR"        >範囲エラー</a>
          </tt>
        </td>     <td>
          <tt>
            <a name="ffi_SYS_RNG_EXCEPTION"        >SYS_RNG_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>RNG_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_index_error"   >&quot;index_error&quot;</a>
          </tt>
        </td>       <td>
          <tt>
            <a class="exception" href="#errors_INDEX_ERROR"        >INDEX_ERROR</a>
          </tt>
        </td>     <td>
          <tt>
            <a name="ffi_SYS_IDX_EXCEPTION"        >SYS_IDX_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>IDX_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_file_error"    >&quot;file_error&quot;</a>
          </tt>
        </td>        <td>
          <tt>
            <a class="exception" href="#errors_FILE_ERROR"         >FILE_ERROR</a>
          </tt>
        </td>      <td>
          <tt>
            <a name="ffi_SYS_FIL_EXCEPTION"        >SYS_FIL_EXCEPTION</a>
          </tt>
        </td>          <td>
          <tt>FIL_EXCEPTION(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_database_error">&quot;database_error&quot;</a>
          </tt>
        </td>    <td>
          <tt>
            <a class="exception" href="#errors_DATABASE_ERROR"     >DATABASE_ERROR</a>
          </tt>
        </td>  <td>
          <tt>
            <a name="ffi_SYS_DB_EXCEPTION"         >SYS_DB_EXCEPTION</a>
          </tt>
        </td>           <td>
          <tt>DB_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_graphic_error" >&quot;グラフィックエラー&quot;</a>
          </tt>
        </td>     <td>
          <tt>
            <a class="exception" href="#errors_GRAPHIC_ERROR"      >GRAPHIC_ERROR</a>
          </tt>
        </td>   <td>
          <tt>
            <a name="ffi_SYS_GRAPHIC_EXCEPTION"    >SYS_GRAPHIC_EXCEPTION</a>
          </tt>
        </td>      <td>
          <tt>GRAPHIC_EXCEPTION(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_illegal_action">&quot;illegible_action&quot;</a>
          </tt>
        </td>    <td>
          <tt>
            <a class="exception" href="#errors_ILLEGAL_ACTION"     >ILLEGAL_ACTION</a>
          </tt>
        </td>  <td>
          <tt>
            <a name="ffi_SYS_ACT_ILLEGAL_EXCEPTION">SYS_ACT_ILLEGAL_EXCEPTION</a>
          </tt>
        </td>  <td>
          <tt>ACT_ILLEGAL_EXCEPTION(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_false"         >「間違い」</a>
          </tt>
        </td>             <td>
          <tt>
            <span class="var_no_ul">FALSE</span>
          </tt>
        </td>           <td>
          <tt>
            <a name="ffi_SYS_FALSE_OBJECT"         >SYS_FALSE_OBJECT</a>
          </tt>
        </td>           <td>
          <tt>FALSE_OBJECT(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_true"          >「true」</a>
          </tt>
        </td>              <td>
          <tt>
            <span class="var_no_ul">TRUE</span>
          </tt>
        </td>            <td>
          <tt>
            <a name="ffi_SYS_TRUE_OBJECT"          >SYS_TRUE_OBJECT</a>
          </tt>
        </td>            <td>
          <tt>TRUE_OBJECT(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_expr"          >&quot;expr&quot;</a>
          </tt>
        </td>              <td>
          <tt>
            <a class="type" href="#types_expr"                     >expr</a>
          </tt>
        </td>            <td>
          <tt>
            <a name="ffi_SYS_EXPR_TYPE"            >SYS_EXPR_TYPE</a>
          </tt>
        </td>              <td>
          <tt>EXPR_TYPE(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_f_param"       >&quot;f_param&quot;</a>
          </tt>
        </td>           <td>
          <tt>
            <span class="type"                                        >f_param</span>
          </tt>
        </td>         <td>
          <tt>
            <a name="ffi_SYS_F_PARAM_TYPE"         >SYS_F_PARAM_TYPE</a>
          </tt>
        </td>           <td>
          <tt>F_PARAM_TYPE(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_integer"       >&quot;integer&quot;</a>
          </tt>
        </td>           <td>
          <tt>
            <a class="type" href="#types_integer"                  >整数</a>
          </tt>
        </td>         <td>
          <tt>
            <a name="ffi_SYS_INT_TYPE"             >SYS_INT_TYPE</a>
          </tt>
        </td>               <td>
          <tt>INT_TYPE(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_bigInteger"    >&quot;bigInteger&quot;</a>
          </tt>
        </td>        <td>
          <tt>
            <a class="type" href="#types_bigInteger"               >bigInteger</a>
          </tt>
        </td>      <td>
          <tt>
            <a name="ffi_SYS_BIGINT_TYPE"          >SYS_BIGINT_TYPE</a>
          </tt>
        </td>            <td>
          <tt>BIGINT_TYPE(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_char"          >&quot;char&quot;</a>
          </tt>
        </td>              <td>
          <tt>
            <a class="type" href="#types_char"                     >char</a>
          </tt>
        </td>            <td>
          <tt>
            <a name="ffi_SYS_CHAR_TYPE"            >SYS_CHAR_TYPE</a>
          </tt>
        </td>              <td>
          <tt>CHAR_TYPE(prog)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_string"        >&quot;文字列&quot;</a>
          </tt>
        </td>            <td>
          <tt>
            <a class="type" href="#types_string"                   >文字列</a>
          </tt>
        </td>          <td>
          <tt>
            <a name="ffi_SYS_STRI_TYPE"            >システム起動タイプ</a>
          </tt>
        </td>              <td>
          <tt>STRI_TYPE(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_proc"          >&quot;proc&quot;</a>
          </tt>
        </td>              <td>
          <tt>
            <a class="type" href="#types_proc"                     >proc</a>
          </tt>
        </td>            <td>
          <tt>
            <a name="ffi_SYS_PROC_TYPE"            >SYS_PROC_TYPE</a>
          </tt>
        </td>              <td>
          <tt>PROC_TYPE(プログラム)</tt>
        </td></tr>
    <tr><td>
          <tt>
            <a class="link" href="#decls_float"         >&quot;float&quot;</a>
          </tt>
        </td>             <td>
          <tt>
            <a class="type" href="#types_float"                    >浮かぶ</a>
          </tt>
        </td>           <td>
          <tt>
            <a name="ffi_SYS_FLT_TYPE"             >SYS_FLT_TYPE</a>
          </tt>
        </td>               <td>
          <tt>FLT_TYPE(プログラム)</tt>
        </td></tr>
</table><p></p>
          <a name="ffi_String_conversions">
        <h3>16.3文字列の変換</h3>
          </a>
        <p>Seed7文字列はUTF-32エンコードで、C文字列はゼロ終端のバイト列です。 Cは長さのあるバイト列も使用する。 バイトシーケンスはISO-8859-1またはUTF-8でエンコードできます。 異なる表現間で変換するには<tt><span class="lib">&quot;stritutl.h&quot;</span></tt>タイプ間の変換関数を定義する<tt><a class="type" href="#ffi_striType">striType</a></tt><tt><a class="type" href="#ffi_cstriType">cstriType</a></tt><tt><a class="type" href="#ffi_bstriType">bstriType</a></tt><tt><a class="type" href="#ffi_utf16striType">utf 16 stritType</a></tt>および<tt><a class="type" href="#ffi_utf32striType">utf32striType</a></tt>・タイプ<tt><a class="type" href="#ffi_utf16striType">utf 16 stritType</a></tt>および<tt><a class="type" href="#ffi_utf32striType">utf32striType</a></tt>の大きさとは無関係である<tt><span class="type">wchar_t</span></tt>Strings with<tt><a class="type" href="#ffi_utf16striType">utf 16 stritType</a></tt>および<tt><a class="type" href="#ffi_utf32striType">utf32striType</a></tt>はゼロ終端されたものでも、パラメータで指定された長さのバッファでもよい。</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">機能概要</td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_cstriType">cstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_cstri">stri_to_cstri</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からISO-8859-1エンコードC文字列を作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_cstriType">cstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_cstri8">stri_to_cstri8</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からUTF-8エンコードC文字列を作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_cstriType">cstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_cstri8_buf">stri_to_cstri8_buf</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からUTF-8エンコードC文字列バッファを作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_bstriType">bstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_bstri">stri_to_bstri</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列から、ISO-8859-1エンコードbstringを作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_bstriType">bstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_bstri8">stri_to_bstri8</a></b>(<a class="type" href="#ffi_striType">const_striType</a>stri)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からUTF-8エンコードbstringを作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_utf16striType">utf 16 stritType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_wstri16">stri_to_wstri16</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からUTF-16エンコード・ワイド・ストリング・バッファーを作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_utf32striType">utf32striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_wstri32">stri_to_wstri32</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列からUTF-32エンコード・ワイド・ストリング・バッファーを作成します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri_to_stri">cstri_to_stri</a></b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri)</td></tr>
      <tr><td width="30"></td><td>ISO-8859-1(Latin-1)エンコードのC文字列をSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri_buf_to_stri">cstri_buf_to_stri</a></b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ)</td></tr>
      <tr><td width="30"></td><td>ISO-8859-1(Latin-1)エンコードのC文字列バッファをSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri8_to_stri">cstri8_to_stri</a></b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>UTF-8エンコードされたC文字列をSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri8_buf_to_stri">cstri8_buf_to_stri</a></b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>UTF-8符号化のC文字列バッファをSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cstri8_or_cstri_to_stri">cstri8_or_cstri_to_stri</a></b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri)</td></tr>
      <tr><td width="30"></td><td>UTF-8またはISO-8859-1符号化C文字列をSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_wstri16_to_stri">wstri16_to_stri</a></b>(<a class="type" href="#ffi_utf16striType">const_utf16striType</a>wstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>UTF-16符号化ワイド・ストリング・バッファをSeed7文字列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_wstri32_to_stri">wstri32_to_stri</a></b>(<a class="type" href="#ffi_utf32striType">const_utf32striType</a>wstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>UTF-32符号化ワイド文字列バッファをSeed7文字列にコピーします。</td></tr></table></td></tr>
</table></div>
          <br />
        <div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">機能詳細</td></tr></table>

  <div>
          <a name="ffi_stri_to_cstri">
        <h3>stri_to_cstri</h3>
          </a>
        <p><a class="type" href="#ffi_cstriType">cstriType</a><b>stri_to_cstri</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列からISO-8859-1エンコードC文字列を作成します。 ゼロバイトで終端されたC文字列用のメモリが割り当てられる。 結果のC文字列はマクロで解放する必要があります。<a class="func" href="#ffi_free_cstri">free_cstri</a>()。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>striにヌル文字か、許可された最大のISO-8859-1文字(255)より大きい文字が含まれている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>はISO-8859-1エンコードされたNULL終端C文字列を返す。メモリ確保が失敗した場合や変換が失敗した場合(err_infoがエラーを示す)はNULLを返す。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_cstri8">
        <h3>stri_to_cstri8</h3>
          </a>
        <p><a class="type" href="#ffi_cstriType">cstriType</a><b>stri_to_cstri8</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列からUTF-8エンコードC文字列を作成します。 ゼロバイトで終端されたC文字列用のメモリが割り当てられる。 結果のC文字列はマクロで解放する必要があります。<a class="func" href="#ffi_free_cstri8">free_cstri8</a>()。 この機能は、パラメータとして使用される一時的な文字列を作成することを目的としています。 良好な性能を得るには、C文字列に割り当てられたメモリーがサイズ超過です。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>striにヌル文字か、許可されたUnicode文字の最大値(U+10 FFFF)より大きい文字が含まれている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-8形式でエンコードされた、ヌルで終了するC文字列です。メモリ割り当てが失敗した場合や変換が失敗した場合(err_infoによってエラーが示されます)は、NULLが返されます。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_cstri8_buf">
        <h3>stri_to_cstri8_buf</h3>
          </a>
        <p><a class="type" href="#ffi_cstriType">cstriType</a><b>stri_to_cstri8_buf</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ)</p><dl><dd><p>Seed7 UTF-32文字列からUTF-8エンコードC文字列バッファを作成します。 ゼロバイトで終端されたC文字列用のメモリが割り当てられる。 文字列内に0バイトがある場合、C文字列にコピーされる。 結果のC文字列はマクロで解放する必要があります。<a class="func" href="#ffi_free_cstri8">free_cstri8</a>()。 この機能は、パラメータとして使用される一時的な文字列を作成することを目的としています。 良好な性能を得るには、C文字列に割り当てられたメモリーがサイズ超過です。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>長さ</tt>-結果の長さ(「\0」なし)を返す場所。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-8形式でエンコードされたヌル終端C文字列でなければなりません。メモリアロケーションが失敗した場合はNULLが返ります。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_bstri">
        <h3>stri_to_bstri</h3>
          </a>
        <p><a class="type" href="#ffi_bstriType">bstriType</a><b>stri_to_bstri</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列から、ISO-8859-1エンコードbstringを作成します。 bstringのメモリが割り当てられます。 bstringの末尾にゼロバイトは追加されません。 UTF-32文字列にヌル文字が含まれている場合、特別なアクションは実行されません。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>striに許可された最大のISO-8859-1文字(255)より大きい文字が含まれている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>ISO-8859-1エンコードされたbstring。メモリアロケーションや変換が失敗した場合(err_infoがエラーを示す)、NULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_bstri8">
        <h3>stri_to_bstri8</h3>
          </a>
        <p><a class="type" href="#ffi_bstriType">bstriType</a><b>stri_to_bstri8</b>(<a class="type" href="#ffi_striType">const_striType</a>stri)</p><dl><dd><p>Seed7 UTF-32文字列からUTF-8エンコードbstringを作成します。 bstringのメモリが割り当てられます。 bstringの末尾にゼロバイトは追加されません。 元の文字列にヌル文字が含まれている場合、特別な処理は行われません。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-8エンコードされたbstringです。メモリアロケーションが失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_wstri16">
        <h3>stri_to_wstri16</h3>
          </a>
        <p><a class="type" href="#ffi_utf16striType">utf 16 stritType</a><b>stri_to_wstri16</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列からUTF-16エンコード・ワイド・ストリング・バッファーを作成します。 ゼロ・バイト終端ワイド・ストリング用のメモリーが割り当てられます。 この機能は、パラメータとして使用される一時的な文字列を作成することを目的としています。 良好なパフォーマンスを得るには、ワイド・ストリングに割り当てられたメモリーがサイズ超過です。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>長さ</tt>-結果の文字長さ(「\0」なし)を返す位置。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>striに許可されたUnicode文字の最大値(U+10 FFFF)より大きい文字が含まれている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-16エンコードされたNULLで終端されたワイド文字列。メモリ割り当てが失敗した場合や変換が失敗した場合(err_infoによってエラーが示される場合)はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_wstri32">
        <h3>stri_to_wstri32</h3>
          </a>
        <p><a class="type" href="#ffi_utf32striType">utf32striType</a><b>stri_to_wstri32</b>(<span class="keywd">const</span><a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列からUTF-32エンコード・ワイド・ストリング・バッファーを作成します。 ゼロ・バイト終端ワイド・ストリング用のメモリーが割り当てられます。 この機能は、パラメータとして使用される一時的な文字列を作成することを目的としています。 良好なパフォーマンスを得るには、ワイド・ストリングに割り当てられたメモリーがサイズ超過です。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>長さ</tt>-結果の文字長さ(「\0」なし)を返す位置。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>striに許可されたUnicode文字の最大値(U+10 FFFF)より大きい文字が含まれている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコードされたNULLで終端されたワイド文字列。メモリ割り当てが失敗した場合や変換が失敗した場合(エラーがerr_infoで示される場合)はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cstri_to_stri">
        <h3>cstri_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cstri_to_stri</b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri)</p><dl><dd><p>ISO-8859-1(Latin-1)エンコードのC文字列をSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-ヌル終端のISO-8859-1エンコードC文字列。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコード形式のSeed7文字列、またはメモリアロケーションに失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cstri_buf_to_stri">
        <h3>cstri_buf_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cstri_buf_to_stri</b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ)</p><dl><dd><p>ISO-8859-1(Latin-1)エンコードのC文字列バッファをSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-ISO-8859-1エンコードC文字列バッファ(ヌル終端でない)。</dd>
        <dd><tt>長さ</tt>-ISO-8859-1エンコードC文字列バッファのバイト長。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコード形式のSeed7文字列、またはメモリアロケーションに失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cstri8_to_stri">
        <h3>cstri8_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cstri8_to_stri</b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>UTF-8エンコードされたC文字列をSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-UTF-8エンコードされたC文字列がヌルで終了しています。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>変換が失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコードされたSeed7文字列。メモリ割り当てが失敗した場合や無効なUTF-8エンコードが使用されている場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cstri8_buf_to_stri">
        <h3>cstri8_buf_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cstri8_buf_to_stri</b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>UTF-8符号化のC文字列バッファをSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-UTF-8エンコードC文字列バッファ(ヌル終端でない)。</dd>
        <dd><tt>長さ</tt>-UTF-8エンコードC文字列バッファのバイト長。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>変換が失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコードされたSeed7文字列。メモリ割り当てが失敗した場合や無効なUTF-8エンコードが使用されている場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cstri8_or_cstri_to_stri">
        <h3>cstri8_or_cstri_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cstri8_or_cstri_to_stri</b>(<a class="type" href="#ffi_cstriType">const_cstriType</a>cstri)</p><dl><dd><p>UTF-8またはISO-8859-1符号化C文字列をSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-ヌル終端のUTF-8またはISO-8859-1エンコードC文字列。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコード形式のSeed7文字列、またはメモリアロケーションに失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_wstri16_to_stri">
        <h3>wstri16_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>wstri16_to_stri</b>(<a class="type" href="#ffi_utf16striType">const_utf16striType</a>wstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>UTF-16符号化ワイド・ストリング・バッファをSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>wstri</tt>-UTF-16エンコード形式のワイド・ストリング・バッファ(NULL終端でない)。</dd>
        <dd><tt>長さ</tt>-UTF-16エンコード形式のワイド・ストリング・バッファの文字長。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコード形式のSeed7文字列、またはメモリアロケーションに失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_wstri32_to_stri">
        <h3>wstri32_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>wstri32_to_stri</b>(<a class="type" href="#ffi_utf32striType">const_utf32striType</a>wstri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>UTF-32符号化ワイド文字列バッファをSeed7文字列にコピーします。 UTF-32符号化されたSeed7文字列用のメモリが割り当てられます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>wstri</tt>-UTF-32エンコード形式のワイド文字列バッファ(ヌル終端でない)。</dd>
        <dd><tt>長さ</tt>-UTF-32エンコード・ワイド・ストリング・バッファの文字長。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコード形式のSeed7文字列、またはメモリアロケーションに失敗した場合はNULLを返します。</dd></dl></dd>
</dl></div></div>
          <a name="ffi_Operating_system_string_and_path_conversions">
        <h3>16.4 OSの文字列とパスの変換</h3>
          </a>
        <p>オペレーティング・システムでのUnicodeエンコーディング(UTF-8またはUTF-16)が一致しない。 そのために<tt><span class="lib">&quot;stritutl.h&quot;</span></tt>タイプを定義する<tt><a class="type" href="#ffi_os_striType">os_stritType</a></tt>とからに変換する関数と<tt><a class="type" href="#ffi_os_striType">os_stritType</a></tt>ファイルパスを表す異なる概念(パス区切り文字とドライブ文字)は<tt><a class="func" href="#ffi_cp_to_os_path">cp_to_os_path</a></tt>および<tt><a class="func" href="#ffi_cp_from_os_path">cp_from_os_path</a></tt></p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">機能概要</td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_conv_from_os_stri">conv_from_os_stri</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_os_striType">const_os_striType</a>os_stri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ)</td></tr>
      <tr><td width="30"></td><td>長さのあるos_stritType文字列をSeed7 UTF-32文字列に変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_os_striType">os_stritType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_os_stri">stri_to_os_stri</a></b>(<a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7 UTF-32文字列を、終端がnullのos_stritType文字列に変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_os_stri_to_stri">os_stri_to_stri</a></b>(<a class="type" href="#ffi_os_striType">const_os_striType</a>os_stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>末尾がNULLのos_stritType文字列をSeed7 UTF-32文字列に変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_os_striType">os_stritType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cp_to_os_path">cp_to_os_path</a></b>(<a class="type" href="#ffi_striType">const_striType</a>std_path<span class="type">int</span>*path_info<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>Seed7標準パスをシステムコールで使用されるパスに変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_cp_from_os_path">cp_from_os_path</a></b>(<a class="type" href="#ffi_os_striType">const_os_striType</a>os_path<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</td></tr>
      <tr><td width="30"></td><td>システム・コールから戻されたパスをSeed7標準パスに変換します。</td></tr></table></td></tr>
</table></div>
          <br />
        <div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">機能詳細</td></tr></table>

  <div>
          <a name="ffi_conv_from_os_stri">
        <h3>conv_from_os_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>conv_from_os_stri</b>(<span class="keywd">const</span><a class="type" href="#ffi_os_striType">const_os_striType</a>os_stri<a class="type" href="#ffi_memSizeType">memSizeType</a>長さ)</p><dl><dd><p>長さのあるos_stritType文字列をSeed7 UTF-32文字列に変換します。 多くのシステムコールは長さのあるos_stritTypeデータを返す。 システムコールは、&quot;version.h&quot;と&quot;os_decls.h&quot;で定義されている。 これらにはos_というプレフィックスが付き、os_stritType型の文字列を使用する。 os_stritTypeは、オペレーティング・システムに応じて、バイトまたはワイドのchar文字列を記述できます。 エンコーディングにはLatin-1、UTF-8、UTF-16を使用でき、またコード・ページを使用することもできます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>os_stri</tt>-バイナリ列の可能性があります(ヌル文字を含む)。</dd>
        <dd><tt>長さ</tt>-os_striの長さ(文字数)</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>Seed7 UTF-32ストリング。エラーが発生した場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_os_stri">
        <h3>stri_to_os_stri</h3>
          </a>
        <p><a class="type" href="#ffi_os_striType">os_stritType</a><b>stri_to_os_stri</b>(<a class="type" href="#ffi_striType">const_striType</a>stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7 UTF-32文字列を、終端がnullのos_stritType文字列に変換します。 ヌル文字で終端されたos_stritType文字列用のメモリが割り当てられる。 os_stritTypeの結果はマクロとともに割り当てられます。<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()マクロで解放する必要があります。<a class="func" href="#ffi_os_stri_free">os_stri_free</a>()。 文字列の割り付け<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()は、作成したときと逆の順序で解放する必要があります。 これにより、割り当てがスタックのように機能します。 多くのシステムコールは、ヌル文字で終端されたos_stritType文字列を持つパラメータを持っています。 システムコールは、&quot;version.h&quot;と&quot;os_decls.h&quot;で定義されている。 これらにはos_というプレフィックスが付き、os_stritType型の文字列を使用する。 os_stritTypeは、オペレーティング・システムに応じて、バイトまたはワイドのchar文字列を記述できます。 エンコーディングにはLatin-1、UTF-8、UTF-16を使用でき、またコード・ページを使用することもできます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>stri</tt>-変換対象のSeed7 UTF-32文字列。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>変換が失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>システムコールで使用される、終端がnullのos_stritType値。エラーが発生した場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_os_stri_to_stri">
        <h3>os_stri_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>os_stri_to_stri</b>(<a class="type" href="#ffi_os_striType">const_os_striType</a>os_stri<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>末尾がNULLのos_stritType文字列をSeed7 UTF-32文字列に変換します。 多くのシステムコールは、終端がnullのos_stritType文字列を返す。 システムコールは、&quot;version.h&quot;と&quot;os_decls.h&quot;で定義されている。 これらにはos_というプレフィックスが付き、os_stritType型の文字列を使用する。 os_stritTypeは、オペレーティング・システムに応じて、バイトまたはワイドのchar文字列を記述できます。 エンコーディングにはLatin-1、UTF-8、UTF-16を使用でき、またコード・ページを使用することもできます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>os_stri</tt>-変換するos_stritType文字列がヌル終端であること</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>Seed7 UTF-32ストリング。エラーが発生した場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cp_to_os_path">
        <h3>cp_to_os_path</h3>
          </a>
        <p><a class="type" href="#ffi_os_striType">os_stritType</a><b>cp_to_os_path</b>(<a class="type" href="#ffi_striType">const_striType</a>std_path<span class="type">int</span>*path_info<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>Seed7標準パスをシステムコールで使用されるパスに変換します。 ヌル終端のos_stritTypeパス用のメモリが割り当てられます。 os_stritTypeの結果はマクロとともに割り当てられます。<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()マクロで解放する必要があります。<a class="func" href="#ffi_os_stri_free">os_stri_free</a>()。 文字列の割り付け<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()は、作成したときと逆の順序で解放する必要があります。 これにより、割り当てがスタックのように機能します。 システムコールは、&quot;version.h&quot;と&quot;os_decls.h&quot;で定義されている。 これらにはos_という接頭辞が付けられ、os_stritTypeタイプのシステム・パスが使用されます。 os_stritTypeは、オペレーティング・システムに応じて、バイトまたはワイドのchar文字列を記述できます。 エンコーディングにはLatin-1、UTF-8、UTF-16を使用でき、またコード・ページを使用することもできます。 os_stritTypeへの変換以外に、一部のオペレーティングシステムではドライブレターへのマッピングが行われることがあります。</p></dd>
    <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>標準パス</tt>-UTF-32符号化変換するSeed7標準パス。</dd>
        <dd><tt>path_info</tt>-機能が成功した場合は変更なし。パスが&quot;/&quot;の場合はPATH_IS_EMULATED_ROOT。パスをマッピングできない場合はPATH_NOT_MAPPED。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。<a class="exception" href="#ffi_errInfoType_RANGE_ERROR">範囲エラー</a>パスが標準パスでない場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>システムコールによって使用される、終端がnullのos_stritTypeパス。エラーが発生した場合はNULL。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_cp_from_os_path">
        <h3>cp_from_os_path</h3>
          </a>
        <p><a class="type" href="#ffi_striType">striType</a><b>cp_from_os_path</b>(<a class="type" href="#ffi_os_striType">const_os_striType</a>os_path<a class="type" href="#ffi_errInfoType">errInfoType</a>*err_info)</p><dl><dd><p>システム・コールから戻されたパスをSeed7標準パスに変換します。 システムコールは、&quot;version.h&quot;と&quot;os_decls.h&quot;で定義されている。 これらにはos_という接頭辞が付けられ、os_stritTypeタイプのシステム・パスが使用されます。 os_stritTypeは、オペレーティング・システムに応じて、バイトまたはワイドのchar文字列を記述できます。 エンコーディングにはLatin-1、UTF-8、UTF-16を使用でき、またコード・ページを使用することもできます。 os_stritTypeからの変換以外にも、一部のオペレーティング・システムではドライブ文字からのマッピングが行われることがあります。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>os_path</tt>-変換するos_stritTypeパスがnullで終了している。</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>メモリアロケーションが失敗した場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-32エンコードされたSeed7標準パス。メモリアロケーションに失敗した場合はNULL。</dd></dl></dd>
</dl></div></div>
          <a name="ffi_Macros_to_access_the_action_parameters">
        <h3>16.5アクションパラメータにアクセスするためのマクロ</h3>
          </a>
        <p>プリミティブアクション関数には<tt>&#39;arguments&#39;</tt>その<tt>&#39;arguments&#39;</tt>パラメータの型<tt><a class="type" href="#ffi_listType">リストタイプ</a></tt>オブジェクトのリストを含みます。 ヘッダファイル<tt><span class="lib">&quot;objutl.h&quot;</span></tt>のようなマクロを定義します<tt><a class="func" href="#ffi_arg_1">arg_1</a></tt><tt><a class="func" href="#ffi_arg_2">arg_2</a></tt><tt><a class="func" href="#ffi_arg_3">arg_3</a></tt>などを使用して<tt>&#39;arguments&#39;</tt></p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">リストからSeed7オブジェクトを取得するための関数(マクロ)</td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_1">arg_1</a></b>(<a class="type" href="#ffi_listType">リストタイプ</a>引数)</td></tr>
      <tr><td width="30"></td><td>リストの最初のオブジェクトを選びます。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_2">arg_2</a></b>(<a class="type" href="#ffi_listType">リストタイプ</a>引数)</td></tr>
      <tr><td width="30"></td><td>リストから2番目のオブジェクトを取り出します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_3">arg_3</a></b>(<a class="type" href="#ffi_listType">リストタイプ</a>引数)</td></tr>
      <tr><td width="30"></td><td>リストから3番目のオブジェクトを取り出します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <b></b>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2">
          <b></b>
        </td></tr>
      </table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_arg_12">arg_12</a></b>(<a class="type" href="#ffi_listType">リストタイプ</a>引数)</td></tr>
      <tr><td width="30"></td><td>リストから12番目のオブジェクトを取り出します。</td></tr></table></td></tr>
</table></div><p>オブジェクト値は特定のC実装型を含みます。 ヘッダファイル<tt><span class="lib">&quot;objutl.h&quot;</span></tt>のようなマクロを定義します<tt><a class="func" href="#ffi_isit_char">isit_char</a></tt>および<tt><a class="func" href="#ffi_isit_set">isit_set</a></tt>を用いて、オブジェクトが要求された型であるかどうかをチェックする。 オブジェクトが要求されたC実装型を持っていない場合、エラー・メッセージが書き込まれます。</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">Cの型のSeed7オブジェクトを調べる関数(マクロ)</td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_array">isit_array</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_arrayType">arrayType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bigint">isit_bigint</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_bigIntType">bigIntType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bool">isit_bool</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_boolType">boolType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_bstri">isit_bstri</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_bstriType">bstriType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_char">isit_char</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_charType">charType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_database">isit_database</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_databaseType">databaseType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_file">init_file</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_fileType">ファイルタイプ</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_float">isit_float</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_floatType">floatType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_hash">isit_hash</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_hashType">hashType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_int">isit_int</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_intType">intType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_poll">isi_poll</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_pollType">pollType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_set">isit_set</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_setType">setType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_socket">isit_socket</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_socketType">socketType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_sqlstmt">isit_sqlstmt</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_sqlStmtType">sqlStmtType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_stri">isit_stri</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_striType">striType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_struct">isit_struct</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_structType">structType</a></td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_isit_win">勝利</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトタイプが<a class="type" href="#ffi_winType">winType</a></td></tr></table></td></tr>
</table></div><p>ヘッダファイル<tt><span class="lib">&quot;objutl.h&quot;</span></tt>のようなマクロを定義します<tt><a class="func" href="#ffi_take_bool">飲む</a></tt>および<tt><a class="func" href="#ffi_take_file">take_file</a></tt>これらのマクロは、要求されたC実装型の値を返します。</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">Seed7オブジェクトのC値を取得する関数(マクロ)</td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_arrayType">arrayType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_array">take_array</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから配列値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_bigIntType">bigIntType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bigint">take_bigint</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからbigInteger値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_boolType">boolType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bool">飲む</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからブール値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_bstriType">bstriType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_bstri">take_bstri</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからbstring値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_charType">charType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_char">take_char</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからchar値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_databaseType">databaseType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_database">take_database</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからデータベース値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_fileType">ファイルタイプ</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_file">take_file</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからファイルの値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_floatType">floatType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_float">take_float</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから実数値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_hashType">hashType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_hash">take_hash</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからハッシュテーブル値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_intType">intType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_int">take_int</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから整数値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_pollType">pollType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_poll">投票する</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから投票データ値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_setType">setType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_set">take_set</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから集合値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_socketType">socketType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_socket">ソケットを取る</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからソケット値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_sqlStmtType">sqlStmtType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_sqlstmt">take_sqlstmt</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトからSQL準備文の値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_striType">striType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_stri">take_stri</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから文字列値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_structType">structType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_struct">take_struct</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから構造体値を取得します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_winType">winType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_take_win">take_win</a></b>(<a class="type" href="#ffi_objectType">objectType</a>arg)</td></tr>
      <tr><td width="30"></td><td>オブジェクトから構造体値を取得します。</td></tr></table></td></tr>
</table></div>
          <a name="ffi_Functions_to_create_action_results">
        <h3>16.6アクション結果を出す機能</h3>
          </a>
        <p>プリミティブアクション関数は、以下の型の結果を持ちます。<tt><a class="type" href="#ffi_objectType">objectType</a></tt>・ヘッダファイル<tt><span class="lib">&quot;objutl.h&quot;</span></tt>のようなマクロを定義します<tt><a class="func" href="#ffi_bld_bigint_temp">bld_bigint_temp</a></tt>および<tt><a class="func" href="#ffi_bld_stri_temp">bld_stri_temp</a></tt>指定されたタイプのオブジェクトを作成します。</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">C値のSeed7オブジェクトを作成する関数</td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_array_temp">bld_array_temp</a></b>(<a class="type" href="#ffi_arrayType">arrayType</a>temp_array)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_arrayType">arrayType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_bigint_temp">bld_bigint_temp</a></b>(<a class="type" href="#ffi_bigIntType">bigIntType</a>temp_bigint)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_bigIntType">bigIntType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_bstri_temp">bld_bstri_temp</a></b>(<a class="type" href="#ffi_bstriType">bstriType</a>一時的)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_bstriType">bstriType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_char_temp">bld_char_temp</a></b>(<a class="type" href="#ffi_charType">charType</a>temp_char</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_charType">charType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_database_temp">bld_database_temp</a></b>(<a class="type" href="#ffi_databaseType">databaseType</a>temp_database)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_databaseType">databaseType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_file_temp">bld_file_temp</a></b>(<a class="type" href="#ffi_fileType">ファイルタイプ</a>temp_file)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_fileType">ファイルタイプ</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_float_temp">bld_float_temp</a></b>(<a class="type" href="#ffi_floatType">floatType</a>temp_float)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_floatType">floatType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_hash_temp">bld_hash_temp</a></b>(<a class="type" href="#ffi_hashType">hashType</a>temp_hash</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_hashType">hashType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_int_temp">bld_int_temp</a></b>(<a class="type" href="#ffi_intType">intType</a>temp_int)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_intType">intType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_poll_temp">bld_poll_temp</a></b>(<a class="type" href="#ffi_pollType">pollType</a>temp_poll)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_pollType">pollType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_set_temp">bld_set_temp</a></b>(<a class="type" href="#ffi_setType">setType</a>temp_set)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_setType">setType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_socket_temp">bld_socket_temp</a></b>(<a class="type" href="#ffi_socketType">socketType</a>temp_socket)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_socketType">socketType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_sqlstmt_temp">bld_sqlstmt_temp</a></b>(<a class="type" href="#ffi_sqlStmtType">sqlStmtType</a>temp_sqlstmt)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_sqlStmtType">sqlStmtType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_stri_temp">bld_stri_temp</a></b>(<a class="type" href="#ffi_striType">striType</a>一時</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_striType">striType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_struct_temp">bld_struct_temp</a></b>(<a class="type" href="#ffi_structType">structType</a>temp_struct)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_structType">structType</a>value.</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_objectType">objectType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a name="ffi_bld_win_temp">bld_win_temp</a></b>(<a class="type" href="#ffi_winType">winType</a>temp_win)</td></tr>
      <tr><td width="30"></td><td>でオブジェクトを作成します。<a class="type" href="#ffi_winType">winType</a>value.</td></tr></table></td></tr>
</table></div>
          <a name="ffi_Memory_management_macros">
        <h3>16.7メモリ管理マクロ</h3>
          </a>
        <p>上記変換機能はマクロを使用しており、メモリ管理を行っている。 これらのマクロの一部はmalloc()を使用せず、スタックでメモリーを管理します。 したがって、正しいマクロを使用してメモリを割り当て、解放することが重要です。 以下のマクロがヘッダファイルで定義されます。<tt><span class="lib">&quot;stritutl.h&quot;</span></tt></p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">マクロの概要</td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_free_cstri">free_cstri</a></b>(<a class="type" href="#ffi_cstriType">cstriType</a>cstri<a class="type" href="#ffi_striType">striType</a>stri)</td></tr>
      <tr><td width="30"></td><td>によって割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_stri_to_cstri">stri_to_cstri</a>()。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_free_cstri8">free_cstri8</a></b>(<a class="type" href="#ffi_cstriType">cstriType</a>cstri<a class="type" href="#ffi_striType">striType</a>stri)</td></tr>
      <tr><td width="30"></td><td>によって割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_stri_to_cstri8">stri_to_cstri8</a>()または<a class="func" href="#ffi_stri_to_cstri8_buf">stri_to_cstri8_buf</a>()。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_boolType">boolType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_os_stri_alloc">os_stri_alloc</a></b>(<a class="type" href="#ffi_os_striType">os_stritType</a>&amp;var<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>にメモリを割り当てるマクロ<a class="type" href="#ffi_os_striType">os_stritType</a>文字列。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_os_stri_free">os_stri_free</a></b>(<a class="type" href="#ffi_os_striType">os_stritType</a>var)</td></tr>
      <tr><td width="30"></td><td>で割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a></td></tr></table></td></tr>
</table></div>
          <br />
        <div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">マクロの詳細</td></tr></table>

  <div>
          <a name="ffi_free_cstri">
        <h3>free_cstri</h3>
          </a>
        <p><span class="type">無</span><b>free_cstri</b>(<a class="type" href="#ffi_cstriType">cstriType</a>cstri<a class="type" href="#ffi_striType">striType</a>stri)</p><dl><dd><p>によって割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_stri_to_cstri">stri_to_cstri</a>()。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-解放する文字列</dd>
        <dd><tt>stri</tt>-終了時に使用されたパラメータ<a class="func" href="#ffi_stri_to_cstri">stri_to_cstri</a>()が呼び出されました。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_free_cstri8">
        <h3>free_cstri8</h3>
          </a>
        <p><span class="type">無</span><b>free_cstri8</b>(<a class="type" href="#ffi_cstriType">cstriType</a>cstri<a class="type" href="#ffi_striType">striType</a>stri)</p><dl><dd><p>によって割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_stri_to_cstri8">stri_to_cstri8</a>()または<a class="func" href="#ffi_stri_to_cstri8_buf">stri_to_cstri8_buf</a>()。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>cstri</tt>-解放する文字列</dd>
        <dd><tt>stri</tt>-終了時に使用されたパラメータ<a class="func" href="#ffi_stri_to_cstri8">stri_to_cstri8</a>()または<a class="func" href="#ffi_stri_to_cstri8_buf">stri_to_cstri8_buf</a>()が呼び出されました。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_os_stri_alloc">
        <h3>os_stri_alloc</h3>
          </a>
        <p><a class="type" href="#ffi_boolType">boolType</a><b>os_stri_alloc</b>(<a class="type" href="#ffi_os_striType">os_stritType</a>&amp;var<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>にメモリを割り当てるマクロ<a class="type" href="#ffi_os_striType">os_stritType</a>文字列。 文字列の割り付け<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()はで解放する必要があります。<a class="func" href="#ffi_os_stri_free">os_stri_free</a>()作成時と逆の順序になります。 これにより、割り当てがスタックのように機能します。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>var</tt>-割り当てられたメモリが割り当てられる変数への参照</dd>
        <dd><tt>len</tt>-割り当てられたメモリーのサイズ(文字単位)。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>割当てが成功した場合はTRUE、メモリー割当てに失敗した場合はFALSEになります。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_os_stri_free">
        <h3>os_stri_free</h3>
          </a>
        <p><span class="type">無</span><b>os_stri_free</b>(<a class="type" href="#ffi_os_striType">os_stritType</a>var)</p><dl><dd><p>で割り当てられたメモリを解放するマクロ<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>Strings allocated with<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>()はで解放する必要があります。<a class="func" href="#ffi_os_stri_free">os_stri_free</a>()作成時と逆の順序になります。 これにより、割り当てがスタックのように機能します。 で返される文字列は<a class="func" href="#ffi_stri_to_os_stri">stri_to_os_stri</a>および<a class="func" href="#ffi_cp_to_os_path">cp_to_os_path</a>とともに割り当てられる<a class="func" href="#ffi_os_stri_alloc">os_stri_alloc</a>それゆえ、彼らもまた解放されなければならない<a class="func" href="#ffi_os_stri_free">os_stri_free</a>()作成時と逆の順序になります。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>var</tt>-解放する文字列</dd></dl></dd>
</dl></div></div>
          <a name="ffi_Basic_conversion_functions">
        <h3>16.8基本的な変換関数</h3>
          </a>
        <p>上記変換機能は基本的な変換機能で実現されている。 状況によっては、基本的な変換関数を直接使用することに意味がある場合があります。 この機能はパフォーマンスのために最適化されています。 いくつかの機能は、ダフの装置にヒントを得たループ展開を使用しています。 ヘッダファイルで以下の基本変換関数が定義されています。<tt><span class="lib">&quot;stritutl.h&quot;</span></tt></p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">機能概要</td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_memcpy_to_strelem">詳細</a></b>(<span class="keywd">登録する</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_ustriType">const_ustriType</a>src<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>lenバイトを文字列内のSeed7文字にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_memset_to_strelem">memset_to_strelem</a></b>(<span class="keywd">登録する</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>ch<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>len 7文字をch文字で埋めます。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_boolType">boolType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_memcpy_from_strelem">横から縦に</a></b>(<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_ustriType">const_ustriType</a>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>src<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>lenSeed7文字をバイト列にコピーします。</td></tr></table></td></tr>

    <tr><td align="right" valign="top"><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*</td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_memchr_strelem">memchr_strelem</a></b>(<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*mem<span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>ch<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>最初のlenのSeed7文字からchを探します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_memSizeType">memSizeType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_utf8_to_stri">utf8_to_stri</a></b>(<a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest_stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*<span class="keywd">const</span>dest_len<a class="type" href="#ffi_ustriType">const_ustriType</a>ウストリ<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>UTF-8エンコード文字列をUTF-32エンコード文字列に変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_memSizeType">memSizeType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_utf8">stri_to_utf8</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_ustriType">オーストリタイプ</a>out_stri<span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*strelem<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</td></tr>
      <tr><td width="30"></td><td>UTF-32エンコード文字列をUTF-8エンコード文字列に変換します。</td></tr></table></td></tr>

    <tr><td align="right" valign="top">
          <a class="type" href="#ffi_memSizeType">memSizeType</a>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_stri_to_utf16">stri_to_utf16</a></b>(<span class="keywd">const</span><a class="type" href="#ffi_utf16striType">utf 16 stritType</a>out_wstri<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*strelem<a class="type" href="#ffi_memSizeType">memSizeType</a>len<a class="type" href="#ffi_errInfoType">errInfoType</a>*<span class="keywd">const</span>err_info)</td></tr>
      <tr><td width="30"></td><td>UTF-32エンコード文字列をUTF-16エンコード文字列に変換します。</td></tr></table></td></tr>
</table></div>
          <br />
        <div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">機能詳細</td></tr></table>

  <div>
          <a name="ffi_memcpy_to_strelem">
        <h3>詳細</h3>
          </a>
        <p><span class="type">無</span><b>詳細</b>(<span class="keywd">登録する</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_ustriType">const_ustriType</a>src<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>lenバイトを文字列内のSeed7文字にコピーします。 この関数は、srcとdestが同じアドレスを指している場合にも正しく動作する。 つまり、次のものに対して正しく動作します。</p><pre>memcpy_to_strelem(mem, (ustriType)mem, num);
</pre></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>dest</tt>-UTF-32エンコード文字による保存先配列</dd>
        <dd><tt>ソース</tt>-ソース配列(ISO-8859-1エンコード・バイト)。</dd>
        <dd><tt>len</tt>-&#39;src&#39;のバイト数および&#39;dest&#39;のUTF-32文字。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_memset_to_strelem">
        <h3>memset_to_strelem</h3>
          </a>
        <p><span class="type">無</span><b>memset_to_strelem</b>(<span class="keywd">登録する</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>ch<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>len 7文字をch文字で埋めます。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>dest</tt>-UTF-32エンコード文字による保存先配列</dd>
        <dd><tt>ch</tt>-&#39;dest&#39;に設定するUTF-32エンコード文字</dd>
        <dd><tt>len</tt>-&#39;ch&#39;が&#39;dest&#39;に埋め込まれる頻度を指定します。</dd></dl></dd>
</dl></div>
<hr />
 <div>
          <a name="ffi_memcpy_from_strelem">
        <h3>横から縦に</h3>
          </a>
        <p><a class="type" href="#ffi_boolType">boolType</a><b>横から縦に</b>(<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_ustriType">const_ustriType</a>dest<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>src<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>lenSeed7文字をバイト列にコピーします。 この関数は、ダフの装置にヒントを得たループ展開と、バイナリまたは(=)を使用したトリックを使用して、許容値をチェックします。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>dest</tt>-ISO-8859-1エンコードバイトによるコピー先配列</dd>
        <dd><tt>ソース</tt>-UTF-32エンコード文字によるソース配列</dd>
        <dd><tt>len</tt>-&#39;src&#39;のUTF-32文字数と&#39;dest&#39;のUTF-32バイト数</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>いずれかの文字が1バイトに収まらない場合はTRUEを、それ以外の場合はFALSEを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_memchr_strelem">
        <h3>memchr_strelem</h3>
          </a>
        <p><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*<b>memchr_strelem</b>(<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*mem<span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>ch<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>最初のlenのSeed7文字からchを探します。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>mem</tt>-UTF-32文字の配列</dd>
        <dd><tt>ch</tt>-memで検索されるUTF-32文字</dd>
        <dd><tt>len</tt>-&#39;mem&#39;内のUTF-32文字数</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>マッチした文字へのポインタ。指定された文字列内にその文字がない場合はNULLを返します。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_utf8_to_stri">
        <h3>utf8_to_stri</h3>
          </a>
        <p><a class="type" href="#ffi_memSizeType">memSizeType</a><b>utf8_to_stri</b>(<a class="type" href="#ffi_strElemType">strElemType</a>*<span class="keywd">const</span>dest_stri<a class="type" href="#ffi_memSizeType">memSizeType</a>*<span class="keywd">const</span>dest_len<a class="type" href="#ffi_ustriType">const_ustriType</a>ウストリ<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>UTF-8エンコード文字列をUTF-32エンコード文字列に変換します。 コピー元とコピー先の文字列が&#39;\0&#39;で終了していません。 宛先dest_striのためのメモリーは割り当てられていません。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>dest_stri</tt>-UTF-32エンコードされた文字列の送信先。</dd>
        <dd><tt>dest_len</tt>-dest_striの長さを返す場所</dd>
        <dd><tt>ウストリ</tt>-変換するUTF-8エンコード文字列。</dd>
        <dd><tt>len</tt>-システム内のバイト数</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>処理が成功した場合は0を返す。</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_utf8">
        <h3>stri_to_utf8</h3>
          </a>
        <p><a class="type" href="#ffi_memSizeType">memSizeType</a><b>stri_to_utf8</b>(<span class="keywd">const</span><a class="type" href="#ffi_ustriType">オーストリタイプ</a>out_stri<span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*strelem<a class="type" href="#ffi_memSizeType">memSizeType</a>len)</p><dl><dd><p>UTF-32エンコード文字列をUTF-8エンコード文字列に変換します。 コピー元とコピー先の文字列が&#39;\0&#39;で終了していません。 宛先out_striのためのメモリは割り当てられていません。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>アウト_ストリー</tt>-UTF-8エンコードされた文字列の送信先</dd>
        <dd><tt>strelem</tt>-変換するUTF-32エンコード文字列。</dd>
        <dd><tt>len</tt>-StrelemのUTF-32文字数</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-8形式に変換した文字列の長さ</dd></dl></dd>
</dl></div>
<hr />
  <div>
          <a name="ffi_stri_to_utf16">
        <h3>stri_to_utf16</h3>
          </a>
        <p><a class="type" href="#ffi_memSizeType">memSizeType</a><b>stri_to_utf16</b>(<span class="keywd">const</span><a class="type" href="#ffi_utf16striType">utf 16 stritType</a>out_wstri<span class="keywd">登録する</span><span class="keywd">const</span><a class="type" href="#ffi_strElemType">strElemType</a>*strelem<a class="type" href="#ffi_memSizeType">memSizeType</a>len<a class="type" href="#ffi_errInfoType">errInfoType</a>*<span class="keywd">const</span>err_info)</p><dl><dd><p>UTF-32エンコード文字列をUTF-16エンコード文字列に変換します。 コピー元とコピー先の文字列が&#39;\0&#39;で終了していません。 宛先out_wstri用のメモリは割り当てられていません。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>リソース</tt>-UTF-16エンコードされた文字列の送信先。</dd>
        <dd><tt>strelem</tt>-変換するUTF-32エンコード文字列。</dd>
        <dd><tt>len</tt>-StrelemのUTF-32文字数</dd>
        <dd><tt>err_info</tt>-関数が成功した場合は変更なし<a class="exception" href="#ffi_errInfoType_MEMORY_ERROR">メモリエラー</a>*strelemに含まれている文字が、使用可能なUnicode文字の最大値(U+10 FFFF)を超えている場合。</dd>
</dl></dd>
      <dd><dl><dt>
          <b>戻り値:</b>
        </dt>
        <dd>UTF-16文字列に変換したときの文字長</dd></dl></dd>
</dl></div></div>
          <a name="ffi_Error_handling">
        <h3>16.9エラー処理</h3>
          </a>
        <p>Cプログラム言語は例外を提供しません。 Seed7では、いくつかのメソッドを使用してエラー処理を行っています。 実際の例外が発生する前に、エラー状態をさまざまな方法で処理できます。</p><ul>
    <li>integer型<tt><a class="type" href="#ffi_errInfoType">errInfoType</a></tt>は、エラー状態を表すのに使用されます。 通常はという名前の変数またはパラメータ<tt><span class="var">err_info</span></tt>は、エラーの状態を格納するために使用されます。 値<tt><a class="exception" href="#ffi_errInfoType_OKAY_NO_ERROR">OK OK_NO_ERROR</a></tt>は、エラーが発生しなかったことを示します。 その他の値(下記参照)は、発生したエラーを示します。</li>
    <li>状況によっては、ある関数に対してただ一つの起こりうるエラー状況しかないことがある(例えばGSLのインスタンス1)。<tt><span class="exception">メモリエラー</span></tt>)。 が指定された場合、NULLを返す関数で処理される。<tt><span class="exception">メモリエラー</span></tt></li>
</ul><p>のエラー状態定数<tt><a class="type" href="#ffi_errInfoType">errInfoType</a></tt>は<tt><span class="lib">&quot;common.h&quot;</span></tt>:</p><pre class="indent">
#
0
#
1
#
2
#
3
#
4
#
5
#
6
#
7
#
8
#
9
<span class="keywd">定義する</span><a name="ffi_errInfoType_OKAY_NO_ERROR" ><span class="exception">OK OK_NO_ERROR</span></a>定義する<span class="keywd"></span>メモリエラー<a name="ffi_errInfoType_MEMORY_ERROR"  ><span class="exception">定義する</span></a><span class="keywd">NUMERIC_ERROR</span>定義する<a name="ffi_errInfoType_NUMERIC_ERROR" ><span class="exception"></span></a>OVERFLOW_ERROR<span class="keywd">定義する</span><a name="ffi_errInfoType_OVERFLOW_ERROR"><span class="exception">範囲エラー</span></a>定義する<span class="keywd"></span>INDEX_ERROR<a name="ffi_errInfoType_RANGE_ERROR"   ><span class="exception">定義する</span></a><span class="keywd">FILE_ERROR</span>定義する<a name="ffi_errInfoType_INDEX_ERROR"   ><span class="exception"></span></a>DATABASE_ERROR<span class="keywd">定義する</span><a name="ffi_errInfoType_FILE_ERROR"    ><span class="exception">GRAPHIC_ERROR</span></a>定義する<span class="keywd"></span>ACTION_ERROR<a name="ffi_errInfoType_DATABASE_ERROR"><span class="exception"></span></a><span class="keywd"></span><a name="ffi_errInfoType_GRAPHIC_ERROR" ><span class="exception"></span></a><span class="keywd"></span><a name="ffi_errInfoType_ACTION_ERROR"  ><span class="exception"></span></a></pre><p>Cコードは<tt><span class="var">err_info</span></tt>変数から値を取得するか、関数がNULLを返すかどうかを調べます。 エラーが発生した場合は、クリーンアップを行うことができます。 この方法により、複数の機能レベルにわたってエラー状況が伝播する可能性があります。 既存のエラー状況(<tt><span class="var">err_info</span></tt>に等しくない値が含まれています<tt><a class="exception" href="#ffi_errInfoType_OKAY_NO_ERROR">OK OK_NO_ERROR</a></tt>)は、エラーが発生しなかった状態にリセットされません。</p><p>マクロで実際の例外をトリガーできます。<tt><a class="func" href="#ffi_raise_error">raise_error</a></tt>このマクロは<tt><a class="type" href="#ffi_errInfoType">errInfoType</a></tt>パラメータを使用して実際の例外を記述します。 すべてのクリーンアップは、事前に行う必要があります。<tt><a class="func" href="#ffi_raise_error">raise_error</a></tt>が呼び出されます。 このマクロは、関数を呼び出します。<tt><span class="func">raise_error2</span></tt>追加パラメータ__FILE__と__LINE__を使用する。 機能<tt><span class="func">raise_error2</span></tt>には、インタプリタ型プログラムとコンパイル型プログラムで異なる実装があります。</p><ul>
    <li>通訳の中で<tt><span class="func">raise_error2</span></tt>フェイルフラグをセットし、正常終了します。</li>
    <li>コンパイルされたコード<tt><span class="func">raise_error2</span></tt>は<tt><span class="func">ロングジャケット</span></tt>例外のハンドラコードでの実行を継続します。</li>
</ul><p>つまり<tt><a class="func" href="#ffi_raise_error">raise_error</a></tt>もインタプリタでは正常に戻ります。 を呼び出す関数<tt><a class="func" href="#ffi_raise_error">raise_error</a></tt>はこの関数を呼び出した後に戻らなければならない。 囲み関数も戻る必要があります。 カレントアクション関数まで行う必要があります。 したがって、これらの関数は常にイミディエイトを返すか、特別な戻り値(例えばNULL)によってシグナルを返します。 特別な戻り値を受け取った時にクリーンアップを行っても、コンパイルされたコードでは動作しません。 片づけが必要であれば、掃除をする必要がある。<tt><a class="func" href="#ffi_raise_error">raise_error</a></tt>外部関数で実行する必要があります。</p><div><table width="100%" border="1" cellspacing="0" cellpadding="3">
<tr><td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF" colspan="2">機能概要</td></tr>

    <tr><td align="right" valign="top">
          <span class="type">無</span>
        </td><td><table border="0" cellspacing="0" cellpadding="0"> <tr><td colspan="2"><b><a class="link" href="#ffi_raise_error">raise_error</a></b>(<a class="type" href="#ffi_errInfoType">errInfoType</a>err_info)</td></tr>
      <tr><td width="30"></td><td>例外を発生させるマクロです。</td></tr></table></td></tr>
</table></div>
          <br />
        <div><p><table width="100%" border="1" cellspacing="0" cellpadding="2"><tr>
<td style="font-size: 22px; font-weight: bold; background-color: #C0C0FF">機能詳細</td></tr></table>

  <div>
          <a name="ffi_raise_error">
        <h3>raise_error</h3>
          </a>
        <p><span class="type">無</span><b>raise_error</b>(<a class="type" href="#ffi_errInfoType">errInfoType</a>err_info)</p><dl><dd><p>例外を発生させるマクロです。 このマクロは、関数を呼び出します。<span class="func">raise_error2</span>追加パラメータ__FILE__と__LINE__を使用する。 機能<span class="func">raise_error2</span>にはインタプリタ型プログラムとコンパイル型プログラムで異なる実装がある。</p></dd>
      <dd><dl><dt>
          <b>パラメータ:</b>
        </dt>
        <dd><tt>err_info</tt>-提起される例外。</dd></dl></dd>
</dl></div></div>
          <a name="errors_file_start"></a>
        <p></p>
          <a name="errors_ERRORS">
        <h2>17. エラー</h2>
          </a>
        <p></p>
          <a name="errors_Parsing_errors">
        <h3>17.1解析エラー</h3>
          </a>
        <p>構文解析エラーはインタプリタとコンパイラが原因となります。 これらのエラーはプログラム実行前にチェックされます。 error 1(Out of heap space)以外のエラーは解析を終了しません。 エラーが発生した場合、プログラムは解釈できず、コンパイルできません。 インタプリタオプション<span class="link"><tt>-x</tt></span>を使用すると、プログラムにエラーが含まれていても実行できます。 次の解析エラーが存在します。</p><dl><dd><table border="0" cellspacing="0">
    <tr><td align="right">1:</td> <td width="10"></td><td>
          <a name="errors_OUT_OF_HEAP_SPACE"                >致命的エラー:ヒープ領域不足</a>
        </td></tr>
    <tr><td align="right">2:</td> <td width="10"></td><td>
          <a name="errors_EOF_ENCOUNTERED"                  >&quot;ファイルの終わり&quot;が検出されました</a>
        </td></tr>
    <tr><td align="right">3:</td> <td width="10"></td><td>
          <a name="errors_CHAR_ILLEGAL"                     ></a>
          <a class="link" href="#tokens_CHAR_ILLEGAL_example"                     >テキスト「%s」に不正な文字があります(U+%04x)</a>
        </td></tr>
    <tr><td align="right">4:</td> <td width="10"></td><td>
          <a name="errors_UNCLOSED_COMMENT"                 ></a>
          <a class="link" href="#tokens_UNCLOSED_COMMENT_example"                      >閉じられていないコメント</a>
        </td></tr>
    <tr><td align="right">5:</td> <td width="10"></td><td>
          <a name="errors_INCLUDE_FILE_NOT_FOUND"           >インクルードファイル&quot;%s&quot;が見つかりません</a>
        </td></tr>
    <tr><td align="right">6:</td> <td width="10"></td><td>
          <a name="errors_WRONG_PATH_DELIMITER"             >パスの区切り文字として\\の代わりに/を使用する</a>
        </td></tr>
    <tr><td align="right">7:</td> <td width="10"></td><td>
          <a name="errors_ESSENTIAL_INCLUDE_FAILED"         >必須ファイルのインクルードに失敗しました。 解析が終了しました。</a>
        </td></tr>
    <tr><td align="right">8:</td> <td width="10"></td><td>
          <a name="errors_ILLEGALPRAGMA"                    ></a>
          <a class="link" href="#decls_ILLEGALPRAGMA_example"                     >プラグマ&quot;%s&quot;が不正です。</a>
        </td></tr>
    <tr><td align="right">9:</td> <td width="10"></td><td>
          <a name="errors_UNDEFINED_ACTION"                 >未定義のアクション&quot;%s&quot;</a>
        </td></tr>
    <tr><td align="right">10:</td> <td width="10"></td><td>
          <a name="errors_WRONGSYSTEM"                      >不正なシステム宣言&quot;%s&quot;</a>
        </td></tr>
    <tr><td align="right">11:</td> <td width="10"></td><td>
          <a name="errors_DOLLAR_VALUE_WRONG"               >&quot;newtype&quot;、&quot;subtype&quot;、&quot;func&quot;、&quot;enumlit&quot;、または&quot;action&quot;が見つかりました&quot;%s&quot;</a>
        </td></tr>
    <tr><td align="right">12:</td> <td width="10"></td><td>
          <a name="errors_DOLLAR_TYPE_WRONG"                >&quot;func&quot;または&quot;type&quot;が予期した結果&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">13:</td> <td width="10"></td><td>
          <a name="errors_SYSTEM_MAIN_MISSING"              >mainのシステム宣言がありません。</a>
        </td></tr>
    <tr><td align="right">14:</td> <td width="10"></td><td>
          <a name="errors_INTEGER_TOO_BIG"                  ></a>
          <a class="link" href="#tokens_INTEGER_TOO_BIG_example"             >整数&quot;%s&quot;が大きすぎます</a>
        </td></tr>
    <tr><td align="right">15:</td> <td width="10"></td><td>
          <a name="errors_NEGATIVE_EXPONENT"                ></a>
          <a class="link" href="#tokens_NEGATIVE_EXPONENT_example"                 >整数リテラルの負の指数</a>
        </td></tr>
    <tr><td align="right">16:</td> <td width="10"></td><td>
          <a name="errors_DIGIT_EXPECTED"                   ></a>
          <a class="link" href="#tokens_DIGIT_EXPECTED_example"                    >予期された数字「%s」が見つかりました</a>
        </td></tr>
    <tr><td align="right">17:</td> <td width="10"></td><td>
          <a name="errors_INTEGER_WITH_EXPONENT_TOO_BIG"    ></a>
          <a class="link" href="#tokens_INTEGER_WITH_EXPONENT_TOO_BIG_example"       >整数&quot;%dE%s&quot;大きすぎます</a>
        </td></tr>
    <tr><td align="right">18:</td> <td width="10"></td><td>
          <a name="errors_BASE2TO36ALLOWED"                 ></a>
          <a class="link" href="#tokens_BASE2TO36ALLOWED_example"                 >整数ベース&quot;%ld&quot;が2から36の間にありません</a>
        </td></tr>
    <tr><td align="right">19:</td> <td width="10"></td><td>
          <a name="errors_EXTENDED_DIGIT_EXPECTED"          ></a>
          <a class="link" href="#tokens_EXTENDED_DIGIT_EXPECTED_example"                 >拡張数字が予期され、「%s」が見つかりました</a>
        </td></tr>
    <tr><td align="right">20:</td> <td width="10"></td><td>
          <a name="errors_ILLEGAL_BASED_DIGIT"              ></a>
          <a class="link" href="#tokens_ILLEGAL_BASED_DIGIT_example"                >ベース整数&quot;%d#%s&quot;内に不正な数字&quot;%c&quot;があります</a>
        </td></tr>
    <tr><td align="right">21:</td> <td width="10"></td><td>
          <a name="errors_BASED_INTEGER_TOO_BIG"            ></a>
          <a class="link" href="#tokens_BASED_INTEGER_TOO_BIG_example"               >基準整数&quot;%d#%s&quot;が大きすぎます</a>
        </td></tr>
    <tr><td align="right">22:</td> <td width="10"></td><td>
          <a name="errors_APOSTROPHE_EXPECTED"              ></a>
          <a class="link" href="#tokens_APOSTROPHE_EXPECTED_example"                >&quot;&#39;&#39;&quot;予期したものが見つかりました&quot;%s&quot;</a>
        </td></tr>
    <tr><td align="right">23:</td> <td width="10"></td><td>
          <a name="errors_CHAR_EXCEEDS"                     ></a>
          <a class="link" href="#tokens_CHAR_EXCEEDS_example"                      >文字直定数がソース行を超えています</a>
        </td></tr>
    <tr><td align="right">24:</td> <td width="10"></td><td>
          <a name="errors_WRONG_QUOTATION_REPRESENTATION"   ></a>
          <a class="link" href="#tokens_WRONG_QUOTATION_REPRESENTATION_example"   >文字列内での表現には&quot;&quot;の代わりに&quot;&quot;を使用します。</a>
        </td></tr>
    <tr><td align="right">25:</td> <td width="10"></td><td>
          <a name="errors_ILLEGAL_STRING_ESCAPE"            ></a>
          <a class="link" href="#tokens_ILLEGAL_STRING_ESCAPE_example"                     >不正な文字列エスケープ&quot;\%s&quot;</a>
        </td></tr>
    <tr><td align="right">26:</td> <td width="10"></td><td>
          <a name="errors_WRONG_NUMERICAL_ESCAPE"           ></a>
          <a class="link" href="#tokens_WRONG_NUMERICAL_ESCAPE_example"             >数字のエスケープシーケンスは&quot;;&quot;で終わる必要があります。&quot;%s&quot;は使用できません。</a>
        </td></tr>
    <tr><td align="right">27:</td> <td width="10"></td><td>
          <a name="errors_NUMERICAL_ESCAPE_TOO_BIG"         ></a>
          <a class="link" href="#tokens_NUMERICAL_ESCAPE_TOO_BIG_example"         >数字エスケープシーケンス&quot;\%u;&quot;は大きすぎます。</a>
        </td></tr>
    <tr><td align="right">28:</td> <td width="10"></td><td>
          <a name="errors_WRONG_STRING_CONTINUATION"        ></a>
          <a class="link" href="#tokens_WRONG_STRING_CONTINUATION_example"                >文字列の継続は&quot;%s&quot;ではなく&quot;\&quot;で終了する必要があります</a>
        </td></tr>
    <tr><td align="right">29:</td> <td width="10"></td><td>
          <a name="errors_STRING_EXCEEDS"                   ></a>
          <a class="link" href="#tokens_STRING_EXCEEDS_example"                    >文字列リテラルがソース行を超えています</a>
        </td></tr>
    <tr><td align="right">30:</td> <td width="10"></td><td>
          <a name="errors_NAME_EXPECTED"                    >名前が&quot;%s&quot;で見つかりました</a>
        </td></tr>
    <tr><td align="right">31:</td> <td width="10"></td><td>
          <a name="errors_INTEGER_EXPECTED"                 ></a>
          <a class="link" href="#tokens_INTEGER_EXPECTED_example"                    >整数リテラルが予期され、&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">32:</td> <td width="10"></td><td>
          <a name="errors_STRING_EXPECTED"                  >文字列リテラルが予期された場所に&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">33:</td> <td width="10"></td><td>
          <a name="errors_IDENT_EXPECTED"                   >Identifier expected found&quot;%s&quot;</a>
        </td></tr>
    <tr><td align="right">34:</td> <td width="10"></td><td>
          <a name="errors_TYPE_EXPECTED"                    >予期したタイプ%sが見つかりました</a>
        </td></tr>
    <tr><td align="right">35:</td> <td width="10"></td><td>
          <a name="errors_PROC_EXPECTED"                    ></a>
          <span class="link">Procedure expected found&quot;%s&quot;expression</span>
        </td></tr>
    <tr><td align="right">36:</td> <td width="10"></td><td>
          <a name="errors_PARAM_SPECIFIER_EXPECTED"         >パラメータ指定子が予期した&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">37:</td> <td width="10"></td><td>
          <a name="errors_PARAM_DECL_OR_SYMBOL_EXPECTED"    >パラメータ宣言またはシンボルが予期され、%sが見つかりました</a>
        </td></tr>
    <tr><td align="right">38:</td> <td width="10"></td><td>
          <a name="errors_EXCEPTION_EXPECTED"               >例外が%sで見つかりました</a>
        </td></tr>
    <tr><td align="right">39:</td> <td width="10"></td><td>
          <a name="errors_EXPR_EXPECTED"                    >式が予期され、&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">40:</td> <td width="10"></td><td>
          <a name="errors_EXPECTED_SYMBOL"                  ></a>
          <span class="link">&quot;%s&quot;予期した&quot;%s&quot;が見つかりました</span>
        </td></tr>
    <tr><td align="right">41:</td> <td width="10"></td><td>
          <a name="errors_PARAM_DECL_FAILED"                >パラメータ%sの宣言に失敗しました。</a>
        </td></tr>
    <tr><td align="right">42:</td> <td width="10"></td><td>
          <a name="errors_DECL_FAILED"                      ></a>
          <a class="link" href="#decls_DECL_FAILED_example"                       >&quot;%s&quot;のデクラレーションに失敗しました。</a>
        </td></tr>
    <tr><td align="right">43:</td> <td width="10"></td><td>
          <a name="errors_REDECLARATION"                    ></a>
          <span class="link">&quot;%s&quot;の再宣言</span>
        </td></tr>
    <tr><td align="right">44:</td> <td width="10"></td><td>
          <a name="errors_PREVIOUS_DECLARATION"             ></a>
          <span class="link">&quot;%s&quot;の前の宣言</span>
        </td></tr>
    <tr><td align="right">45:</td> <td width="10"></td><td>
          <a name="errors_EXCEPTION_RAISED"                 >例外&quot;%s&quot;を発生</a>
        </td></tr>
    <tr><td align="right">46:</td> <td width="10"></td><td>
          <a name="errors_ILLEGAL_ASSOCIATIVITY"            >予想される結合性が&quot;%s&quot;見つかりました</a>
        </td></tr>
    <tr><td align="right">47:</td> <td width="10"></td><td>
          <a name="errors_ILLEGAL_PRIORITY"                 >文の優先度&quot;%s&quot;が大きすぎます。</a>
        </td></tr>
    <tr><td align="right">48:</td> <td width="10"></td><td>
          <a name="errors_TWO_PARAMETER_SYNTAX"             >演算子の前に2つのパラメータを持つ構文は不適当です</a>
        </td></tr>
    <tr><td align="right">49:</td> <td width="10"></td><td>
          <a name="errors_EMPTY_SYNTAX"                     >構文宣言が空です</a>
        </td></tr>
    <tr><td align="right">50:</td> <td width="10"></td><td>
          <a name="errors_SYNTAX_DECLARED_TWICE"            >構文%sが2回宣言されました</a>
        </td></tr>
    <tr><td align="right">51:</td> <td width="10"></td><td>
          <a name="errors_DOT_EXPR_EXPECTED"                >構文記述としてドット表現が必要です。%sが見つかりました</a>
        </td></tr>
    <tr><td align="right">52:</td> <td width="10"></td><td>
          <a name="errors_REDECLARED_INFIX_PRIORITY"        ></a>
          <span class="link">&quot;%s&quot;中置記法の優先度%dで再宣言されました%dではありません</span>
        </td></tr>
    <tr><td align="right">53:</td> <td width="10"></td><td>
          <a name="errors_REDECLARED_PREFIX_PRIORITY"       >&quot;%s&quot;プレフィックス優先度%dで再宣言されました%dではありません</a>
        </td></tr>
    <tr><td align="right">54:</td> <td width="10"></td><td>
          <a name="errors_WRONG_EXPR_PARAM_PRIORITY"        >&quot;%s&quot;の後のパラメータには優先度%dが必要です%dではありません</a>
        </td></tr>
    <tr><td align="right">55:</td> <td width="10"></td><td>
          <a name="errors_WRONG_PREFIX_PRIORITY"            >優先度&lt;=%d優先度%dで&quot;%s&quot;が見つかりました</a>
        </td></tr>
    <tr><td align="right">56:</td> <td width="10"></td><td>
          <a name="errors_DOT_EXPR_ILLEGAL"                 >&quot;%s&quot;のドット表現には%dではなく%dの優先度が必要です</a>
        </td></tr>
    <tr><td align="right">57:</td> <td width="10"></td><td>
          <a name="errors_NO_MATCH"                         ></a>
          <a class="link" href="#decls_NO_MATCH_example"                          >%sとの一致に失敗しました</a>
        </td></tr>
    <tr><td align="right">58:</td> <td width="10"></td><td>
          <a name="errors_WRONGACCESSRIGHT"                 ></a>
          <a class="link" href="#tutorial_WRONGACCESSRIGHT_example"               >%sで予期された変数が%sで見つかりました</a>
        </td></tr>
    <tr><td align="right">59:</td> <td width="10"></td><td>
          <a name="errors_LITERAL_TYPE_UNDEFINED"           >リテラル&quot;%s&quot;の型が未定義です</a>
        </td></tr>
    <tr><td align="right">60:</td> <td width="10"></td><td>
          <a name="errors_KIND_OF_IN_PARAM_UNDEFINED"       >タイプ&quot;%s&quot;に対して指定されていないパラメータ(valまたはref)の種類</a>
        </td></tr>
    <tr><td align="right">61:</td> <td width="10"></td><td>
          <a name="errors_OVERLONG_UTF8_ENCODING"           ></a>
          <a class="link" href="#tokens_OVERLONG_UTF8_ENCODING_example"           >文字&quot;%s&quot;に使用されている長すぎるUTF-8エンコーディング(U+%04x)</a>
        </td></tr>
    <tr><td align="right">62:</td> <td width="10"></td><td>
          <a name="errors_UTF16_SURROGATE_CHAR_FOUND"       ></a>
          <a class="link" href="#tokens_UTF16_SURROGATE_CHAR_FOUND_example"       >UTF-8エンコード&quot;%s&quot;にUTF-16代理文字が見つかりました(U+%04x)</a>
        </td></tr>
    <tr><td align="right">63:</td> <td width="10"></td><td>
          <a name="errors_CHAR_NOT_UNICODE"                 ></a>
          <a class="link" href="#tokens_CHAR_NOT_UNICODE_example"                 >非Unicode文字が見つかりました&quot;%s&quot;(U+%04x)</a>
        </td></tr>
    <tr><td align="right">64:</td> <td width="10"></td><td>
          <a name="errors_UTF8_CONTINUATION_BYTE_EXPECTED"  ></a>
          <a class="link" href="#tokens_UTF8_CONTINUATION_BYTE_EXPECTED_example"  >UTF-8継続バイトが予期され、&quot;%s&quot;が見つかりました(U+%04x)</a>
        </td></tr>
    <tr><td align="right">65:</td> <td width="10"></td><td>
          <a name="errors_UNEXPECTED_UTF8_CONTINUATION_BYTE"></a>
          <a class="link" href="#tokens_UNEXPECTED_UTF8_CONTINUATION_BYTE_example">予期しないUTF-8継続バイトが&quot;%s&quot;(U+%04x)で見つかりました</a>
        </td></tr>
    <tr><td align="right">66:</td> <td width="10"></td><td>
          <a name="errors_SOLITARY_UTF8_START_BYTE"         ></a>
          <a class="link" href="#tokens_SOLITARY_UTF8_START_BYTE_example"         >孤立したUTF-8開始バイト&quot;%s&quot;が見つかりました(U+%04x)</a>
        </td></tr>
    <tr><td align="right">67:</td> <td width="10"></td><td>
          <a name="errors_UTF16_BYTE_ORDER_MARK_FOUND"      ></a>
          <a class="link" href="#tokens_UTF16_BYTE_ORDER_MARK_FOUND_example"      >UTF-16バイトオーダーマークが&quot;%s&quot;を検出しました(U+%04x)</a>
        </td></tr>
    <tr><td align="right"></td> <td width="10"></td><td>未定義エラー</td></tr>
</table></dd></dl><p>プログラムは他のプログラムを解析して、その解析エラーを調べることができます。 プログラムのソースコードは以下の通りです。<span class="lib">s7check.sd7</span>これはEmacsのSeed7モードがSeed7ソースファイルまたはライブラリの静的チェックを行うために使用します。</p><pre class="indent">
$
;

;






;

value;

0;

value;




fileName
(PROGRAM)[1];

)次に
aProgram




);


aProgram
(fileName);

;



);




エラー
(aProgram, index);




anError.error

anError.message);

(anError.errorLine);



);

;

;

;

;

;
<span class="keywd">含む</span><span class="lib">&quot;seed7_05.s7i&quot;</span>含む<span class="keywd"></span>&quot;<span class="stri">プロジェクトs7i<span class="lib">&quot;</span>const</span><a class="keywd_no_ul" href="#decls_Procedure_declarations">proc</a>:main<a class="type_no_ul" href="#types_proc">is func</a>地域の<span class="keywd">var</span><span class="keywd">文字列</span>:fileName<a class="keywd_no_ul" href="#decls_Variable_declarations">は</a><a class="type_no_ul" href="#types_string">&quot;&quot;</a>var<span class="keywd"></span>プログラム<a class="stri" href="#tokens_String_literals">:aProgram</a>は<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>プログラム<a class="type_no_ul" href="#types_program">var</a><span class="keywd">整数</span>:index<a class="type_no_ul" href="#types_program">は</a>var<a class="keywd_no_ul" href="#decls_Variable_declarations"></a>parseError<a class="type_no_ul" href="#types_integer">:anError</a>は<span class="keywd"></span>parseError<a class="keywd_no_ul" href="#decls_Variable_declarations">begin</a>if<a class="type_no_ul" href="#types_parseError"></a>長さ<span class="keywd">(</span>argv<span class="type">(PROGRAM))</span>>=<span class="keywd">1</span>その時<a class="keywd_no_ul" href="#stats_if-statement">:=</a><span class="func_no_ul">argv</span>if<span class="func_no_ul"></span>endsWith<span class="op_no_ul">(fileName</span>&quot;.s7i&quot;<a class="keywd_no_ul" href="#stats_if-statement">:=</a><a class="op_no_ul" href="#stats_Assignment">parseStri</a>(<span class="func_no_ul">&quot;$include\&quot;seed7_05.s7i\&quot;;\n\</span>\include&quot;<a class="keywd_no_ul" href="#stats_if-statement"></a>&lt;&amp;<span class="func_no_ul"></span>文字通りの<a class="stri" href="#tokens_String_literals">(fileName)</a>&lt;&amp;<a class="op_no_ul" href="#stats_Assignment"></a>&quot;;\n\<span class="func">\const proc:main is func begin noop;end func;\n</span>else<a class="stri" href="#tokens_String_literals">:=</a><a class="stri" href="#tokens_String_literals">parseFile</a>終わり<span class="op_no_ul"></span>if<span class="func_no_ul">if</span><span class="op_no_ul">errorCount</span>(aProgram)<a class="stri" href="#tokens_String_literals">=</a>0<a class="stri" href="#tokens_String_literals">その時</a>writeln<a class="keywd_no_ul" href="#stats_if-statement">(</a>&quot;エラーは見つかりませんでした&quot;<a class="op_no_ul" href="#stats_Assignment">else</a>の<span class="func">索引</span>範囲<a class="keywd_no_ul" href="#stats_if-statement">1</a>へ<a class="keywd_no_ul" href="#stats_if-statement"></a>errorCount<a class="keywd_no_ul" href="#stats_if-statement">(aProgram)</a>do<span class="func">:=</span><span class="op_no_ul">getError</span>writeln<a class="keywd_no_ul" href="#stats_if-statement">(anError.fileName</a>&lt;&amp;<span class="func_no_ul">&quot;(&quot;</span><a class="stri" href="#tokens_String_literals">&lt;&amp;</a>anError.lineNumber<a class="keywd_no_ul" href="#stats_if-statement">&lt;&amp;</a><a class="keywd_no_ul" href="#stats_for-statement">&quot;):&quot;</a><a class="keywd_no_ul" href="#stats_for-statement">&lt;&amp;</a>&lt;&amp;<a class="keywd_no_ul" href="#stats_for-statement"></a>&quot;:&quot;<span class="func"></span>&lt;&amp;<a class="keywd_no_ul" href="#stats_for-statement">writeln</a>if<a class="op_no_ul" href="#stats_Assignment">anError.columnNumber</a>&lt;><span class="func">0</span>その時<span class="func_no_ul">writeln</span>(<span class="op_no_ul">&quot;-&quot;</span><a class="stri" href="#tokens_String_literals">mult</a><span class="op_no_ul">pred</span>(anError.columnNumber)<span class="op_no_ul">&lt;&amp;</span><a class="stri" href="#tokens_String_literals">&quot;^&quot;</a>終わり<span class="op_no_ul"></span>if<span class="op_no_ul">終わり</span><a class="stri" href="#tokens_String_literals">の</a>終わり<span class="op_no_ul"></span>if<span class="func_no_ul">終わり</span><a class="keywd_no_ul" href="#stats_if-statement">if</a>終わり<span class="op_no_ul"></span>機能<a class="keywd_no_ul" href="#stats_if-statement"></a><span class="func_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><span class="op_no_ul"></span><span class="func_no_ul"></span><span class="op_no_ul"></span><a class="stri" href="#tokens_String_literals"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_for-statement"></a><a class="keywd_no_ul" href="#stats_for-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><a class="keywd_no_ul" href="#stats_if-statement"></a><span class="keywd"></span><span class="keywd"></span></pre>
          <a name="errors_Compilation_errors">
        <h3>17.2コンパイルエラー</h3>
          </a>
        <p>コンパイラはコード生成時にチェックを行います。 チェックの結果、いくつかの警告が書き込まれる場合があります。 警告レベルはオプションで指定できる。<span class="link"><tt>-wn</tt></span></p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><th>水準器</th><th>注意</th></tr>

    <tr><td>2</td><td>%sと比較すると、常に%sと評価されます。</td></tr>
    <tr><td>2</td><td>式が&quot;%s&quot;を上げています。</td></tr>
    <tr><td>1</td><td>チェックは非表示ですが&quot;%s&quot;をキャッチします。</td></tr>
    <tr><td>2</td><td>%sのチェックは抑止されますが、それ以外はキャッチします。</td></tr>
    <tr><td>1</td><td>Whenの値が%sと重複しています。</td></tr>
    <tr><td>1</td><td>%sの前回の使用状況。</td></tr>
    <tr><td>1</td><td>セットが空の場合。</td></tr>
    <tr><td>1</td><td>値を一定に保つ必要がある場合。</td></tr>
    <tr><td>2</td><td>変数%sが2つ以上の入出力パラメータ(%s)に使用されています。</td></tr>
    <tr><td>2</td><td>変数%sはinout-parameter(%s)およびref-parameter(%s)として使用されています。</td></tr>
    <tr><td>1</td><td>順方向定義関数が呼び出されました。</td></tr>
    <tr><td>1</td><td>呼び出される関数の順方向定義。</td></tr>
    <tr><td>2</td><td>インタフェース関数の無限再帰です。</td></tr>
</table></dd></dl><p></p>
          <a name="errors_Exceptions">
        <h3>17.3例外</h3>
          </a>
        <p>例外とは、プログラムの実行中に発生する異常なイベントのことです。 例外は、プログラム実行の通常フローを変更します。 例外が、対応する例外に実行を転送する。<a class="link" href="#errors_Handlers">ハンドラ</a>・該当する例外がない場合<a class="link" href="#errors_Handlers">ハンドラ</a>が存在する場合、プログラムは終了します。 次のようなさまざまな例外があります。<tt><a class="exception" href="#errors_MEMORY_ERROR">メモリエラー</a></tt><tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt><tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt><tt><a class="exception" href="#errors_INDEX_ERROR">INDEX_ERROR</a></tt><tt><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></tt><tt><a class="exception" href="#errors_FILE_ERROR">FILE_ERROR</a></tt><tt><a class="exception" href="#errors_DATABASE_ERROR">DATABASE_ERROR</a></tt><tt><a class="exception" href="#errors_GRAPHIC_ERROR">GRAPHIC_ERROR</a></tt>および<tt><a class="exception" href="#errors_ILLEGAL_ACTION">ILLEGAL_ACTION</a></tt>プログラムは<tt><span class="keywd">上げる</span></tt>ステートメントを使用します。 例:</p><pre class="indent">;
<span class="keywd">上げる</span><a class="exception" href="#errors_RANGE_ERROR">範囲エラー</a></pre><p>追加の例外は次のように宣言できます。</p><pre class="indent">enumlit;
<span class="keywd">const</span><a class="type" href="#types_enumeration">例外</a>:MY_ERROR<span class="keywd">は</span></pre><p></p>
          <a name="errors_MEMORY_ERROR">
        <h4>17.3.1 MEMORY_ERROR</h4>
          </a>
        <p>例外<tt><span class="exception">メモリエラー</span></tt>はデータを保持するのに十分なメモリがない場合に呼び出されます。 このエラーはランタイム・ライブラリまたはインタプリタ・カーネルから発生します。 Catching a<tt><span class="exception">メモリエラー</span></tt>可能であるが、慎重に行わなければならない。 関連する変数<tt><span class="exception">メモリエラー</span></tt>が不正な値を持つ場合がある。A<tt><span class="exception">メモリエラー</span></tt>は、以下のタイプの様々な操作によって発生する可能性がある:</p><dl><dt></dt><dd><tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_struct">構造体</a></tt><tt><a class="type" href="#types_hash">ハッシュ</a></tt><tt><a class="type" href="#types_file">ファイルする</a></tt><tt><a class="type" href="#types_func">機能</a></tt><tt><a class="type" href="#types_proc">proc</a></tt><tt><a class="type" href="#types_reference">参考</a></tt><tt><a class="type" href="#types_string">文字列</a></tt></dd><dt></dt><dd>さらに、インタプリタカーネルもこの例外を発生させるかもしれません。</dd></dl><p></p>
          <a name="errors_NUMERIC_ERROR">
        <h4>17.3.2 NUMERIC_ERROR</h4>
          </a>
        <p>例外<tt><span class="exception">NUMERIC_ERROR</span></tt>数値演算が正しい結果を提供できない場合に上げられます。 これには、0除算、負の指数による整数の累乗、負の数の平方根、負の数の対数など、数学的に定義されていないものが含まれます。<tt><span class="exception">NUMERIC_ERROR</span></tt>以下の数種類の操作で発生させることができます。</p><dl><dt>以下から挙げることができます。<tt><a class="type" href="#types_integer">整数</a></tt>操作:</dt><dd><span class="op"></span><span class="op">**</span><span class="op">div</span><span class="op">レム</span><span class="op">mdiv</span><span class="op">mod</span><span class="func">sqrt</span><span class="func">log2</span><span class="func">log10</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>操作:</dt><dd><span class="op"></span><span class="op">**</span><span class="op">div</span><span class="op">レム</span><span class="op">mdiv</span><span class="op">mod</span><span class="func">sqrt</span><span class="func">log2</span><span class="func">log10</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_rational">合理的な</a></tt>操作:</dt><dd><span class="op">/</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_bigRational">bigRational</a></tt>操作:</dt><dd><span class="op">/</span></dd></dl>
<p>具体的には、次のような場合に数値エラーが発生します。</p><ul>
    <li>部門(<span class="op">div</span><span class="op">レム</span><span class="op">mdiv</span><span class="op">mod</span><span class="op">/</span>)をゼロでリセットします。 例:<tt>1<span class="op">div</span>0</tt>上げる<tt><span class="exception">NUMERIC_ERROR</span></tt><tt><a class="type" href="#types_float">浮かぶ</a></tt>ゼロ除算では昇給しない<tt><span class="exception">NUMERIC_ERROR</span></tt>を返す。<tt><span class="var">インフィニティ</span></tt>または<tt><span class="op">-</span><span class="var">インフィニティ</span></tt>で行ないます。</li>
    <li><span class="op">累乗</span>(<span class="op">**</span>)指数が負の場合<tt><a class="type" href="#types_integer">整数</a></tt>例:<tt>2<span class="op">**</span>(-1)</tt>上げる<tt><span class="exception">NUMERIC_ERROR</span></tt></li>
    <li>機能(<span class="func">sqrt</span><span class="func">log2</span><span class="func">log10</span><span class="op"></span>)は、正の引数に対してのみ定義されます。 例:<tt><span class="func">sqrt</span>(-1)</tt>上げる<tt><span class="exception">NUMERIC_ERROR</span></tt></li>
</ul><p></p>
          <a name="errors_OVERFLOW_ERROR">
        <h4>17.3.3 OVERFLOW_ERROR</h4>
          </a>
        <p>整数オーバーフローが発生するのは、計算の結果が<tt><a class="type" href="#types_integer">整数</a></tt>変数。 これは、結果が次の場合に発生します。<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>またはより大きい<tt><a class="type" href="#types_integer">整数</a><span class="var">最後の</span></tt></p><dl><dt>以下から挙げることができます。<tt><a class="type" href="#types_integer">整数</a></tt>操作:</dt><dd><span class="op">-</span>(標識)<span class="op">+</span><span class="op">-</span><span class="op">*</span><span class="op">**</span><span class="op">div</span><span class="op">レム</span><span class="op">mdiv</span><span class="op">mod</span><span class="op">&lt;&lt;</span><span class="op">>></span><span class="op">+:=</span><span class="op">-:=</span><span class="op">*:=</span><span class="op">&lt;&lt;:=</span><span class="op">>>:=</span><span class="op"></span><span class="func">abs</span><span class="func">水</span><span class="func">pred</span><span class="func">増加</span><span class="func">decr</span></dd></dl>
<p>具体的には、以下の条件でオーバーフローが発生する可能性があります。</p><ul>
    <li><span class="link">否定</span>は、2の補数表現では対応する正の値がないため、オーバーフローする可能性がある。<span class="link">最大の負の整数</span>例:<tt><span class="op">-</span><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>上げる<tt><span class="exception">OVERFLOW_ERROR</span></tt></li>
    <li><span class="op">追加</span><span class="op">引き算</span><span class="op">増殖</span>および<span class="op">累乗</span>(<span class="op">+</span><span class="op">-</span><span class="op">*</span><span class="op">**</span><span class="func">水</span><span class="func">pred</span>)結果が通常より少ない場合、オーバーフローを引き起こします。<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>またはより大きい<tt><a class="type" href="#types_integer">整数</a><span class="var">最後の</span></tt></li>
    <li>変数を変更する算術演算(<span class="op">+:=</span><span class="op">-:=</span><span class="op">*:=</span><span class="func">増加</span><span class="func">decr</span>)変数が<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>またはより大きい<tt><a class="type" href="#types_integer">整数</a><span class="var">最後の</span></tt></li>
    <li>除算<tt><span class="op">div</span></tt>および<tt><span class="op">mdiv</span></tt>除算によってあふれることがある<tt>-1</tt>は、被除数を無効にするのと同じである。 例:<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span><span class="op">div</span>-1</tt>上げる<tt><span class="exception">OVERFLOW_ERROR</span></tt></li>
    <li><span class="link">余り</span>および<span class="link">モジュロ</span>上げるように定義される<tt><span class="exception">OVERFLOW_ERROR</span></tt>被除数が<span class="link">最大の負の整数</span>であり、除数は<tt>-1</tt>例:<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span><span class="op">レム</span>-1</tt>上げる<tt><span class="exception">OVERFLOW_ERROR</span></tt>これは、基礎となるCコードのいわゆる未定義動作を引き起こす可能性があるため、オーバーフローとして定義されています。<li>すべてのシフト操作(<tt><span class="op">&lt;&lt;</span></tt><tt><span class="op">>></span></tt><span class="op">&lt;&lt;:=</span>および<tt><span class="op">>>:=</span></tt>)シフト量が負または等しい場合にオーバーフローを引き起こします。<tt>64</tt></li>
    <li>左シフト演算(<tt><span class="op">&lt;&lt;</span></tt>および<span class="op">&lt;&lt;:=</span>)シフト結果がより小さくなる場合にオーバーフローを引き起こすこともあります。<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>またはより大きい<tt><a class="type" href="#types_integer">整数</a><span class="var">最後の</span></tt></li>
    <li>二項係数(<tt><span class="op"></span></tt>)を実行した場合、結果が<tt><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></tt>またはより大きい<tt><a class="type" href="#types_integer">整数</a><span class="var">最後の</span></tt></li>
    <li>絶対値を計算する<span class="func">abs</span>で呼び出された場合、オーバーフローする可能性があります。<span class="link">最大の負の整数</span>例:<tt><span class="func">abs</span>(<a class="type" href="#types_integer">整数</a><span class="var">1番目</span>)</tt>上げる<tt><span class="exception">OVERFLOW_ERROR</span></tt></li>
</ul><p>インタプリタは常に整数オーバーフローの有無をチェックします。 デフォルトでは<span class="link">編集者</span>は整数オーバーフローをチェックするコードを生成する。 オプション<span class="link"><tt>-so</tt></span>を使用すると、整数オーバーフローチェックの生成を抑制することができます。 オーバーフロー状況が発生したが、オーバーフローチェックがオフになっている場合(<span class="link"><tt>-so</tt></span>)、動作は未定義です(「」の章を参照してください)。<a class="link" href="#errors_Suppressing_exception_checks">17.6例外チェックの抑止</a>)。</p><p>別のオーバーフロー例外により、オーバーフローの状況を簡単に把握できます。 すべてのオーバーフロー状況。ここで<tt><span class="exception">OVERFLOW_ERROR</span></tt>未定義の動作を持つCの状況に対応します。 Seed7 のオーバーフローの概念は、オーバーフローチェックがオフの場合に単純なCコードを生成できるように設計されています。</p><p><span class="link">コンパイラ</span>最適化(例えば<span class="link"><tt>-oc2</tt></span>または<span class="link"><tt>-oc3</tt></span>)は、オーバーフローの可能性を減らすことができます。 最適化されたプログラムでは、オーバーフローを回避し、代わりに正しい結果が計算されるように、式が言い換えられることがあります。 次の式を考えてみましょう。</p><pre class="indent">
数

<span class="op">+</span><a class="type" href="#types_integer">整数</a><span class="var">最後の</span><span class="op">+</span><a class="type" href="#types_integer">整数</a><span class="var">1番目</span></pre><p>もし<tt>数</tt>範囲内<tt><span class="func">水</span>(<a class="type" href="#types_integer">整数</a><span class="var">1番目</span>)</tt>および<tt>0</tt>式が評価され、オーバーフローは発生しません。<tt>数</tt>例外<tt><span class="exception">OVERFLOW_ERROR</span></tt>を上げます。 上記の式を最適化すると、次のように言い換えることができます。</p><pre class="indent">(数)
<span class="func">pred</span></pre><p>この式はトリガするだけです<tt><span class="exception">OVERFLOW_ERROR</span></tt>numberが次の値の場合:<a class="type" href="#types_integer">整数</a><span class="var">1番目</span></p><p>オーバーフローチェックでは、整数オーバーフローが常に発生することが保証されます。<tt><span class="exception">OVERFLOW_ERROR</span></tt>しかし、あなたは当てにできない<tt><span class="exception">OVERFLOW_ERROR</span></tt>正しい結果を返す別の方法がある場合にはエラーが発生します。</p>
          <a name="errors_INDEX_ERROR">
        <h4>17.3.4 INDEX_ERROR</h4>
          </a>
        <p>An<tt><span class="exception">INDEX_ERROR</span></tt>にアクセスするためにインデックスが使用された場合に発生します。<tt><a class="type" href="#types_array">配列</a></tt><tt><a class="type" href="#types_string">文字列</a></tt><tt><span class="type">bstring</span></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt>実際に存在する要素を超えた要素。 例:An attempt to get a element of a<tt><a class="type" href="#types_string">文字列</a></tt><tt><span class="type">bstring</span></tt>または<tt><a class="type" href="#types_ref_list">参照リスト</a></tt>負またはゼロの指数上昇で<tt><span class="exception">INDEX_ERROR</span></tt></p><dl><dt>以下から挙げることができます。<tt><a class="type" href="#types_array">配列</a></tt>操作:</dt><dd><span class="op">[索引]</span><span class="op">[索引.]</span><span class="op">[. 索引]</span><span class="op">[start. 停止]</span><span class="op">[index len length]</span><span class="func">挿入する</span><span class="func">取り除く</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_string">文字列</a></tt>操作:</dt><dd><span class="op">[索引]</span><span class="op">[索引.]</span><span class="op">[. 索引]</span><span class="op">[start. 停止]</span><span class="op">[index len length]</span><span class="op">[index fixLen length]</span><span class="op">@:=[index]char</span><span class="op">@:=[index]string</span></dd><dt>以下から挙げることができます。<tt><span class="type">bstring</span></tt>操作:</dt><dd><span class="op">[索引]</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_hash">ハッシュ</a></tt>操作:</dt><dd><span class="op">[</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_ref_list">参照リスト</a></tt>操作:</dt><dd><span class="op">[索引]</span><span class="op">@:=[index]要素</span></dd></dl>
<p>インタプリタは、索引が既存の要素を参照しているかどうかを常にチェックします。 デフォルトでは<span class="link">編集者</span>インデックスが既存の要素を参照しているかどうかをチェックするコードを生成します。 オプション<span class="link"><tt>-si</tt></span>を使用すると、インデックスチェックの生成を抑制できます。 存在しない要素が参照された場合、インデックスチェックが(<span class="link"><tt>-si</tt></span>)、動作は未定義です(「」の章を参照してください)。<a class="link" href="#errors_Suppressing_exception_checks">17.6例外チェックの抑止</a>)。</p>
          <a name="errors_RANGE_ERROR">
        <h4>17.3.5範囲エラー</h4>
          </a>
        <p>多くの関数は有効な引数の範囲を定義し<tt><span class="exception">範囲エラー</span></tt>この範囲に違反した場合。</p><dl><dt>以下から挙げることができます。<tt><a class="type" href="#types_boolean">ブール</a></tt>操作:</dt><dd><span class="op">conv</span><span class="op">解析する</span><span class="func">ブール</span><span class="func">水</span><span class="func">pred</span><span class="func">ブール</span><span class="func">ランド</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_integer">整数</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">基数</span><span class="op">RADIX</span><span class="op">sci</span><span class="func">ランド</span><span class="func">整数</span><span class="func">バイト</span><span class="func">bytes2Int</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_bigInteger">bigInteger</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">基数</span><span class="op">RADIX</span><span class="op">sci</span><span class="func">ランド</span><span class="func">整数</span><span class="func">バイト</span><span class="func">bytes2BigInt</span><span class="func">ord</span><span class="func">bigInteger</span><span class="func">bitLength</span><span class="func">modInverse</span><span class="func">modPow</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_rational">合理的な</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">指</span><span class="op">sci</span><span class="func">合理的な</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_bigRational">bigRational</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">指</span><span class="op">sci</span><span class="func">bigRational</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_float">浮かぶ</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">指</span><span class="op">sci</span><span class="func">浮かぶ</span><span class="func">丸い</span><span class="func">切断する</span><span class="func">ランド</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_complex">複雑なさま</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="op">指</span><span class="op">sci</span><span class="func">複雑なさま</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_char">char</a></tt>操作:</dt><dd><span class="op">conv</span><span class="op">解析する</span><span class="func">chr</span><span class="func">char</span><span class="func">ランド</span><span class="func">char</span><span class="func">trimValue</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_string">文字列</a></tt>操作:</dt><dd><span class="op">mult</span><span class="func">pos</span><span class="func">rpos</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_set">ビットセット</a></tt>操作:</dt><dd><span class="op">conv</span><span class="op">解析する</span><span class="func">ランド</span><span class="func">分</span><span class="func">最大</span><span class="func">次の</span><span class="func">整数</span><span class="func">ビットセット</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_array">配列</a></tt>操作:</dt><dd><span class="op">回</span><span class="func">ランド</span></dd><dt>以下から挙げることができます。<tt><span class="type">ビン32</span></tt>操作:</dt><dd><span class="op">基数</span><span class="op">RADIX</span><span class="func">バイト</span><span class="func">float2MbfBits</span></dd><dt>以下から挙げることができます。<tt><span class="type">bin64</span></tt>操作:</dt><dd><span class="op">基数</span><span class="op">RADIX</span><span class="func">bin64</span><span class="func">バイト</span><span class="func">float2MbfBits</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_category">カテゴリ</a></tt>操作:</dt><dd><span class="op">解析する</span><span class="func">カテゴリ</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_ref_list">参照リスト</a></tt>操作:</dt><dd><span class="func">pos</span></dd><dt>以下から挙げることができます。<tt><a class="type" href="#types_file">ファイルする</a></tt>操作:</dt><dd><span class="func">開いたさま</span><span class="func">openUtf8</span><span class="func">openUtf16le</span><span class="func">openUtf16be</span><span class="func">openUtf16</span><span class="func">openInetSocket</span><span class="func">書く</span><span class="func">writeln</span><span class="func">取得</span><span class="func">長さ</span><span class="func">切り詰める</span><span class="func">シークする</span><span class="func">話す</span><span class="func">飛ばす</span></dd></dl>
<p></p>
          <a name="errors_FILE_ERROR">
        <h4>17.3.6 FILE_ERROR</h4>
          </a>
        <p>A<tt><span class="exception">FILE_ERROR</span></tt>は、ファイルに対する不正な操作が行われた場合に発生します。</p><dl><dt>以下の関数で呼び出すことができます。</dt><dd><a class="func" href="#os_fileType">ファイルタイプ</a><a class="func" href="#os_fileType">ファイルタイプL</a><a class="func" href="#os_fileSize">ファイルサイズ</a><a class="func" href="#os_fileSize">bigFileSize</a><a class="func" href="#os_getFileMode">getFileMode</a><a class="func" href="#os_setFileMode">setFileMode</a><a class="func" href="#os_getATime">getATime</a><a class="func" href="#os_setATime">setATime</a><a class="func" href="#os_getCTime">getCTime</a><a class="func" href="#os_getMTime">getMTime</a><a class="func" href="#os_setMTime">setMTime</a><a class="func" href="#os_getOwner">getOwner</a><a class="func" href="#os_setOwner">所有者を設定する</a><a class="func" href="#os_getGroup">getGroup</a><a class="func" href="#os_setGroup">setGroup</a><a class="func" href="#os_readDir">readDir</a><a class="func" href="#os_removeFile">removeFile</a><a class="func" href="#os_removeTree">removeTree</a><a class="func" href="#os_moveFile">moveFile</a><a class="func" href="#os_cloneFile">cloneFile</a><a class="func" href="#os_copyFile">copyFile</a><a class="func" href="#os_readlink">readlink</a><a class="func" href="#os_symlink">シンボリックリンク</a>,hasNext, seek, tell, bigTell, setbuf, write<span class="func">inetSocketAddress</span><span class="func">inetListenerAddress</span><span class="func">openInetSocket</span><span class="func">openInetListener</span></dd></dl>
<p></p>
          <a name="errors_DATABASE_ERROR">
        <h4>17.3.7 DATABASE_ERROR</h4>
          </a>
        <p>例外<tt><span class="exception">DATABASE_ERROR</span></tt>データベース関数によって発生する可能性があります。 もし<tt><span class="exception">DATABASE_ERROR</span></tt>を用いて、エラーの原因に関する情報を得ることができます。</p><pre class="indent">)
<span class="keywd">const</span><a class="type" href="#types_func">機能</a><a class="type" href="#types_string">文字列</a>:<b><span class="func">errMessage</span></b>(<span class="exception">DATABASE_ERROR</span></pre><p>データベースおよびSeed7データベースドライバからのメッセージがあります。 データベースドライバには次のようなメッセージが表示されます。</p><pre class="indent">動的ライブラリの検索に失敗しました:libclntsh.so
</pre><p>これは、コネクタライブラリが見つからなかったことを示します。 この場合は、コネクタライブラリの場所を環境変数LD_LIBRARY_PATHで指定することができます。</p>
          <a name="errors_GRAPHIC_ERROR">
        <h4>17.3.8 GRAPHIC_ERROR</h4>
          </a>
        <p>例外<tt><span class="exception">GRAPHIC_ERROR</span></tt>グラフィックドライバによって発生する場合があります。 基本となるグラフィックライブラリ関数がエラーを報告した場合<tt><span class="exception">GRAPHIC_ERROR</span></tt>を上げます。</p>
          <a name="errors_ILLEGAL_ACTION">
        <h4>17.3.9 ILLEGAL_ACTION</h4>
          </a>
        <p>例外<tt><span class="exception">ILLEGAL_ACTION</span></tt>は、プリミティブなアクションが正当なアクションを指していない場合、インタプリタカーネルによって呼び出されることがある。 このチェックは、s7インタプリタが<tt>&#39;#define WITH_ACTION_CHECK&#39;</tt>その<tt><span class="exception">ILLEGAL_ACTION</span></tt>プリミティブ・アクションACT_ILLEGALが実行されると例外が発生します。</p>
          <a name="errors_Handlers">
        <h3>17.4ハンドラ</h3>
          </a>
        <p>EXCEPTIONをキャッチするには、次のハンドラ構造を使用できます。</p><pre class="indent">
数:=1
0;



:
number:=1;

;
<span class="keywd">ブロック</span>div<span class="op">例外</span>捕まえる<span class="keywd"></span>NUMERIC_ERROR<span class="keywd">エンドブロック</span><a class="exception" href="#errors_NUMERIC_ERROR"></a><span class="keywd"></span></pre><p>いくつかの例外をキャッチすることもできます。</p><pre class="indent">doSomething(someValue);



);

);

;
<span class="keywd">ブロック</span>例外<span class="keywd">捕まえる</span><span class="keywd">メモリエラー</span>:writeln(<a class="exception" href="#errors_MEMORY_ERROR">&quot;MEMORY_ERROR&quot;</a>捕まえる<span class="stri"></span>NUMERIC_ERROR<span class="keywd">:writeln(</span>&quot;NUMERIC_ERROR&quot;<a class="exception" href="#errors_NUMERIC_ERROR">エンドブロック</a><span class="stri"></span><span class="keywd"></span></pre><p>An<tt><span class="keywd">そうでなければ</span></tt>handler:他のハンドラでキャッチされていない例外をキャッチします。</p><pre class="indent">doSomething(someValue);



);

);

;
<span class="keywd">ブロック</span>例外<span class="keywd">捕まえる</span><span class="keywd">範囲エラー</span>:writeln(<a class="exception" href="#errors_RANGE_ERROR">&quot;RANGE_ERROR&quot;</a>そうでなければ<span class="stri">:writeln(</span>「その他の例外」<span class="keywd">エンドブロック</span><span class="stri"></span><span class="keywd"></span></pre><p></p>
          <a name="errors_Trace_exceptions">
        <h3>17.5トレースの例外</h3>
          </a>
        <p>インタプリタオプション<span class="link"><tt>-te</tt></span>を使用して、例外およびハンドラをトレースできます。例外が発生した場合は、次のように記述されます。</p><pre class="indent">***integer.s7iで例外NUMERIC_ERRORが発生しました(118)
{160000 div fuel_max}at lander.sd7(836)
***アクション&quot;INT_DIV&quot;

***使用できるコマンドは次のとおりです。
RETURN続行
※解約
#Terminate with stack trace
/Trigger SIGFPE
n番号付きで例外を発生させます(例:!1はMEMORY_ERRORを発生させます)
</pre><p>詳細:<ul>
    <li>リターンキーを押すと、プログラムは変更なしで続行します。</li>
    <li>プレス<tt>*</tt>RETURNを押すとプログラムは直ちに終了します。</li>
    <li>プレス<tt>#</tt>RETURNはスタックトレースを書き込んでプログラムを終了します。 例:</p><pre class="indent">
***例外NUMERIC_ERRORがで発生したため、プログラムは終了しました
{integer:<SYMBOLOBJECT>*NULL_ENTITY_OBJECT*div fuel_max}

スタック:
in(val integer:被除数)div(val integer:除数)at integer.s7i(118)
in init_display at lander.sd7(836)
lander.sd7(906)のセットアップ
主にlander.sd7(1536)
</pre></li>
    <li>プレス<tt>/</tt>RETURNがシグナルSIGFPEをトリガします。 インタプリタがデバッガから起動されていると、デバッガが起動されます。</li>
</ul>
          <a name="errors_Stack_trace">
        <h3>17.6スタックトレース</h3>
          </a>
        <p>例外がキャッチされない場合、プログラムは終了し、s7インタプリタはスタックトレースを書き込みます。</p><pre class="indent">***捕捉できない例外NUMERIC_ERRORがで発生しました
{integer:&lt;SYMBOLOBJECT>*NULL_ENTITY_OBJECT*div fuel_max}

スタック:
in(val integer:被除数)div(val integer:除数)at integer.s7i(118)
in init_display at lander.sd7(836)
lander.sd7(906)のセットアップ
主にlander.sd7(1536)
</pre><p>スタック・トレースは<tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt>によって提起された<tt><span class="keywd">div</span></tt>操作。 この操作は118行目で定義されています。<tt><span class="lib">integer.s7i</span></tt>さらに興味深いのは<tt><span class="keywd">div</span></tt>が関数から呼び出されました。<tt>&#39;init_display&#39;</tt>の836行目で<tt><span class="prog">lander.sd7</span></tt>A<tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt>で<tt><span class="keywd">div</span></tt>ゼロ除算が原因と考えられます。 簡単な検査<tt><span class="prog">lander.sd7</span></tt>への代入が<tt>&#39;fuel_max&#39;</tt>は、スタックトレースの動作を示すためにコメントアウトされています。</p><p>コンパイルされたプログラムでは、はるかに短いクラッシュメッセージが作成されます。</p><pre class="indent">***sigutl.c(218)で未捕捉の例外NUMERIC_ERRORが発生しました
</pre><p>詳細情報を取得するには、次の2つの方法があります。</p><ul>
    <li>代わりに、インタプリタでプログラムを起動してください。</li>
    <li>オプションでプログラムをコンパイルする<span class="link"><tt>-g</tt></span><span class="link"><tt>-e</tt></span>デバッガから起動してください。</li>
</ul><p>もし<span class="link">s7c</span>オプションを指定して呼び出す<span class="link"><tt>-g</tt></span>Cコンパイラにデバッグ情報の生成を指示します。 このようにして、gdbのようなデバッガがプログラムを実行し、情報を提供できます。 オプション<span class="link"><tt>-e</tt></span>捕捉されていない例外が発生した場合に、信号を送信するコードを生成するようにコンパイラに指示します。 このオプションを使用すると、デバッガはキャッチされなかったSeed7例外を処理できます。 に注意してください。<span class="link"><tt>-e</tt></span>はシグナルSIGFPEを送る。 これは、その例外が浮動小数点演算に関連しない場合でも行われます。</p><pre class="indent">/s7 s7c-g-e lander
gdb./lander
</pre><p>そうすれば、デバッガはプログラムを実行し、クラッシュが発生した場合にバックトレースを書き込むことができるはずです。</p><pre class="indent">(gdb)run
起動プログラム:/home/tm/seed7_5/prg/lander

プログラム受信信号SIGFPE、演算例外
0x000000000041b942 in o_3912_init_display()at lander.sd7:839
839 fuel_gauge:=40*rocket.fuel div fuel_max;
(gdb)bt
#0 0x000000000041b942 in o_3912_init_display()at lander.sd7:839
#1 0x000000000041c2e5 in o_3917_setup()at lander.sd7:908
#2 0x0000000000421fe1 in main(argc=1, argv=0x7fffffffdf28)at lander.sd7:1541
</pre><p>Seed7ソースではなく、生成されたCプログラムをデバッグすることが役立つ場合があります。 オプション<span class="link"><tt>-g-debug_c</tt></span>はデバッグ情報を作成します。これは、Seed7コンパイラによって生成されたCプログラムを参照します。</p><pre class="indent">/s7 s7c-g-debug_c-e lander
gdb./lander
</pre><p>デバッガは一時ファイルを参照します。<tt><span class="stri">tmp_lander.c</span></tt>:</p><pre class="indent">(gdb)run
起動プログラム:/home/tm/seed7_5/prg/lander

プログラム受信信号SIGFPE、演算例外
0x08068518 in o_2541_init_display()at tmp_lander.c:19727
1万9727_2428_fuel_gauge=((40)*(((structType)(o_2338_rocket))->stru[10].value.intValue/*->o_2336_fuel*/))/(o_2431_fuel_max);
(gdb)bt
#0 0x08068518 in o_2541_init_display()at tmp_lander.c:19727
#1 0x08068c21 in o_2546_setup()at tmp_lander.c:19864
#2 0x0806c304 at tmp_lander.c:21188 in main(argc=1, argv=0xbffff324)
</pre><p>一部のSeed7例外はシグナルを送信しません。 これにより、デバッガは捕捉できない例外が発生したことを認識できなくなります。 コンパイラオプション<span class="link"><tt>-e</tt></span>このような状況で役立ちます。 これは、キャッチされていない例外が発生した場合に信号を送信するコードを生成するようにコンパイラに指示します。 これにより、デバッガは捕捉できなかったSeed7例外のバックトレースを表示できます。</p>
          <a name="errors_Suppressing_exception_checks">
        <h3>17.7例外チェックの抑止</h3>
          </a>
        <p>Seed7プログラムは<span class="link">コンパイルされた</span>オプションで<span class="link"><tt>-sx</tt></span>例外チェックの生成を抑止します。 抑制されたチェック<span class="keywd">x</span>は以下のリストからの文字で指定される:</p><ul>
    <li><b>d</b>チェックの生成を抑止します。<a class="link" href="#errors_NUMERIC_ERROR">0による整数除算</a></li>
    <li><b>i</b>の生成を抑制する<a class="link" href="#errors_INDEX_ERROR">索引チェック</a>(例:string, array)。</li>
    <li><b>o</b>の生成を抑制する<a class="link" href="#errors_OVERFLOW_ERROR">integer overflow</a>チェック。</li>
    <li><b>r</b>の生成を抑制する<a class="link" href="#errors_RANGE_ERROR">範囲</a>チェック。</li>
</ul><p>例外チェックがオフに設定されていても(<span class="link"><tt>-s</tt></span>)、動作は未定義です。 この場合、次のことが起こり得ます。</p><ul>
    <li>例外が未だに提起されている。</li>
    <li>別の例外を挙げる。</li>
    <li>プログラムがハングアップする。</li>
    <li>プログラムがクラッシュする。</li>
    <li>何らかの不要データ値で計算が続行されます。 このゴミの値が危険なことを引き起こす可能性があります。 あなたのプログラムで計算したX線量は、まるっきり違っているかもしれないのです。 プログラムが橋の静力学を間違って計算する可能性があります。</li>
</ul><p>未定義動作とはC言語や他のプログラム言語の言語仕様で使われる用語である。 未定義動作とは通常、プログラムの動作が予測不能であることを意味します。 通常、Seed7はあらゆる状況で明確な動作をします。 C言語の言語仕様が未定義の動作を参照している状況でも。</p><p>A<a class="link" href="#errors_Handlers">ハンドラ</a>例外が確実に機能するためには、例外のチェックが実行されている必要があります。 その<span class="link">編集者</span>が以下の場合に警告<span class="link"><tt>-s</tt></span>が使われ<a class="link" href="#errors_Handlers">ハンドラ</a>例外として 例:</p><pre class="indent">
***example.sd7(123):Catch of
ただし、抑制は表示されません。
<span class="exception">OVERFLOW_ERROR</span></pre><p>特定の例外を発生させず<a class="link" href="#errors_Handlers">ハンドラ</a>この例外は、その例外のチェックなしでコンパイルされると考えることができます。 例外チェックの省略を決定するためには、慎重なプログラム分析とテスト(例外は決して発生させるべきではありません)が必要です。</p>
          <a name="errors_Signals">
        <h3>17.8信号</h3>
          </a>
        <p>シグナルはイベントの非同期的な通知です。 プログラムの終了要求など、外部からイベントが発生する可能性があります。 このイベントは、メモリーアクセス違反(segfault)などのプログラム自体から発生することもあります。 いくつかのシグナルは、Seed7ランタイム・ライブラリによって処理されます。 インタプリタそれぞれのコンパイラオプション<span class="link"><tt>-ts</tt></span>を使用すると、Seed7プログラム(下記参照)に信号を送信したときの動作を制御できます。 以下の信号がSeed7で扱われます。</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  <tr><th>信号機</th><th>特殊ハンドラ</th><th>なしでの行動<span class="link"><tt>-ts</tt></span></th><th>行動<span class="link"><tt>-ts</tt></span></th></tr>

  <tr><td>
          <a name="errors_SIGABRT">SIGABRT</a>
        </td><td>上げる<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt></td><td>例外を発生させる</td><td>決めるためのダイアログ</td></tr>
  <tr><td>
          <a name="errors_SIGILL">SIGILL</a>
        </td><td>上げる<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt></td><td>例外を発生させる</td><td>決めるためのダイアログ</td></tr>
  <tr><td>
          <a name="errors_SIGTRAP">SIGTRAP</a>
        </td><td>上げる<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt></td><td>例外を発生させる</td><td>決めるためのダイアログ</td></tr>
  <tr><td>
          <a name="errors_SIGINT">SIGINT</a>
        </td><td>-</td><td>メッセージで終了</td><td>決めるためのダイアログ</td></tr>
  <tr><td>
          <a name="errors_SIGFPE">SIGFPE</a>
        </td><td>上げる<tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt></td><td>例外を発生させる</td><td>決めるためのダイアログ</td></tr>
  <tr><td>
          <a name="errors_SIGTERM">SIGTERM</a>
        </td><td>-</td><td>メッセージで終了</td><td>メッセージで終了</td></tr>
  <tr><td>
          <a name="errors_SIGSEGV">SIGSEGV</a>
        </td><td>-</td><td>プログラムを終了する</td><td>メッセージで終了</td></tr>
  <tr><td>
          <a name="errors_SIGPIPE">SIGPIPE</a>
        </td><td>-</td><td>無視</td><td>無視</td></tr>
  <tr><td>
          <a name="errors_SIGWINCH">信号ウィンチ</a>
        </td><td>コンソールのサイズ変更</td><td>-</td><td>-</td></tr>
  <tr><td>
          <a name="errors_SIGALRM">SIGALRM</a>
        </td><td>しばらく待ってください</td><td>-</td><td>-</td></tr>
</table></dd></dl><p>実際のCコンパイラとオペレーティングシステムに応じて、シグナルSIGABRT、SIGILL、SIGTRAPが引き数として使用されることもある。<tt><a class="exception" href="#errors_OVERFLOW_ERROR">OVERFLOW_ERROR</a></tt>信号SIGFPEを使って<tt><a class="exception" href="#errors_NUMERIC_ERROR">NUMERIC_ERROR</a></tt></p><p>インタプリタがコンパイラオプション<span class="link"><tt>-ts</tt></span>一部のシグナル(上の表を参照)はコンソールでダイアログを起動します。 例:</p><pre class="indent">***シグナルSIGINT発生

***使用できるコマンドは次のとおりです。
RETURN続行
※解約
/Trigger SIGFPE
n番号付きで例外を発生させます(例:!1はMEMORY_ERRORを発生させます)
</pre><p>ユーザはコマンドを入力し、リターンキーで起動することができます。 プログラムがコンソールでの入力を待っていた場合は、入力を再度入力することができます。</p><pre class="indent">再入力>
</pre><p>SIGFPEトリガはプログラムがデバッガで実行される場合に便利です。 この場合SIGFPEはデバッガプロンプトを起動します。 例外(例:MEMORY_ERROR)を発生させることで、スタックトレースを取得することができます(これはインタプリタでのみ動作します)。 コンパイルされたプログラムは、スタックトレースを取得するためにデバッガで実行する必要があります。</p>
          <a name="errors_Other_errors_and_warnings">
        <h3>17.9その他のエラーおよび警告</h3>
          </a>
        <p><dl><dt>メモリが足りません。 解析が終了しました。</dt><dd>このエラーメッセージは、解析エラー1(<a class="link" href="#errors_OUT_OF_HEAP_SPACE">ヒープ領域不足</a>)。 内部ヒープ情報とともに、この問題が発生したアナライザ・ソース・コードのファイル名と行番号が表示されます。</dd><dt>mainのシステム宣言がありません。</dt><dd>各プログラムには、どのプロシージャを最初に起動するかを記述したシステム宣言が必要です。</dd><dt>例外%s発生</dt><dd>トレースレベルで例外のトレースを指定している場合は、例外とハンドラがこのメッセージとともに表示され、ユーザーはEnterキーを入力して受け入れる必要があります。</dd><dt>アクション$%sには%sではなく%sが必要です</dt><dd>このエラーは、アクションが間違ったプリミティブ値で何かを行おうとした場合に発生する可能性があります。 たとえば、INT_ADDを使用して整数を文字列に追加します。 分析段階では正しい型をチェックするため、このエラーは基本ライブラリの定義が間違っている場合にのみ発生します。</dd><dt>アクション$%s(空の値)</dt><dd>このエラーは、アクションがNULLを使用して何かをしようとし、NULLが値として許可されていない場合に発生する可能性があります。 もし解析が正常に動作していれば、これは起きないはずです。</dd><dt>アクション$%sには定数ではない変数%sが必要です</dt><dd>このエラーは、値を定数に割り当てるアクションで発生する可能性があります。 解析段階では変数オブジェクトをチェックするため、このエラーは基本ライブラリの定義が間違っている場合にのみ発生する。 基本的に、このエラーは、:=,incr, decr, wrd_rd, lin_rd</dd><dt></dl><p></p>
</body>
</html>
